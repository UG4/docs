<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ug4: pcl::OrderedInterface&lt; TType, TContainer, TAlloc &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ug4
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classpcl_1_1_ordered_interface.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classpcl_1_1_ordered_interface-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pcl::OrderedInterface&lt; TType, TContainer, TAlloc &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__ugbase.html">ugbase</a> &raquo; <a class="el" href="group__pcl.html">PCL</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>You may add elements to this interface and iterate over them.  
 <a href="classpcl_1_1_ordered_interface.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="pcl__communication__structs_8h_source.html">pcl_communication_structs.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_ordered_interface_1_1_interface_entry.html">InterfaceEntry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_ordered_interface_1_1_interface_entry_cmp.html">InterfaceEntryCmp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a63a0ff4f94fedfa883de6536d837d707"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classpcl_1_1interface__tags_1_1ordered__interface__tag.html">interface_tags::ordered_interface_tag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_ordered_interface.html#a63a0ff4f94fedfa883de6536d837d707">category_tag</a></td></tr>
<tr class="separator:a63a0ff4f94fedfa883de6536d837d707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2174f3a344bfccb60134fc0604a0ba77"><td class="memItemLeft" align="right" valign="top">typedef ElemContainer::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_ordered_interface.html#a2174f3a344bfccb60134fc0604a0ba77">const_iterator</a></td></tr>
<tr class="separator:a2174f3a344bfccb60134fc0604a0ba77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02fc303432e68743659bf3f93144e4e5"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structpcl_1_1type__traits.html">type_traits</a>&lt; TType &gt;::Elem&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_ordered_interface.html#a02fc303432e68743659bf3f93144e4e5">Element</a></td></tr>
<tr class="separator:a02fc303432e68743659bf3f93144e4e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aaf87ae3ef32df4a64fa2d7cdb70c53"><td class="memItemLeft" align="right" valign="top">typedef ElemContainer::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_ordered_interface.html#a2aaf87ae3ef32df4a64fa2d7cdb70c53">iterator</a></td></tr>
<tr class="separator:a2aaf87ae3ef32df4a64fa2d7cdb70c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5c514062f40a504932875c21e0b53d8"><td class="memItemLeft" align="right" valign="top">typedef TType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_ordered_interface.html#ac5c514062f40a504932875c21e0b53d8">Type</a></td></tr>
<tr class="separator:ac5c514062f40a504932875c21e0b53d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8b90a445fb14789fb9b257123c39f7ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_ordered_interface.html#a2aaf87ae3ef32df4a64fa2d7cdb70c53">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_ordered_interface.html#a8b90a445fb14789fb9b257123c39f7ea">begin</a> ()</td></tr>
<tr class="separator:a8b90a445fb14789fb9b257123c39f7ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaba231ebc0155e0a8f19cc49b0673aea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_ordered_interface.html#a2174f3a344bfccb60134fc0604a0ba77">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_ordered_interface.html#aaba231ebc0155e0a8f19cc49b0673aea">begin</a> () const</td></tr>
<tr class="separator:aaba231ebc0155e0a8f19cc49b0673aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab70a1fad284b3e0ee1bfad23ef7d8c66"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_ordered_interface.html#ab70a1fad284b3e0ee1bfad23ef7d8c66">empty</a> () const</td></tr>
<tr class="separator:ab70a1fad284b3e0ee1bfad23ef7d8c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b82cef21a9e8490dec38c27776a7976"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_ordered_interface.html#a2aaf87ae3ef32df4a64fa2d7cdb70c53">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_ordered_interface.html#a4b82cef21a9e8490dec38c27776a7976">end</a> ()</td></tr>
<tr class="separator:a4b82cef21a9e8490dec38c27776a7976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac25902ba499218c2af12468f60014ccd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_ordered_interface.html#a2174f3a344bfccb60134fc0604a0ba77">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_ordered_interface.html#ac25902ba499218c2af12468f60014ccd">end</a> () const</td></tr>
<tr class="separator:ac25902ba499218c2af12468f60014ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3bd7c23e7821d8ebb4948bd1dcf1a36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_ordered_interface.html#a2aaf87ae3ef32df4a64fa2d7cdb70c53">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_ordered_interface.html#ac3bd7c23e7821d8ebb4948bd1dcf1a36">erase</a> (<a class="el" href="classpcl_1_1_ordered_interface.html#a2aaf87ae3ef32df4a64fa2d7cdb70c53">iterator</a> iter)</td></tr>
<tr class="separator:ac3bd7c23e7821d8ebb4948bd1dcf1a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8371adba709c3191c2a7eb9bda55499"><td class="memTemplParams" colspan="2">template&lt;class TCompare &gt; </td></tr>
<tr class="memitem:aa8371adba709c3191c2a7eb9bda55499"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_ordered_interface.html#a2aaf87ae3ef32df4a64fa2d7cdb70c53">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpcl_1_1_ordered_interface.html#aa8371adba709c3191c2a7eb9bda55499">find_insert_pos_sorted</a> (const <a class="el" href="classpcl_1_1_ordered_interface.html#a02fc303432e68743659bf3f93144e4e5">Element</a> e, TCompare <a class="el" href="classpcl_1_1_ordered_interface.html#a00310ab46a9a5165421f189ae8f8f89f">cmp</a>)</td></tr>
<tr class="memdesc:aa8371adba709c3191c2a7eb9bda55499"><td class="mdescLeft">&#160;</td><td class="mdescRight">find insertion position for an element to be inserted  <a href="classpcl_1_1_ordered_interface.html#aa8371adba709c3191c2a7eb9bda55499">More...</a><br /></td></tr>
<tr class="separator:aa8371adba709c3191c2a7eb9bda55499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeabbb87f4c67dd042a5c4f30e1b29968"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpcl_1_1_ordered_interface.html#a02fc303432e68743659bf3f93144e4e5">Element</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_ordered_interface.html#aeabbb87f4c67dd042a5c4f30e1b29968">get_element</a> (<a class="el" href="classpcl_1_1_ordered_interface.html#a2174f3a344bfccb60134fc0604a0ba77">const_iterator</a> iter) const</td></tr>
<tr class="separator:aeabbb87f4c67dd042a5c4f30e1b29968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbeeb5588895dd0649681116c3900bbf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_ordered_interface.html#a02fc303432e68743659bf3f93144e4e5">Element</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_ordered_interface.html#abbeeb5588895dd0649681116c3900bbf">get_element</a> (<a class="el" href="classpcl_1_1_ordered_interface.html#a2aaf87ae3ef32df4a64fa2d7cdb70c53">iterator</a> iter)</td></tr>
<tr class="separator:abbeeb5588895dd0649681116c3900bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4796f5a650698fb39e21246c811bb88"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_ordered_interface.html#ae4796f5a650698fb39e21246c811bb88">get_local_id</a> (<a class="el" href="classpcl_1_1_ordered_interface.html#a2174f3a344bfccb60134fc0604a0ba77">const_iterator</a> iter) const</td></tr>
<tr class="separator:ae4796f5a650698fb39e21246c811bb88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8878ee8ecb35a2fa3bd549d06b594f73"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_ordered_interface.html#a8878ee8ecb35a2fa3bd549d06b594f73">get_local_id</a> (<a class="el" href="classpcl_1_1_ordered_interface.html#a2aaf87ae3ef32df4a64fa2d7cdb70c53">iterator</a> iter)</td></tr>
<tr class="separator:a8878ee8ecb35a2fa3bd549d06b594f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad59a408f466b6106620cb9d3fb3ca4e4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_ordered_interface.html#ad59a408f466b6106620cb9d3fb3ca4e4">get_target_proc</a> () const</td></tr>
<tr class="separator:ad59a408f466b6106620cb9d3fb3ca4e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6bd3fe237cb03c7938474e043a29e9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_ordered_interface.html#a2aaf87ae3ef32df4a64fa2d7cdb70c53">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_ordered_interface.html#af6bd3fe237cb03c7938474e043a29e9a">insert</a> (const <a class="el" href="classpcl_1_1_ordered_interface.html#a02fc303432e68743659bf3f93144e4e5">Element</a> &amp;elem, <a class="el" href="classpcl_1_1_ordered_interface.html#a2aaf87ae3ef32df4a64fa2d7cdb70c53">iterator</a> insertBefore)</td></tr>
<tr class="memdesc:af6bd3fe237cb03c7938474e043a29e9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an element before the passed iterator.  <a href="classpcl_1_1_ordered_interface.html#af6bd3fe237cb03c7938474e043a29e9a">More...</a><br /></td></tr>
<tr class="separator:af6bd3fe237cb03c7938474e043a29e9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a933c7b505c1acb7baca356010591099e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_ordered_interface.html#a933c7b505c1acb7baca356010591099e">OrderedInterface</a> (int targetProc=-1)</td></tr>
<tr class="separator:a933c7b505c1acb7baca356010591099e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00cc2e223de0041fe699905b0afd792b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_ordered_interface.html#a2aaf87ae3ef32df4a64fa2d7cdb70c53">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_ordered_interface.html#a00cc2e223de0041fe699905b0afd792b">push_back</a> (const <a class="el" href="classpcl_1_1_ordered_interface.html#a02fc303432e68743659bf3f93144e4e5">Element</a> &amp;elem)</td></tr>
<tr class="separator:a00cc2e223de0041fe699905b0afd792b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6c6e78b6001c10823254de7c5352669"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_ordered_interface.html#ad6c6e78b6001c10823254de7c5352669">size</a> () const</td></tr>
<tr class="memdesc:ad6c6e78b6001c10823254de7c5352669"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the number of elements that are stored in the interface.  <a href="classpcl_1_1_ordered_interface.html#ad6c6e78b6001c10823254de7c5352669">More...</a><br /></td></tr>
<tr class="separator:ad6c6e78b6001c10823254de7c5352669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4737c862ffcf5893abaf8aa6b790dfe9"><td class="memTemplParams" colspan="2">template&lt;class TCompare &gt; </td></tr>
<tr class="memitem:a4737c862ffcf5893abaf8aa6b790dfe9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpcl_1_1_ordered_interface.html#a4737c862ffcf5893abaf8aa6b790dfe9">sort</a> (TCompare <a class="el" href="classpcl_1_1_ordered_interface.html#a00310ab46a9a5165421f189ae8f8f89f">cmp</a>)</td></tr>
<tr class="memdesc:a4737c862ffcf5893abaf8aa6b790dfe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">sort the entries in this interface.  <a href="classpcl_1_1_ordered_interface.html#a4737c862ffcf5893abaf8aa6b790dfe9">More...</a><br /></td></tr>
<tr class="separator:a4737c862ffcf5893abaf8aa6b790dfe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eda5984d1304e2071c3e9ce5eb5805c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_ordered_interface.html#a1eda5984d1304e2071c3e9ce5eb5805c">swap</a> (<a class="el" href="classpcl_1_1_ordered_interface.html">OrderedInterface</a> &amp;interface)</td></tr>
<tr class="memdesc:a1eda5984d1304e2071c3e9ce5eb5805c"><td class="mdescLeft">&#160;</td><td class="mdescRight">swaps the content of two interfaces.  <a href="classpcl_1_1_ordered_interface.html#a1eda5984d1304e2071c3e9ce5eb5805c">More...</a><br /></td></tr>
<tr class="separator:a1eda5984d1304e2071c3e9ce5eb5805c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a00310ab46a9a5165421f189ae8f8f89f"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_ordered_interface.html#a00310ab46a9a5165421f189ae8f8f89f">cmp</a> (<a class="el" href="classpcl_1_1_ordered_interface.html#a2aaf87ae3ef32df4a64fa2d7cdb70c53">iterator</a> iter1, <a class="el" href="classpcl_1_1_ordered_interface.html#a2aaf87ae3ef32df4a64fa2d7cdb70c53">iterator</a> iter2, const std::input_iterator_tag &amp;)</td></tr>
<tr class="memdesc:a00310ab46a9a5165421f189ae8f8f89f"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if iter1 &lt; iter2.  <a href="classpcl_1_1_ordered_interface.html#a00310ab46a9a5165421f189ae8f8f89f">More...</a><br /></td></tr>
<tr class="separator:a00310ab46a9a5165421f189ae8f8f89f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a03959a54ffc81c2108f54f7a8ba2a872"><td class="memItemLeft" align="right" valign="top">typedef TContainer&lt; <a class="el" href="structpcl_1_1_ordered_interface_1_1_interface_entry.html">InterfaceEntry</a>, TAlloc&lt; <a class="el" href="structpcl_1_1_ordered_interface_1_1_interface_entry.html">InterfaceEntry</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_ordered_interface.html#a03959a54ffc81c2108f54f7a8ba2a872">ElemContainer</a></td></tr>
<tr class="separator:a03959a54ffc81c2108f54f7a8ba2a872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84f07e16cfd41ba3a4502ca2b607944b"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structpcl_1_1type__traits.html">type_traits</a>&lt; TType &gt;::Elem&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_ordered_interface.html#a84f07e16cfd41ba3a4502ca2b607944b">TElem</a></td></tr>
<tr class="separator:a84f07e16cfd41ba3a4502ca2b607944b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ae15565d44fc2dc1ff2fb2bb541d746f6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_ordered_interface.html#ae15565d44fc2dc1ff2fb2bb541d746f6">get_free_id</a> ()</td></tr>
<tr class="memdesc:ae15565d44fc2dc1ff2fb2bb541d746f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a free id in each call.  <a href="classpcl_1_1_ordered_interface.html#ae15565d44fc2dc1ff2fb2bb541d746f6">More...</a><br /></td></tr>
<tr class="separator:ae15565d44fc2dc1ff2fb2bb541d746f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ad57e55a7f2e4d061f4dd2d5f78b11e7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_ordered_interface.html#a03959a54ffc81c2108f54f7a8ba2a872">ElemContainer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_ordered_interface.html#ad57e55a7f2e4d061f4dd2d5f78b11e7a">m_elements</a></td></tr>
<tr class="separator:ad57e55a7f2e4d061f4dd2d5f78b11e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb039d3bca6aab1a21f1a8ba545233fa"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_ordered_interface.html#aeb039d3bca6aab1a21f1a8ba545233fa">m_idCounter</a></td></tr>
<tr class="separator:aeb039d3bca6aab1a21f1a8ba545233fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f658ffb0b7d93aeb64d2071c743e75f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_ordered_interface.html#a8f658ffb0b7d93aeb64d2071c743e75f">m_size</a></td></tr>
<tr class="separator:a8f658ffb0b7d93aeb64d2071c743e75f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08634ee63970054312e82c4073ed0754"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_ordered_interface.html#a08634ee63970054312e82c4073ed0754">m_targetProc</a></td></tr>
<tr class="separator:a08634ee63970054312e82c4073ed0754"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class TType, template&lt; class T, class Alloc &gt; class TContainer = std::vector, template&lt; class T &gt; class TAlloc = std::allocator&gt;<br />
class pcl::OrderedInterface&lt; TType, TContainer, TAlloc &gt;</h3>

<p>You may add elements to this interface and iterate over them. </p>
<p>You may retrieve a localID for each element in the interface </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a63a0ff4f94fedfa883de6536d837d707"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63a0ff4f94fedfa883de6536d837d707">&#9670;&nbsp;</a></span>category_tag</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TType , template&lt; class T, class Alloc &gt; class TContainer = std::vector, template&lt; class T &gt; class TAlloc = std::allocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classpcl_1_1interface__tags_1_1ordered__interface__tag.html">interface_tags::ordered_interface_tag</a> <a class="el" href="classpcl_1_1_ordered_interface.html">pcl::OrderedInterface</a>&lt; TType, TContainer, TAlloc &gt;::<a class="el" href="classpcl_1_1_ordered_interface.html#a63a0ff4f94fedfa883de6536d837d707">category_tag</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2174f3a344bfccb60134fc0604a0ba77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2174f3a344bfccb60134fc0604a0ba77">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TType , template&lt; class T, class Alloc &gt; class TContainer = std::vector, template&lt; class T &gt; class TAlloc = std::allocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ElemContainer::const_iterator <a class="el" href="classpcl_1_1_ordered_interface.html">pcl::OrderedInterface</a>&lt; TType, TContainer, TAlloc &gt;::<a class="el" href="classpcl_1_1_ordered_interface.html#a2174f3a344bfccb60134fc0604a0ba77">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a03959a54ffc81c2108f54f7a8ba2a872"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03959a54ffc81c2108f54f7a8ba2a872">&#9670;&nbsp;</a></span>ElemContainer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TType , template&lt; class T, class Alloc &gt; class TContainer = std::vector, template&lt; class T &gt; class TAlloc = std::allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef TContainer&lt;<a class="el" href="structpcl_1_1_ordered_interface_1_1_interface_entry.html">InterfaceEntry</a>, TAlloc&lt;<a class="el" href="structpcl_1_1_ordered_interface_1_1_interface_entry.html">InterfaceEntry</a>&gt; &gt; <a class="el" href="classpcl_1_1_ordered_interface.html">pcl::OrderedInterface</a>&lt; TType, TContainer, TAlloc &gt;::<a class="el" href="classpcl_1_1_ordered_interface.html#a03959a54ffc81c2108f54f7a8ba2a872">ElemContainer</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a02fc303432e68743659bf3f93144e4e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02fc303432e68743659bf3f93144e4e5">&#9670;&nbsp;</a></span>Element</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TType , template&lt; class T, class Alloc &gt; class TContainer = std::vector, template&lt; class T &gt; class TAlloc = std::allocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structpcl_1_1type__traits.html">type_traits</a>&lt;TType&gt;::Elem <a class="el" href="classpcl_1_1_ordered_interface.html">pcl::OrderedInterface</a>&lt; TType, TContainer, TAlloc &gt;::<a class="el" href="classpcl_1_1_ordered_interface.html#a02fc303432e68743659bf3f93144e4e5">Element</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2aaf87ae3ef32df4a64fa2d7cdb70c53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aaf87ae3ef32df4a64fa2d7cdb70c53">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TType , template&lt; class T, class Alloc &gt; class TContainer = std::vector, template&lt; class T &gt; class TAlloc = std::allocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ElemContainer::iterator <a class="el" href="classpcl_1_1_ordered_interface.html">pcl::OrderedInterface</a>&lt; TType, TContainer, TAlloc &gt;::<a class="el" href="classpcl_1_1_ordered_interface.html#a2aaf87ae3ef32df4a64fa2d7cdb70c53">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a84f07e16cfd41ba3a4502ca2b607944b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84f07e16cfd41ba3a4502ca2b607944b">&#9670;&nbsp;</a></span>TElem</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TType , template&lt; class T, class Alloc &gt; class TContainer = std::vector, template&lt; class T &gt; class TAlloc = std::allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structpcl_1_1type__traits.html">type_traits</a>&lt;TType&gt;::Elem <a class="el" href="classpcl_1_1_ordered_interface.html">pcl::OrderedInterface</a>&lt; TType, TContainer, TAlloc &gt;::<a class="el" href="classpcl_1_1_ordered_interface.html#a84f07e16cfd41ba3a4502ca2b607944b">TElem</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac5c514062f40a504932875c21e0b53d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5c514062f40a504932875c21e0b53d8">&#9670;&nbsp;</a></span>Type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TType , template&lt; class T, class Alloc &gt; class TContainer = std::vector, template&lt; class T &gt; class TAlloc = std::allocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef TType <a class="el" href="classpcl_1_1_ordered_interface.html">pcl::OrderedInterface</a>&lt; TType, TContainer, TAlloc &gt;::<a class="el" href="classpcl_1_1_ordered_interface.html#ac5c514062f40a504932875c21e0b53d8">Type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a933c7b505c1acb7baca356010591099e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a933c7b505c1acb7baca356010591099e">&#9670;&nbsp;</a></span>OrderedInterface()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TType , template&lt; class T, class Alloc &gt; class TContainer = std::vector, template&lt; class T &gt; class TAlloc = std::allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcl_1_1_ordered_interface.html">pcl::OrderedInterface</a>&lt; TType, TContainer, TAlloc &gt;::<a class="el" href="classpcl_1_1_ordered_interface.html">OrderedInterface</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>targetProc</em> = <code>-1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8b90a445fb14789fb9b257123c39f7ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b90a445fb14789fb9b257123c39f7ea">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TType , template&lt; class T, class Alloc &gt; class TContainer = std::vector, template&lt; class T &gt; class TAlloc = std::allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcl_1_1_ordered_interface.html#a2aaf87ae3ef32df4a64fa2d7cdb70c53">iterator</a> <a class="el" href="classpcl_1_1_ordered_interface.html">pcl::OrderedInterface</a>&lt; TType, TContainer, TAlloc &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="classpcl_1_1_ordered_interface.html#ad57e55a7f2e4d061f4dd2d5f78b11e7a">pcl::OrderedInterface&lt; TType, TContainer, TAlloc &gt;::m_elements</a>.</p>

<p class="reference">Referenced by <a class="el" href="classug_1_1_com_pol___vec_copy.html#a0e679634c6aa899430437c7eaa5a3d9a">ug::ComPol_VecCopy&lt; TVector &gt;::collect()</a>, <a class="el" href="classug_1_1_com_pol___vec_scale_copy.html#ad8a5e37101158f7422a25b4192456c8d">ug::ComPol_VecScaleCopy&lt; TVector &gt;::collect()</a>, <a class="el" href="classug_1_1_com_pol___vec_add.html#a14c9e241a1715ed8b975b1883eec95fc">ug::ComPol_VecAdd&lt; TVector &gt;::collect()</a>, <a class="el" href="classug_1_1_com_pol___vec_scale_add.html#a0fc785054dfbc1409809ef12c6785bf2">ug::ComPol_VecScaleAdd&lt; TVector &gt;::collect()</a>, <a class="el" href="classug_1_1_com_pol___vec_add_set_zero.html#a6dfbfc994fad6cfa6258089e16781f7a">ug::ComPol_VecAddSetZero&lt; TVector &gt;::collect()</a>, <a class="el" href="classug_1_1_com_pol___vec_subtract.html#aa41a936a030bd017614bb877af46adbf">ug::ComPol_VecSubtract&lt; TVector &gt;::collect()</a>, <a class="el" href="classug_1_1_com_pol___check_consistency.html#a11cae941179535fd256d1c6c09a8e060">ug::ComPol_CheckConsistency&lt; TVector &gt;::collect()</a>, <a class="el" href="classug_1_1_com_pol___vec_subtract_only_one_slave.html#a20ed3209b14672de9d38b562977c1709">ug::ComPol_VecSubtractOnlyOneSlave&lt; TVector &gt;::collect()</a>, <a class="el" href="classug_1_1_com_pol___mat_distribute_diag.html#a8b99939a8110a534e20eed9838a83bba">ug::ComPol_MatDistributeDiag&lt; TAlgebra &gt;::collect()</a>, <a class="el" href="classug_1_1_com_pol___mat_add_rows_overlap0.html#a28a9261cd7e149902ea90917166d4051">ug::ComPol_MatAddRowsOverlap0&lt; TMatrix &gt;::collect()</a>, <a class="el" href="classug_1_1_com_pol___mat_copy_rows_overlap0.html#afc9bc7c23540a497b0ee093cc215902d">ug::ComPol_MatCopyRowsOverlap0&lt; TMatrix &gt;::collect()</a>, <a class="el" href="classug_1_1_com_pol___mat_add_set_zero_inner_interface_couplings.html#a763c078c797cd97628010fbfcb420e83">ug::ComPol_MatAddSetZeroInnerInterfaceCouplings&lt; TMatrix &gt;::collect()</a>, <a class="el" href="classug_1_1_communication_scheme.html#aff03f433ab925390398b343e066f2b6d">ug::CommunicationScheme&lt; TDerived, TValue &gt;::collect()</a>, <a class="el" href="classug_1_1_communication_scheme_3_01_t_derived_00_01bool_01_4.html#a1b80fb322fa59288aba5593dc5508814">ug::CommunicationScheme&lt; TDerived, bool &gt;::collect()</a>, <a class="el" href="classug_1_1_com_pol___mat_copy_diag.html#aa118d6253227923b54d7cfea5a793faf">ug::ComPol_MatCopyDiag&lt; TMatrix &gt;::collect()</a>, <a class="el" href="classug_1_1_com_pol___mat_create_overlap.html#ab873e3d49c62357c2551bff6ae33bb55">ug::ComPol_MatCreateOverlap&lt; TMatrix &gt;::collect()</a>, <a class="el" href="classug_1_1_com_pol___vec_copy.html#a0930c67c6e61ab9d1e00aa02482046c1">ug::ComPol_VecCopy&lt; TVector &gt;::extract()</a>, <a class="el" href="classug_1_1_com_pol___vec_scale_copy.html#ac2d3ec8fa07be5b12c134ab26dd99d8f">ug::ComPol_VecScaleCopy&lt; TVector &gt;::extract()</a>, <a class="el" href="classug_1_1_com_pol___vec_add.html#a00d6fd7fd419e2c5be85cbb4cb82d01f">ug::ComPol_VecAdd&lt; TVector &gt;::extract()</a>, <a class="el" href="classug_1_1_com_pol___vec_scale_add.html#af6570894ab4ccb4a1d77f1342c568590">ug::ComPol_VecScaleAdd&lt; TVector &gt;::extract()</a>, <a class="el" href="classug_1_1_com_pol___vec_add_set_zero.html#a9e3f2be77ab88f384f93654aae6d108e">ug::ComPol_VecAddSetZero&lt; TVector &gt;::extract()</a>, <a class="el" href="classug_1_1_com_pol___vec_subtract.html#af7f59a1824b8aa13f6834dcf152b44fd">ug::ComPol_VecSubtract&lt; TVector &gt;::extract()</a>, <a class="el" href="classug_1_1_com_pol___check_consistency.html#aafa3b042f38ca52e4e018963ae98ed92">ug::ComPol_CheckConsistency&lt; TVector &gt;::extract()</a>, <a class="el" href="classug_1_1_com_pol___vec_subtract_only_one_slave.html#af98d07686e2eda329bae69b5ee5b30b3">ug::ComPol_VecSubtractOnlyOneSlave&lt; TVector &gt;::extract()</a>, <a class="el" href="classug_1_1_com_pol___mat_distribute_diag.html#a5622a5631df45db450c4b691f0b26a1d">ug::ComPol_MatDistributeDiag&lt; TAlgebra &gt;::extract()</a>, <a class="el" href="classug_1_1_com_pol___mat_add_rows_overlap0.html#ad08a9110d0aa3df112458be1bef323d2">ug::ComPol_MatAddRowsOverlap0&lt; TMatrix &gt;::extract()</a>, <a class="el" href="classug_1_1_com_pol___mat_copy_rows_overlap0.html#a02537c029681c81e09e1f759e26dd795">ug::ComPol_MatCopyRowsOverlap0&lt; TMatrix &gt;::extract()</a>, <a class="el" href="classug_1_1_com_pol___mat_add_set_zero_inner_interface_couplings.html#ab25f906424557c8864b35439715a305d">ug::ComPol_MatAddSetZeroInnerInterfaceCouplings&lt; TMatrix &gt;::extract()</a>, <a class="el" href="classug_1_1_communication_scheme.html#a8b1e395a22a82a667ecf39bb4831616f">ug::CommunicationScheme&lt; TDerived, TValue &gt;::extract()</a>, <a class="el" href="classug_1_1_communication_scheme_3_01_t_derived_00_01bool_01_4.html#a70895a14496ac6a353717eb53910cda4">ug::CommunicationScheme&lt; TDerived, bool &gt;::extract()</a>, <a class="el" href="classug_1_1_com_pol___mat_copy_diag.html#aa761290592ce813cc9ca55ded6ba61de">ug::ComPol_MatCopyDiag&lt; TMatrix &gt;::extract()</a>, <a class="el" href="classug_1_1_com_pol___mat_create_overlap.html#af15a2896c0919978ba9a0c0fba441346">ug::ComPol_MatCreateOverlap&lt; TMatrix &gt;::extract()</a>, <a class="el" href="classpcl_1_1_ordered_interface.html#ae15565d44fc2dc1ff2fb2bb541d746f6">pcl::OrderedInterface&lt; TType, TContainer, TAlloc &gt;::get_free_id()</a>, <a class="el" href="classug_1_1_slicing_data.html#a44a2f814f0a40202c4d7b77f68ea7402">ug::SlicingData&lt; TVec, N &gt;::replace_indices_in_layout()</a>, <a class="el" href="namespaceug.html#a0aafbd652b123eb69a5f3b298a48e5b6">ug::SerializeInterface()</a>, and <a class="el" href="group__lib__algebra__parallelization__util.html#ga9801a124862216fb6db2999188ac4c32">ug::SetInterfaceValues()</a>.</p>

</div>
</div>
<a id="aaba231ebc0155e0a8f19cc49b0673aea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaba231ebc0155e0a8f19cc49b0673aea">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TType , template&lt; class T, class Alloc &gt; class TContainer = std::vector, template&lt; class T &gt; class TAlloc = std::allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcl_1_1_ordered_interface.html#a2174f3a344bfccb60134fc0604a0ba77">const_iterator</a> <a class="el" href="classpcl_1_1_ordered_interface.html">pcl::OrderedInterface</a>&lt; TType, TContainer, TAlloc &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="classpcl_1_1_ordered_interface.html#ad57e55a7f2e4d061f4dd2d5f78b11e7a">pcl::OrderedInterface&lt; TType, TContainer, TAlloc &gt;::m_elements</a>.</p>

</div>
</div>
<a id="a00310ab46a9a5165421f189ae8f8f89f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00310ab46a9a5165421f189ae8f8f89f">&#9670;&nbsp;</a></span>cmp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TType , template&lt; class T, class Alloc &gt; class TContainer = std::vector, template&lt; class T &gt; class TAlloc = std::allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="classpcl_1_1_ordered_interface.html">pcl::OrderedInterface</a>&lt; TType, TContainer, TAlloc &gt;::cmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_ordered_interface.html#a2aaf87ae3ef32df4a64fa2d7cdb70c53">iterator</a>&#160;</td>
          <td class="paramname"><em>iter1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_ordered_interface.html#a2aaf87ae3ef32df4a64fa2d7cdb70c53">iterator</a>&#160;</td>
          <td class="paramname"><em>iter2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::input_iterator_tag &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns true if iter1 &lt; iter2. </p>

<p class="reference">Referenced by <a class="el" href="classpcl_1_1_ordered_interface.html#aa8371adba709c3191c2a7eb9bda55499">pcl::OrderedInterface&lt; TType, TContainer, TAlloc &gt;::find_insert_pos_sorted()</a>, and <a class="el" href="classpcl_1_1_ordered_interface.html#a4737c862ffcf5893abaf8aa6b790dfe9">pcl::OrderedInterface&lt; TType, TContainer, TAlloc &gt;::sort()</a>.</p>

</div>
</div>
<a id="ab70a1fad284b3e0ee1bfad23ef7d8c66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab70a1fad284b3e0ee1bfad23ef7d8c66">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TType , template&lt; class T, class Alloc &gt; class TContainer = std::vector, template&lt; class T &gt; class TAlloc = std::allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpcl_1_1_ordered_interface.html">pcl::OrderedInterface</a>&lt; TType, TContainer, TAlloc &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="classpcl_1_1_ordered_interface.html#ad6c6e78b6001c10823254de7c5352669">pcl::OrderedInterface&lt; TType, TContainer, TAlloc &gt;::size()</a>.</p>

</div>
</div>
<a id="a4b82cef21a9e8490dec38c27776a7976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b82cef21a9e8490dec38c27776a7976">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TType , template&lt; class T, class Alloc &gt; class TContainer = std::vector, template&lt; class T &gt; class TAlloc = std::allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcl_1_1_ordered_interface.html#a2aaf87ae3ef32df4a64fa2d7cdb70c53">iterator</a> <a class="el" href="classpcl_1_1_ordered_interface.html">pcl::OrderedInterface</a>&lt; TType, TContainer, TAlloc &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="classpcl_1_1_ordered_interface.html#ad57e55a7f2e4d061f4dd2d5f78b11e7a">pcl::OrderedInterface&lt; TType, TContainer, TAlloc &gt;::m_elements</a>.</p>

<p class="reference">Referenced by <a class="el" href="classug_1_1_com_pol___vec_copy.html#a0e679634c6aa899430437c7eaa5a3d9a">ug::ComPol_VecCopy&lt; TVector &gt;::collect()</a>, <a class="el" href="classug_1_1_com_pol___vec_scale_copy.html#ad8a5e37101158f7422a25b4192456c8d">ug::ComPol_VecScaleCopy&lt; TVector &gt;::collect()</a>, <a class="el" href="classug_1_1_com_pol___vec_add.html#a14c9e241a1715ed8b975b1883eec95fc">ug::ComPol_VecAdd&lt; TVector &gt;::collect()</a>, <a class="el" href="classug_1_1_com_pol___vec_scale_add.html#a0fc785054dfbc1409809ef12c6785bf2">ug::ComPol_VecScaleAdd&lt; TVector &gt;::collect()</a>, <a class="el" href="classug_1_1_com_pol___vec_add_set_zero.html#a6dfbfc994fad6cfa6258089e16781f7a">ug::ComPol_VecAddSetZero&lt; TVector &gt;::collect()</a>, <a class="el" href="classug_1_1_com_pol___vec_subtract.html#aa41a936a030bd017614bb877af46adbf">ug::ComPol_VecSubtract&lt; TVector &gt;::collect()</a>, <a class="el" href="classug_1_1_com_pol___check_consistency.html#a11cae941179535fd256d1c6c09a8e060">ug::ComPol_CheckConsistency&lt; TVector &gt;::collect()</a>, <a class="el" href="classug_1_1_com_pol___vec_subtract_only_one_slave.html#a20ed3209b14672de9d38b562977c1709">ug::ComPol_VecSubtractOnlyOneSlave&lt; TVector &gt;::collect()</a>, <a class="el" href="classug_1_1_com_pol___mat_distribute_diag.html#a8b99939a8110a534e20eed9838a83bba">ug::ComPol_MatDistributeDiag&lt; TAlgebra &gt;::collect()</a>, <a class="el" href="classug_1_1_com_pol___mat_add_rows_overlap0.html#a28a9261cd7e149902ea90917166d4051">ug::ComPol_MatAddRowsOverlap0&lt; TMatrix &gt;::collect()</a>, <a class="el" href="classug_1_1_com_pol___mat_copy_rows_overlap0.html#afc9bc7c23540a497b0ee093cc215902d">ug::ComPol_MatCopyRowsOverlap0&lt; TMatrix &gt;::collect()</a>, <a class="el" href="classug_1_1_com_pol___mat_add_set_zero_inner_interface_couplings.html#a763c078c797cd97628010fbfcb420e83">ug::ComPol_MatAddSetZeroInnerInterfaceCouplings&lt; TMatrix &gt;::collect()</a>, <a class="el" href="classug_1_1_communication_scheme.html#aff03f433ab925390398b343e066f2b6d">ug::CommunicationScheme&lt; TDerived, TValue &gt;::collect()</a>, <a class="el" href="classug_1_1_communication_scheme_3_01_t_derived_00_01bool_01_4.html#a1b80fb322fa59288aba5593dc5508814">ug::CommunicationScheme&lt; TDerived, bool &gt;::collect()</a>, <a class="el" href="classug_1_1_com_pol___mat_copy_diag.html#aa118d6253227923b54d7cfea5a793faf">ug::ComPol_MatCopyDiag&lt; TMatrix &gt;::collect()</a>, <a class="el" href="classug_1_1_com_pol___mat_create_overlap.html#ab873e3d49c62357c2551bff6ae33bb55">ug::ComPol_MatCreateOverlap&lt; TMatrix &gt;::collect()</a>, <a class="el" href="classug_1_1_com_pol___vec_copy.html#a0930c67c6e61ab9d1e00aa02482046c1">ug::ComPol_VecCopy&lt; TVector &gt;::extract()</a>, <a class="el" href="classug_1_1_com_pol___vec_scale_copy.html#ac2d3ec8fa07be5b12c134ab26dd99d8f">ug::ComPol_VecScaleCopy&lt; TVector &gt;::extract()</a>, <a class="el" href="classug_1_1_com_pol___vec_add.html#a00d6fd7fd419e2c5be85cbb4cb82d01f">ug::ComPol_VecAdd&lt; TVector &gt;::extract()</a>, <a class="el" href="classug_1_1_com_pol___vec_scale_add.html#af6570894ab4ccb4a1d77f1342c568590">ug::ComPol_VecScaleAdd&lt; TVector &gt;::extract()</a>, <a class="el" href="classug_1_1_com_pol___vec_add_set_zero.html#a9e3f2be77ab88f384f93654aae6d108e">ug::ComPol_VecAddSetZero&lt; TVector &gt;::extract()</a>, <a class="el" href="classug_1_1_com_pol___vec_subtract.html#af7f59a1824b8aa13f6834dcf152b44fd">ug::ComPol_VecSubtract&lt; TVector &gt;::extract()</a>, <a class="el" href="classug_1_1_com_pol___check_consistency.html#aafa3b042f38ca52e4e018963ae98ed92">ug::ComPol_CheckConsistency&lt; TVector &gt;::extract()</a>, <a class="el" href="classug_1_1_com_pol___vec_subtract_only_one_slave.html#af98d07686e2eda329bae69b5ee5b30b3">ug::ComPol_VecSubtractOnlyOneSlave&lt; TVector &gt;::extract()</a>, <a class="el" href="classug_1_1_com_pol___mat_distribute_diag.html#a5622a5631df45db450c4b691f0b26a1d">ug::ComPol_MatDistributeDiag&lt; TAlgebra &gt;::extract()</a>, <a class="el" href="classug_1_1_com_pol___mat_add_rows_overlap0.html#ad08a9110d0aa3df112458be1bef323d2">ug::ComPol_MatAddRowsOverlap0&lt; TMatrix &gt;::extract()</a>, <a class="el" href="classug_1_1_com_pol___mat_copy_rows_overlap0.html#a02537c029681c81e09e1f759e26dd795">ug::ComPol_MatCopyRowsOverlap0&lt; TMatrix &gt;::extract()</a>, <a class="el" href="classug_1_1_com_pol___mat_add_set_zero_inner_interface_couplings.html#ab25f906424557c8864b35439715a305d">ug::ComPol_MatAddSetZeroInnerInterfaceCouplings&lt; TMatrix &gt;::extract()</a>, <a class="el" href="classug_1_1_communication_scheme.html#a8b1e395a22a82a667ecf39bb4831616f">ug::CommunicationScheme&lt; TDerived, TValue &gt;::extract()</a>, <a class="el" href="classug_1_1_communication_scheme_3_01_t_derived_00_01bool_01_4.html#a70895a14496ac6a353717eb53910cda4">ug::CommunicationScheme&lt; TDerived, bool &gt;::extract()</a>, <a class="el" href="classug_1_1_com_pol___mat_copy_diag.html#aa761290592ce813cc9ca55ded6ba61de">ug::ComPol_MatCopyDiag&lt; TMatrix &gt;::extract()</a>, <a class="el" href="classug_1_1_com_pol___mat_create_overlap.html#af15a2896c0919978ba9a0c0fba441346">ug::ComPol_MatCreateOverlap&lt; TMatrix &gt;::extract()</a>, <a class="el" href="classpcl_1_1_ordered_interface.html#ae15565d44fc2dc1ff2fb2bb541d746f6">pcl::OrderedInterface&lt; TType, TContainer, TAlloc &gt;::get_free_id()</a>, <a class="el" href="classpcl_1_1_ordered_interface.html#af6bd3fe237cb03c7938474e043a29e9a">pcl::OrderedInterface&lt; TType, TContainer, TAlloc &gt;::insert()</a>, <a class="el" href="classug_1_1_slicing_data.html#a44a2f814f0a40202c4d7b77f68ea7402">ug::SlicingData&lt; TVec, N &gt;::replace_indices_in_layout()</a>, <a class="el" href="namespaceug.html#a0aafbd652b123eb69a5f3b298a48e5b6">ug::SerializeInterface()</a>, and <a class="el" href="group__lib__algebra__parallelization__util.html#ga9801a124862216fb6db2999188ac4c32">ug::SetInterfaceValues()</a>.</p>

</div>
</div>
<a id="ac25902ba499218c2af12468f60014ccd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac25902ba499218c2af12468f60014ccd">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TType , template&lt; class T, class Alloc &gt; class TContainer = std::vector, template&lt; class T &gt; class TAlloc = std::allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcl_1_1_ordered_interface.html#a2174f3a344bfccb60134fc0604a0ba77">const_iterator</a> <a class="el" href="classpcl_1_1_ordered_interface.html">pcl::OrderedInterface</a>&lt; TType, TContainer, TAlloc &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="classpcl_1_1_ordered_interface.html#ad57e55a7f2e4d061f4dd2d5f78b11e7a">pcl::OrderedInterface&lt; TType, TContainer, TAlloc &gt;::m_elements</a>.</p>

</div>
</div>
<a id="ac3bd7c23e7821d8ebb4948bd1dcf1a36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3bd7c23e7821d8ebb4948bd1dcf1a36">&#9670;&nbsp;</a></span>erase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TType , template&lt; class T, class Alloc &gt; class TContainer = std::vector, template&lt; class T &gt; class TAlloc = std::allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcl_1_1_ordered_interface.html#a2aaf87ae3ef32df4a64fa2d7cdb70c53">iterator</a> <a class="el" href="classpcl_1_1_ordered_interface.html">pcl::OrderedInterface</a>&lt; TType, TContainer, TAlloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_ordered_interface.html#a2aaf87ae3ef32df4a64fa2d7cdb70c53">iterator</a>&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="classpcl_1_1_ordered_interface.html#ad57e55a7f2e4d061f4dd2d5f78b11e7a">pcl::OrderedInterface&lt; TType, TContainer, TAlloc &gt;::m_elements</a>, and <a class="el" href="classpcl_1_1_ordered_interface.html#a8f658ffb0b7d93aeb64d2071c743e75f">pcl::OrderedInterface&lt; TType, TContainer, TAlloc &gt;::m_size</a>.</p>

<p class="reference">Referenced by <a class="el" href="classug_1_1_slicing_data.html#a44a2f814f0a40202c4d7b77f68ea7402">ug::SlicingData&lt; TVec, N &gt;::replace_indices_in_layout()</a>.</p>

</div>
</div>
<a id="aa8371adba709c3191c2a7eb9bda55499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8371adba709c3191c2a7eb9bda55499">&#9670;&nbsp;</a></span>find_insert_pos_sorted()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TType , template&lt; class T, class Alloc &gt; class TContainer = std::vector, template&lt; class T &gt; class TAlloc = std::allocator&gt; </div>
<div class="memtemplate">
template&lt;class TCompare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcl_1_1_ordered_interface.html#a2aaf87ae3ef32df4a64fa2d7cdb70c53">iterator</a> <a class="el" href="classpcl_1_1_ordered_interface.html">pcl::OrderedInterface</a>&lt; TType, TContainer, TAlloc &gt;::find_insert_pos_sorted </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_ordered_interface.html#a02fc303432e68743659bf3f93144e4e5">Element</a>&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TCompare&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find insertion position for an element to be inserted </p>
<dl class="section return"><dt>Returns</dt><dd>iterator to insertion position if found; end-iterator otherwise </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This method implicitly requires the interface to be sorted w.r.t. the passed compare object. If it is not, the position might not be correct. </dd></dl>

<p class="reference">References <a class="el" href="classpcl_1_1_ordered_interface.html#a00310ab46a9a5165421f189ae8f8f89f">pcl::OrderedInterface&lt; TType, TContainer, TAlloc &gt;::cmp()</a>, and <a class="el" href="classpcl_1_1_ordered_interface.html#ad57e55a7f2e4d061f4dd2d5f78b11e7a">pcl::OrderedInterface&lt; TType, TContainer, TAlloc &gt;::m_elements</a>.</p>

</div>
</div>
<a id="aeabbb87f4c67dd042a5c4f30e1b29968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeabbb87f4c67dd042a5c4f30e1b29968">&#9670;&nbsp;</a></span>get_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TType , template&lt; class T, class Alloc &gt; class TContainer = std::vector, template&lt; class T &gt; class TAlloc = std::allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpcl_1_1_ordered_interface.html#a02fc303432e68743659bf3f93144e4e5">Element</a>&amp; <a class="el" href="classpcl_1_1_ordered_interface.html">pcl::OrderedInterface</a>&lt; TType, TContainer, TAlloc &gt;::get_element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_ordered_interface.html#a2174f3a344bfccb60134fc0604a0ba77">const_iterator</a>&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abbeeb5588895dd0649681116c3900bbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbeeb5588895dd0649681116c3900bbf">&#9670;&nbsp;</a></span>get_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TType , template&lt; class T, class Alloc &gt; class TContainer = std::vector, template&lt; class T &gt; class TAlloc = std::allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcl_1_1_ordered_interface.html#a02fc303432e68743659bf3f93144e4e5">Element</a>&amp; <a class="el" href="classpcl_1_1_ordered_interface.html">pcl::OrderedInterface</a>&lt; TType, TContainer, TAlloc &gt;::get_element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_ordered_interface.html#a2aaf87ae3ef32df4a64fa2d7cdb70c53">iterator</a>&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="classug_1_1_do_f_distribution.html#a6b4139c4f8d56335a33b4ab77afeef8e">ug::DoFDistribution::add_indices_from_layouts()</a>, <a class="el" href="namespaceug.html#a493bd820e6533113719c9e6161330ce2">ug::AddEntriesToIndexLayout_DomainDecomposition()</a>, <a class="el" href="namespaceug.html#af25a21b44a926c8a1bd5572ed8b86465">ug::AddEntriesToSurfaceIndexLayout()</a>, <a class="el" href="classug_1_1_parallel_vector.html#a38358ca446e1842509a109f68c559b15">ug::ParallelVector&lt; TVector &gt;::check_storage_type()</a>, <a class="el" href="classug_1_1_com_pol___vec_copy.html#a0e679634c6aa899430437c7eaa5a3d9a">ug::ComPol_VecCopy&lt; TVector &gt;::collect()</a>, <a class="el" href="classug_1_1_com_pol___vec_scale_copy.html#ad8a5e37101158f7422a25b4192456c8d">ug::ComPol_VecScaleCopy&lt; TVector &gt;::collect()</a>, <a class="el" href="classug_1_1_com_pol___vec_add.html#a14c9e241a1715ed8b975b1883eec95fc">ug::ComPol_VecAdd&lt; TVector &gt;::collect()</a>, <a class="el" href="classug_1_1_com_pol___vec_scale_add.html#a0fc785054dfbc1409809ef12c6785bf2">ug::ComPol_VecScaleAdd&lt; TVector &gt;::collect()</a>, <a class="el" href="classug_1_1_com_pol___vec_add_set_zero.html#a6dfbfc994fad6cfa6258089e16781f7a">ug::ComPol_VecAddSetZero&lt; TVector &gt;::collect()</a>, <a class="el" href="classug_1_1_com_pol___vec_subtract.html#aa41a936a030bd017614bb877af46adbf">ug::ComPol_VecSubtract&lt; TVector &gt;::collect()</a>, <a class="el" href="classug_1_1_com_pol___check_consistency.html#a11cae941179535fd256d1c6c09a8e060">ug::ComPol_CheckConsistency&lt; TVector &gt;::collect()</a>, <a class="el" href="classug_1_1_com_pol___vec_subtract_only_one_slave.html#a20ed3209b14672de9d38b562977c1709">ug::ComPol_VecSubtractOnlyOneSlave&lt; TVector &gt;::collect()</a>, <a class="el" href="classug_1_1_com_pol___mat_distribute_diag.html#a8b99939a8110a534e20eed9838a83bba">ug::ComPol_MatDistributeDiag&lt; TAlgebra &gt;::collect()</a>, <a class="el" href="classug_1_1_com_pol___mat_add_rows_overlap0.html#a28a9261cd7e149902ea90917166d4051">ug::ComPol_MatAddRowsOverlap0&lt; TMatrix &gt;::collect()</a>, <a class="el" href="classug_1_1_com_pol___mat_copy_rows_overlap0.html#afc9bc7c23540a497b0ee093cc215902d">ug::ComPol_MatCopyRowsOverlap0&lt; TMatrix &gt;::collect()</a>, <a class="el" href="classug_1_1_com_pol___mat_add_set_zero_inner_interface_couplings.html#a763c078c797cd97628010fbfcb420e83">ug::ComPol_MatAddSetZeroInnerInterfaceCouplings&lt; TMatrix &gt;::collect()</a>, <a class="el" href="classug_1_1_communication_scheme.html#aff03f433ab925390398b343e066f2b6d">ug::CommunicationScheme&lt; TDerived, TValue &gt;::collect()</a>, <a class="el" href="classug_1_1_communication_scheme_3_01_t_derived_00_01bool_01_4.html#a1b80fb322fa59288aba5593dc5508814">ug::CommunicationScheme&lt; TDerived, bool &gt;::collect()</a>, <a class="el" href="classug_1_1_com_pol___mat_copy_diag.html#aa118d6253227923b54d7cfea5a793faf">ug::ComPol_MatCopyDiag&lt; TMatrix &gt;::collect()</a>, <a class="el" href="classug_1_1_com_pol___mat_create_overlap.html#ab873e3d49c62357c2551bff6ae33bb55">ug::ComPol_MatCreateOverlap&lt; TMatrix &gt;::collect()</a>, <a class="el" href="namespaceug.html#a2b2b6e701b3a0fda203733f02ca784ed">ug::CopyInterfaceEntrysToDomainDecompositionLayouts()</a>, <a class="el" href="classug_1_1_com_pol___vec_copy.html#a0930c67c6e61ab9d1e00aa02482046c1">ug::ComPol_VecCopy&lt; TVector &gt;::extract()</a>, <a class="el" href="classug_1_1_com_pol___vec_scale_copy.html#ac2d3ec8fa07be5b12c134ab26dd99d8f">ug::ComPol_VecScaleCopy&lt; TVector &gt;::extract()</a>, <a class="el" href="classug_1_1_com_pol___vec_add.html#a00d6fd7fd419e2c5be85cbb4cb82d01f">ug::ComPol_VecAdd&lt; TVector &gt;::extract()</a>, <a class="el" href="classug_1_1_com_pol___vec_scale_add.html#af6570894ab4ccb4a1d77f1342c568590">ug::ComPol_VecScaleAdd&lt; TVector &gt;::extract()</a>, <a class="el" href="classug_1_1_com_pol___vec_add_set_zero.html#a9e3f2be77ab88f384f93654aae6d108e">ug::ComPol_VecAddSetZero&lt; TVector &gt;::extract()</a>, <a class="el" href="classug_1_1_com_pol___vec_subtract.html#af7f59a1824b8aa13f6834dcf152b44fd">ug::ComPol_VecSubtract&lt; TVector &gt;::extract()</a>, <a class="el" href="classug_1_1_com_pol___check_consistency.html#aafa3b042f38ca52e4e018963ae98ed92">ug::ComPol_CheckConsistency&lt; TVector &gt;::extract()</a>, <a class="el" href="classug_1_1_com_pol___vec_subtract_only_one_slave.html#af98d07686e2eda329bae69b5ee5b30b3">ug::ComPol_VecSubtractOnlyOneSlave&lt; TVector &gt;::extract()</a>, <a class="el" href="classug_1_1_com_pol___mat_distribute_diag.html#a5622a5631df45db450c4b691f0b26a1d">ug::ComPol_MatDistributeDiag&lt; TAlgebra &gt;::extract()</a>, <a class="el" href="classug_1_1_com_pol___mat_add_rows_overlap0.html#ad08a9110d0aa3df112458be1bef323d2">ug::ComPol_MatAddRowsOverlap0&lt; TMatrix &gt;::extract()</a>, <a class="el" href="classug_1_1_com_pol___mat_copy_rows_overlap0.html#a02537c029681c81e09e1f759e26dd795">ug::ComPol_MatCopyRowsOverlap0&lt; TMatrix &gt;::extract()</a>, <a class="el" href="classug_1_1_com_pol___mat_add_set_zero_inner_interface_couplings.html#ab25f906424557c8864b35439715a305d">ug::ComPol_MatAddSetZeroInnerInterfaceCouplings&lt; TMatrix &gt;::extract()</a>, <a class="el" href="classug_1_1_communication_scheme.html#a8b1e395a22a82a667ecf39bb4831616f">ug::CommunicationScheme&lt; TDerived, TValue &gt;::extract()</a>, <a class="el" href="classug_1_1_communication_scheme_3_01_t_derived_00_01bool_01_4.html#a70895a14496ac6a353717eb53910cda4">ug::CommunicationScheme&lt; TDerived, bool &gt;::extract()</a>, <a class="el" href="classug_1_1_com_pol___mat_copy_diag.html#aa761290592ce813cc9ca55ded6ba61de">ug::ComPol_MatCopyDiag&lt; TMatrix &gt;::extract()</a>, <a class="el" href="classug_1_1_com_pol___mat_create_overlap.html#af15a2896c0919978ba9a0c0fba441346">ug::ComPol_MatCreateOverlap&lt; TMatrix &gt;::extract()</a>, <a class="el" href="namespaceug.html#a30de9ad725723658df3a71970a157ba3">ug::GetHighestReferencedIndex()</a>, <a class="el" href="namespaceug.html#a99ca331a2ec1a6cc4626af6efb4d417d">ug::MatExtractDiagOnLayout()</a>, <a class="el" href="namespaceug.html#a7a755b57f02aabc6ecb6494d285cdd73">ug::MatWriteDiagOnLayout()</a>, <a class="el" href="namespaceug.html#a88a143cd8091d7dec71f516edc5f1eca">ug::PermuteIndicesInIndexLayout()</a>, <a class="el" href="classug_1_1_slicing_data.html#a44a2f814f0a40202c4d7b77f68ea7402">ug::SlicingData&lt; TVec, N &gt;::replace_indices_in_layout()</a>, <a class="el" href="group__lib__algebra__parallelization__util.html#ga008815d4f97936dac5cae4be5e019c0c">ug::ScaleLayoutValues()</a>, <a class="el" href="namespaceug.html#a0aafbd652b123eb69a5f3b298a48e5b6">ug::SerializeInterface()</a>, <a class="el" href="group__lib__algebra__parallelization__util.html#ga9801a124862216fb6db2999188ac4c32">ug::SetInterfaceValues()</a>, and <a class="el" href="group__lib__algebra__parallelization__util.html#ga33b4797e3d3382885a96223a2c44d72f">ug::SetLayoutValues()</a>.</p>

</div>
</div>
<a id="ae15565d44fc2dc1ff2fb2bb541d746f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae15565d44fc2dc1ff2fb2bb541d746f6">&#9670;&nbsp;</a></span>get_free_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TType , template&lt; class T, class Alloc &gt; class TContainer = std::vector, template&lt; class T &gt; class TAlloc = std::allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classpcl_1_1_ordered_interface.html">pcl::OrderedInterface</a>&lt; TType, TContainer, TAlloc &gt;::get_free_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns a free id in each call. </p>
<p>Those ids are not necessarily aligned. </p>

<p class="reference">References <a class="el" href="classpcl_1_1_ordered_interface.html#a8b90a445fb14789fb9b257123c39f7ea">pcl::OrderedInterface&lt; TType, TContainer, TAlloc &gt;::begin()</a>, <a class="el" href="classpcl_1_1_ordered_interface.html#a4b82cef21a9e8490dec38c27776a7976">pcl::OrderedInterface&lt; TType, TContainer, TAlloc &gt;::end()</a>, and <a class="el" href="classpcl_1_1_ordered_interface.html#aeb039d3bca6aab1a21f1a8ba545233fa">pcl::OrderedInterface&lt; TType, TContainer, TAlloc &gt;::m_idCounter</a>.</p>

<p class="reference">Referenced by <a class="el" href="classpcl_1_1_ordered_interface.html#af6bd3fe237cb03c7938474e043a29e9a">pcl::OrderedInterface&lt; TType, TContainer, TAlloc &gt;::insert()</a>, and <a class="el" href="classpcl_1_1_ordered_interface.html#a00cc2e223de0041fe699905b0afd792b">pcl::OrderedInterface&lt; TType, TContainer, TAlloc &gt;::push_back()</a>.</p>

</div>
</div>
<a id="ae4796f5a650698fb39e21246c811bb88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4796f5a650698fb39e21246c811bb88">&#9670;&nbsp;</a></span>get_local_id() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TType , template&lt; class T, class Alloc &gt; class TContainer = std::vector, template&lt; class T &gt; class TAlloc = std::allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classpcl_1_1_ordered_interface.html">pcl::OrderedInterface</a>&lt; TType, TContainer, TAlloc &gt;::get_local_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_ordered_interface.html#a2174f3a344bfccb60134fc0604a0ba77">const_iterator</a>&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8878ee8ecb35a2fa3bd549d06b594f73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8878ee8ecb35a2fa3bd549d06b594f73">&#9670;&nbsp;</a></span>get_local_id() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TType , template&lt; class T, class Alloc &gt; class TContainer = std::vector, template&lt; class T &gt; class TAlloc = std::allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classpcl_1_1_ordered_interface.html">pcl::OrderedInterface</a>&lt; TType, TContainer, TAlloc &gt;::get_local_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_ordered_interface.html#a2aaf87ae3ef32df4a64fa2d7cdb70c53">iterator</a>&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad59a408f466b6106620cb9d3fb3ca4e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad59a408f466b6106620cb9d3fb3ca4e4">&#9670;&nbsp;</a></span>get_target_proc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TType , template&lt; class T, class Alloc &gt; class TContainer = std::vector, template&lt; class T &gt; class TAlloc = std::allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classpcl_1_1_ordered_interface.html">pcl::OrderedInterface</a>&lt; TType, TContainer, TAlloc &gt;::get_target_proc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="classpcl_1_1_ordered_interface.html#a08634ee63970054312e82c4073ed0754">pcl::OrderedInterface&lt; TType, TContainer, TAlloc &gt;::m_targetProc</a>.</p>

<p class="reference">Referenced by <a class="el" href="classug_1_1_communication_scheme.html#aff03f433ab925390398b343e066f2b6d">ug::CommunicationScheme&lt; TDerived, TValue &gt;::collect()</a>, <a class="el" href="classug_1_1_communication_scheme_3_01_t_derived_00_01bool_01_4.html#a1b80fb322fa59288aba5593dc5508814">ug::CommunicationScheme&lt; TDerived, bool &gt;::collect()</a>, <a class="el" href="classug_1_1_communication_scheme.html#a8b1e395a22a82a667ecf39bb4831616f">ug::CommunicationScheme&lt; TDerived, TValue &gt;::extract()</a>, <a class="el" href="classug_1_1_communication_scheme_3_01_t_derived_00_01bool_01_4.html#a70895a14496ac6a353717eb53910cda4">ug::CommunicationScheme&lt; TDerived, bool &gt;::extract()</a>, <a class="el" href="classug_1_1_com_pol___mat_create_overlap.html#af15a2896c0919978ba9a0c0fba441346">ug::ComPol_MatCreateOverlap&lt; TMatrix &gt;::extract()</a>, and <a class="el" href="classug_1_1_com_pol___mat_create_overlap.html#a53b2038293353f028dbe2b9223f96f24">ug::ComPol_MatCreateOverlap&lt; TMatrix &gt;::post_process()</a>.</p>

</div>
</div>
<a id="af6bd3fe237cb03c7938474e043a29e9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6bd3fe237cb03c7938474e043a29e9a">&#9670;&nbsp;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TType , template&lt; class T, class Alloc &gt; class TContainer = std::vector, template&lt; class T &gt; class TAlloc = std::allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcl_1_1_ordered_interface.html#a2aaf87ae3ef32df4a64fa2d7cdb70c53">iterator</a> <a class="el" href="classpcl_1_1_ordered_interface.html">pcl::OrderedInterface</a>&lt; TType, TContainer, TAlloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_ordered_interface.html#a02fc303432e68743659bf3f93144e4e5">Element</a> &amp;&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_ordered_interface.html#a2aaf87ae3ef32df4a64fa2d7cdb70c53">iterator</a>&#160;</td>
          <td class="paramname"><em>insertBefore</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert an element before the passed iterator. </p>
<p>The insertion iterator is best determined using the <a class="el" href="classpcl_1_1_ordered_interface.html#aa8371adba709c3191c2a7eb9bda55499" title="find insertion position for an element to be inserted">find_insert_pos_sorted()</a> method designed for this purpose.</p>
<dl class="section return"><dt>Returns</dt><dd>iterator to inserted element </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The method is intended for manipulation of the interface after it has been ordered and only suited for a small number of insertions (typically a single insertion). For more insertions, consider <a class="el" href="classpcl_1_1_ordered_interface.html#a00cc2e223de0041fe699905b0afd792b">push_back()</a> and re-ordering. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This method is highly experimental. Use with extreme caution! </dd></dl>

<p class="reference">References <a class="el" href="classpcl_1_1_ordered_interface.html#a4b82cef21a9e8490dec38c27776a7976">pcl::OrderedInterface&lt; TType, TContainer, TAlloc &gt;::end()</a>, <a class="el" href="classpcl_1_1_ordered_interface.html#ae15565d44fc2dc1ff2fb2bb541d746f6">pcl::OrderedInterface&lt; TType, TContainer, TAlloc &gt;::get_free_id()</a>, <a class="el" href="classpcl_1_1_ordered_interface.html#ad57e55a7f2e4d061f4dd2d5f78b11e7a">pcl::OrderedInterface&lt; TType, TContainer, TAlloc &gt;::m_elements</a>, and <a class="el" href="classpcl_1_1_ordered_interface.html#a8f658ffb0b7d93aeb64d2071c743e75f">pcl::OrderedInterface&lt; TType, TContainer, TAlloc &gt;::m_size</a>.</p>

</div>
</div>
<a id="a00cc2e223de0041fe699905b0afd792b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00cc2e223de0041fe699905b0afd792b">&#9670;&nbsp;</a></span>push_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TType , template&lt; class T, class Alloc &gt; class TContainer = std::vector, template&lt; class T &gt; class TAlloc = std::allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcl_1_1_ordered_interface.html#a2aaf87ae3ef32df4a64fa2d7cdb70c53">iterator</a> <a class="el" href="classpcl_1_1_ordered_interface.html">pcl::OrderedInterface</a>&lt; TType, TContainer, TAlloc &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_ordered_interface.html#a02fc303432e68743659bf3f93144e4e5">Element</a> &amp;&#160;</td>
          <td class="paramname"><em>elem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="classpcl_1_1_ordered_interface.html#ae15565d44fc2dc1ff2fb2bb541d746f6">pcl::OrderedInterface&lt; TType, TContainer, TAlloc &gt;::get_free_id()</a>, <a class="el" href="classpcl_1_1_ordered_interface.html#ad57e55a7f2e4d061f4dd2d5f78b11e7a">pcl::OrderedInterface&lt; TType, TContainer, TAlloc &gt;::m_elements</a>, and <a class="el" href="classpcl_1_1_ordered_interface.html#a8f658ffb0b7d93aeb64d2071c743e75f">pcl::OrderedInterface&lt; TType, TContainer, TAlloc &gt;::m_size</a>.</p>

<p class="reference">Referenced by <a class="el" href="classug_1_1_distributed_grid_manager.html#a07a67bf4dd6ca6b6d6a51f716023cf20">ug::DistributedGridManager::add_element_to_interface()</a>, <a class="el" href="namespaceug.html#abf8d23b0126010ea83a0260e6b23cbab">ug::AddConnectionsBetweenSlaves()</a>, <a class="el" href="namespaceug.html#a91093ee2bea136e72d3f5b3b88d2df0f">ug::AddExtraProcessEntriesToSubdomainLayout()</a>, <a class="el" href="namespaceug.html#a0872923a3552b6bd590b9a24c62d8430">ug::AddLayoutFromGlobalLayout()</a>, <a class="el" href="namespaceug.html#a207b43e7431f56746521de393a8f3fda">ug::BuildOneToManyLayout()</a>, <a class="el" href="namespaceug.html#a1f2ab4440bd70defa2f16e54071ac586">ug::DeserializeInterface()</a>, <a class="el" href="classug_1_1_com_pol___mat_create_overlap.html#a53b2038293353f028dbe2b9223f96f24">ug::ComPol_MatCreateOverlap&lt; TMatrix &gt;::post_process()</a>, <a class="el" href="namespaceug.html#a8481589812a443f06888946f76ef7c17">ug::ReceiveMatrix()</a>, and <a class="el" href="namespaceug.html#adf469b73bc057daa50f80ffaa8152daa">ug::SendMatrix()</a>.</p>

</div>
</div>
<a id="ad6c6e78b6001c10823254de7c5352669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6c6e78b6001c10823254de7c5352669">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TType , template&lt; class T, class Alloc &gt; class TContainer = std::vector, template&lt; class T &gt; class TAlloc = std::allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classpcl_1_1_ordered_interface.html">pcl::OrderedInterface</a>&lt; TType, TContainer, TAlloc &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the number of elements that are stored in the interface. </p>

<p class="reference">References <a class="el" href="classpcl_1_1_ordered_interface.html#a8f658ffb0b7d93aeb64d2071c743e75f">pcl::OrderedInterface&lt; TType, TContainer, TAlloc &gt;::m_size</a>.</p>

<p class="reference">Referenced by <a class="el" href="classug_1_1_com_pol___mat_add_set_zero_inner_interface_couplings.html#a763c078c797cd97628010fbfcb420e83">ug::ComPol_MatAddSetZeroInnerInterfaceCouplings&lt; TMatrix &gt;::collect()</a>, <a class="el" href="classpcl_1_1_ordered_interface.html#ab70a1fad284b3e0ee1bfad23ef7d8c66">pcl::OrderedInterface&lt; TType, TContainer, TAlloc &gt;::empty()</a>, <a class="el" href="classug_1_1_com_pol___mat_add_set_zero_inner_interface_couplings.html#ab25f906424557c8864b35439715a305d">ug::ComPol_MatAddSetZeroInnerInterfaceCouplings&lt; TMatrix &gt;::extract()</a>, <a class="el" href="classug_1_1_com_pol___vec_copy.html#ab4d550b67767fc19bbd44530a8ce5ae6">ug::ComPol_VecCopy&lt; TVector &gt;::get_required_buffer_size()</a>, <a class="el" href="classug_1_1_com_pol___vec_scale_copy.html#a07ae003931f8eaf6abea7dd000c53563">ug::ComPol_VecScaleCopy&lt; TVector &gt;::get_required_buffer_size()</a>, <a class="el" href="classug_1_1_com_pol___vec_add.html#a02f4f1c6b874f47e80eec09e5b290836">ug::ComPol_VecAdd&lt; TVector &gt;::get_required_buffer_size()</a>, <a class="el" href="classug_1_1_com_pol___vec_scale_add.html#a5b2a5c28ea52092981925a6fed6db59e">ug::ComPol_VecScaleAdd&lt; TVector &gt;::get_required_buffer_size()</a>, <a class="el" href="classug_1_1_com_pol___vec_add_set_zero.html#af6b6f8f3e87109f4f07d844814f68ef0">ug::ComPol_VecAddSetZero&lt; TVector &gt;::get_required_buffer_size()</a>, <a class="el" href="classug_1_1_com_pol___vec_subtract.html#a6c1c023c6f40e9f1b74ab528431b2f5b">ug::ComPol_VecSubtract&lt; TVector &gt;::get_required_buffer_size()</a>, <a class="el" href="classug_1_1_com_pol___check_consistency.html#af3bfc73c4da2afb512b89ce88deb68e2">ug::ComPol_CheckConsistency&lt; TVector &gt;::get_required_buffer_size()</a>, <a class="el" href="classug_1_1_com_pol___vec_subtract_only_one_slave.html#a0f0c3f9f65cb1307ce4a4a157be1ebc0">ug::ComPol_VecSubtractOnlyOneSlave&lt; TVector &gt;::get_required_buffer_size()</a>, <a class="el" href="classug_1_1_com_pol___mat_distribute_diag.html#a3143f1854d3968b40630961c6f03a28c">ug::ComPol_MatDistributeDiag&lt; TAlgebra &gt;::get_required_buffer_size()</a>, <a class="el" href="classug_1_1_communication_scheme.html#a385a8b3902dc3c3d7e4c7419d9558569">ug::CommunicationScheme&lt; TDerived, TValue &gt;::get_required_buffer_size()</a>, <a class="el" href="classug_1_1_communication_scheme_3_01_t_derived_00_01bool_01_4.html#aa7a434d946dcc853349f9d33af6fb4ee">ug::CommunicationScheme&lt; TDerived, bool &gt;::get_required_buffer_size()</a>, <a class="el" href="classug_1_1_com_pol___mat_copy_diag.html#a4e1e3d327c23560dabbf769102fecb47">ug::ComPol_MatCopyDiag&lt; TMatrix &gt;::get_required_buffer_size()</a>, <a class="el" href="namespaceug.html#ac0457d3e4758a6ccdd37488b84122a62">ug::NumIndices()</a>, <a class="el" href="classug_1_1_b_g_l_parallel_matrix.html#abc13d0bddab7193fceb897cb085eec51">ug::BGLParallelMatrix&lt; T &gt;::refresh()</a>, and <a class="el" href="namespaceug.html#a0aafbd652b123eb69a5f3b298a48e5b6">ug::SerializeInterface()</a>.</p>

</div>
</div>
<a id="a4737c862ffcf5893abaf8aa6b790dfe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4737c862ffcf5893abaf8aa6b790dfe9">&#9670;&nbsp;</a></span>sort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TType , template&lt; class T, class Alloc &gt; class TContainer = std::vector, template&lt; class T &gt; class TAlloc = std::allocator&gt; </div>
<div class="memtemplate">
template&lt;class TCompare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_ordered_interface.html">pcl::OrderedInterface</a>&lt; TType, TContainer, TAlloc &gt;::sort </td>
          <td>(</td>
          <td class="paramtype">TCompare&#160;</td>
          <td class="paramname"><em>cmp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>sort the entries in this interface. </p>

<p class="reference">References <a class="el" href="classpcl_1_1_ordered_interface.html#a00310ab46a9a5165421f189ae8f8f89f">pcl::OrderedInterface&lt; TType, TContainer, TAlloc &gt;::cmp()</a>, <a class="el" href="classpcl_1_1_ordered_interface.html#ad57e55a7f2e4d061f4dd2d5f78b11e7a">pcl::OrderedInterface&lt; TType, TContainer, TAlloc &gt;::m_elements</a>, and <a class="el" href="classpcl_1_1_ordered_interface.html#aeb039d3bca6aab1a21f1a8ba545233fa">pcl::OrderedInterface&lt; TType, TContainer, TAlloc &gt;::m_idCounter</a>.</p>

</div>
</div>
<a id="a1eda5984d1304e2071c3e9ce5eb5805c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eda5984d1304e2071c3e9ce5eb5805c">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TType , template&lt; class T, class Alloc &gt; class TContainer = std::vector, template&lt; class T &gt; class TAlloc = std::allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_ordered_interface.html">pcl::OrderedInterface</a>&lt; TType, TContainer, TAlloc &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_ordered_interface.html">OrderedInterface</a>&lt; TType, TContainer, TAlloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>interface</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>swaps the content of two interfaces. </p>
<p>m_elements, m_size, m_targetProc and m_idCounter are swapped. </p>

<p class="reference">References <a class="el" href="classpcl_1_1_ordered_interface.html#ad57e55a7f2e4d061f4dd2d5f78b11e7a">pcl::OrderedInterface&lt; TType, TContainer, TAlloc &gt;::m_elements</a>, <a class="el" href="classpcl_1_1_ordered_interface.html#aeb039d3bca6aab1a21f1a8ba545233fa">pcl::OrderedInterface&lt; TType, TContainer, TAlloc &gt;::m_idCounter</a>, <a class="el" href="classpcl_1_1_ordered_interface.html#a8f658ffb0b7d93aeb64d2071c743e75f">pcl::OrderedInterface&lt; TType, TContainer, TAlloc &gt;::m_size</a>, and <a class="el" href="classpcl_1_1_ordered_interface.html#a08634ee63970054312e82c4073ed0754">pcl::OrderedInterface&lt; TType, TContainer, TAlloc &gt;::m_targetProc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ad57e55a7f2e4d061f4dd2d5f78b11e7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad57e55a7f2e4d061f4dd2d5f78b11e7a">&#9670;&nbsp;</a></span>m_elements</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TType , template&lt; class T, class Alloc &gt; class TContainer = std::vector, template&lt; class T &gt; class TAlloc = std::allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcl_1_1_ordered_interface.html#a03959a54ffc81c2108f54f7a8ba2a872">ElemContainer</a> <a class="el" href="classpcl_1_1_ordered_interface.html">pcl::OrderedInterface</a>&lt; TType, TContainer, TAlloc &gt;::m_elements</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="classpcl_1_1_ordered_interface.html#a8b90a445fb14789fb9b257123c39f7ea">pcl::OrderedInterface&lt; TType, TContainer, TAlloc &gt;::begin()</a>, <a class="el" href="classpcl_1_1_ordered_interface.html#a4b82cef21a9e8490dec38c27776a7976">pcl::OrderedInterface&lt; TType, TContainer, TAlloc &gt;::end()</a>, <a class="el" href="classpcl_1_1_ordered_interface.html#ac3bd7c23e7821d8ebb4948bd1dcf1a36">pcl::OrderedInterface&lt; TType, TContainer, TAlloc &gt;::erase()</a>, <a class="el" href="classpcl_1_1_ordered_interface.html#aa8371adba709c3191c2a7eb9bda55499">pcl::OrderedInterface&lt; TType, TContainer, TAlloc &gt;::find_insert_pos_sorted()</a>, <a class="el" href="classpcl_1_1_ordered_interface.html#af6bd3fe237cb03c7938474e043a29e9a">pcl::OrderedInterface&lt; TType, TContainer, TAlloc &gt;::insert()</a>, <a class="el" href="classpcl_1_1_ordered_interface.html#a00cc2e223de0041fe699905b0afd792b">pcl::OrderedInterface&lt; TType, TContainer, TAlloc &gt;::push_back()</a>, <a class="el" href="classpcl_1_1_ordered_interface.html#a4737c862ffcf5893abaf8aa6b790dfe9">pcl::OrderedInterface&lt; TType, TContainer, TAlloc &gt;::sort()</a>, and <a class="el" href="classpcl_1_1_ordered_interface.html#a1eda5984d1304e2071c3e9ce5eb5805c">pcl::OrderedInterface&lt; TType, TContainer, TAlloc &gt;::swap()</a>.</p>

</div>
</div>
<a id="aeb039d3bca6aab1a21f1a8ba545233fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb039d3bca6aab1a21f1a8ba545233fa">&#9670;&nbsp;</a></span>m_idCounter</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TType , template&lt; class T, class Alloc &gt; class TContainer = std::vector, template&lt; class T &gt; class TAlloc = std::allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classpcl_1_1_ordered_interface.html">pcl::OrderedInterface</a>&lt; TType, TContainer, TAlloc &gt;::m_idCounter</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="classpcl_1_1_ordered_interface.html#ae15565d44fc2dc1ff2fb2bb541d746f6">pcl::OrderedInterface&lt; TType, TContainer, TAlloc &gt;::get_free_id()</a>, <a class="el" href="classpcl_1_1_ordered_interface.html#a4737c862ffcf5893abaf8aa6b790dfe9">pcl::OrderedInterface&lt; TType, TContainer, TAlloc &gt;::sort()</a>, and <a class="el" href="classpcl_1_1_ordered_interface.html#a1eda5984d1304e2071c3e9ce5eb5805c">pcl::OrderedInterface&lt; TType, TContainer, TAlloc &gt;::swap()</a>.</p>

</div>
</div>
<a id="a8f658ffb0b7d93aeb64d2071c743e75f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f658ffb0b7d93aeb64d2071c743e75f">&#9670;&nbsp;</a></span>m_size</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TType , template&lt; class T, class Alloc &gt; class TContainer = std::vector, template&lt; class T &gt; class TAlloc = std::allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classpcl_1_1_ordered_interface.html">pcl::OrderedInterface</a>&lt; TType, TContainer, TAlloc &gt;::m_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="classpcl_1_1_ordered_interface.html#ac3bd7c23e7821d8ebb4948bd1dcf1a36">pcl::OrderedInterface&lt; TType, TContainer, TAlloc &gt;::erase()</a>, <a class="el" href="classpcl_1_1_ordered_interface.html#af6bd3fe237cb03c7938474e043a29e9a">pcl::OrderedInterface&lt; TType, TContainer, TAlloc &gt;::insert()</a>, <a class="el" href="classpcl_1_1_ordered_interface.html#a00cc2e223de0041fe699905b0afd792b">pcl::OrderedInterface&lt; TType, TContainer, TAlloc &gt;::push_back()</a>, <a class="el" href="classpcl_1_1_ordered_interface.html#ad6c6e78b6001c10823254de7c5352669">pcl::OrderedInterface&lt; TType, TContainer, TAlloc &gt;::size()</a>, and <a class="el" href="classpcl_1_1_ordered_interface.html#a1eda5984d1304e2071c3e9ce5eb5805c">pcl::OrderedInterface&lt; TType, TContainer, TAlloc &gt;::swap()</a>.</p>

</div>
</div>
<a id="a08634ee63970054312e82c4073ed0754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08634ee63970054312e82c4073ed0754">&#9670;&nbsp;</a></span>m_targetProc</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TType , template&lt; class T, class Alloc &gt; class TContainer = std::vector, template&lt; class T &gt; class TAlloc = std::allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classpcl_1_1_ordered_interface.html">pcl::OrderedInterface</a>&lt; TType, TContainer, TAlloc &gt;::m_targetProc</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="classpcl_1_1_ordered_interface.html#ad59a408f466b6106620cb9d3fb3ca4e4">pcl::OrderedInterface&lt; TType, TContainer, TAlloc &gt;::get_target_proc()</a>, and <a class="el" href="classpcl_1_1_ordered_interface.html#a1eda5984d1304e2071c3e9ce5eb5805c">pcl::OrderedInterface&lt; TType, TContainer, TAlloc &gt;::swap()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>ugbase/pcl/<a class="el" href="pcl__communication__structs_8h_source.html">pcl_communication_structs.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacepcl.html">pcl</a></li><li class="navelem"><a class="el" href="classpcl_1_1_ordered_interface.html">OrderedInterface</a></li>
    <li class="footer">Generated on Mon Mar 18 2024 00:54:52 for ug4 by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
