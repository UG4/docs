<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ug4: ug::GridObserver Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ug4
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classug_1_1_grid_observer.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classug_1_1_grid_observer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ug::GridObserver Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="grid__observer_8h_source.html">grid_observer.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for ug::GridObserver:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="classug_1_1_grid_observer.png" usemap="#ug::GridObserver_map" alt=""/>
  <map id="ug::GridObserver_map" name="ug::GridObserver_map">
<area href="classug_1_1_copy_attachment_handler.html" alt="ug::CopyAttachmentHandler&lt; ug::Vertex, ug::Attachment&lt; ug::NeuriteProjector::SurfaceParams &gt; &gt;" shape="rect" coords="581,56,1152,80"/>
<area href="classug_1_1_hanging_node_refiner_base.html" alt="ug::HangingNodeRefinerBase&lt; MGSelector &gt;" shape="rect" coords="581,112,1152,136"/>
<area href="classug_1_1_hanging_node_refiner_base.html" alt="ug::HangingNodeRefinerBase&lt; Selector &gt;" shape="rect" coords="581,168,1152,192"/>
<area href="classug_1_1_adaption_surface_grid_function.html" alt="ug::AdaptionSurfaceGridFunction&lt; TDomain &gt;" shape="rect" coords="581,224,1152,248"/>
<area href="classug_1_1_bool_marker.html" title="Allows to mark elements." alt="ug::BoolMarker" shape="rect" coords="581,280,1152,304"/>
<area href="classug_1_1_copy_attachment_handler.html" title="handler for attachments in a multi-grid" alt="ug::CopyAttachmentHandler&lt; TElem, TAttachment &gt;" shape="rect" coords="581,336,1152,360"/>
<area href="classug_1_1_delaunay_info.html" alt="ug::DelaunayInfo&lt; TAAPos &gt;" shape="rect" coords="581,392,1152,416"/>
<area href="classug_1_1_distributed_grid_manager.html" title="manages the layouts and interfaces which are associated with a distributed grid." alt="ug::DistributedGridManager" shape="rect" coords="581,448,1152,472"/>
<area href="classug_1_1_global_fractured_media_refiner.html" alt="ug::GlobalFracturedMediaRefiner" shape="rect" coords="581,504,1152,528"/>
<area href="classug_1_1_global_multi_grid_refiner.html" alt="ug::GlobalMultiGridRefiner" shape="rect" coords="581,560,1152,584"/>
<area href="classug_1_1_hanging_node_refiner_base.html" title="Base class for a hanging-node refiner." alt="ug::HangingNodeRefinerBase&lt; TSelector &gt;" shape="rect" coords="581,616,1152,640"/>
<area href="classug_1_1_i_selector.html" title="base-implementation of a selector" alt="ug::ISelector" shape="rect" coords="581,672,1152,696"/>
<area href="classug_1_1_i_subset_handler.html" alt="ug::ISubsetHandler" shape="rect" coords="581,728,1152,752"/>
<area href="classug_1_1_multi_grid.html" alt="ug::MultiGrid" shape="rect" coords="581,784,1152,808"/>
<area href="classug_1_1_periodic_boundary_manager.html" alt="ug::PeriodicBoundaryManager" shape="rect" coords="581,840,1152,864"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3e6bfb8d606a813b0ff82d6712a2a6ec"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_grid_observer.html#a3e6bfb8d606a813b0ff82d6712a2a6ec">elements_to_be_cleared</a> (<a class="el" href="classug_1_1_grid.html">Grid</a> *grid)</td></tr>
<tr class="separator:a3e6bfb8d606a813b0ff82d6712a2a6ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61ddf58b3f6e237e55108563307dd9c1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_grid_observer.html#a61ddf58b3f6e237e55108563307dd9c1">grid_to_be_destroyed</a> (<a class="el" href="classug_1_1_grid.html">Grid</a> *grid)</td></tr>
<tr class="separator:a61ddf58b3f6e237e55108563307dd9c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94071d6999d20894445c4e7baa88e785"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_grid_observer.html#a94071d6999d20894445c4e7baa88e785">~GridObserver</a> ()</td></tr>
<tr class="separator:a94071d6999d20894445c4e7baa88e785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:adeab4893050fed4b7c5b50a646d3d623"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_grid_observer.html#adeab4893050fed4b7c5b50a646d3d623">vertex_created</a> (<a class="el" href="classug_1_1_grid.html">Grid</a> *grid, <a class="el" href="classug_1_1_vertex.html">Vertex</a> *vrt, <a class="el" href="classug_1_1_grid_object.html">GridObject</a> *pParent=NULL, bool replacesParent=false)</td></tr>
<tr class="memdesc:adeab4893050fed4b7c5b50a646d3d623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notified whenever a new element of the given type is created in the given grid.  <a href="classug_1_1_grid_observer.html#adeab4893050fed4b7c5b50a646d3d623">More...</a><br /></td></tr>
<tr class="separator:adeab4893050fed4b7c5b50a646d3d623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ee0a20d46e6058074da8959bc39619"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_grid_observer.html#a74ee0a20d46e6058074da8959bc39619">edge_created</a> (<a class="el" href="classug_1_1_grid.html">Grid</a> *grid, <a class="el" href="classug_1_1_edge.html">Edge</a> *e, <a class="el" href="classug_1_1_grid_object.html">GridObject</a> *pParent=NULL, bool replacesParent=false)</td></tr>
<tr class="memdesc:a74ee0a20d46e6058074da8959bc39619"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notified whenever a new element of the given type is created in the given grid.  <a href="classug_1_1_grid_observer.html#a74ee0a20d46e6058074da8959bc39619">More...</a><br /></td></tr>
<tr class="separator:a74ee0a20d46e6058074da8959bc39619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a881661659f5808690326d4042ba088bf"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_grid_observer.html#a881661659f5808690326d4042ba088bf">face_created</a> (<a class="el" href="classug_1_1_grid.html">Grid</a> *grid, <a class="el" href="classug_1_1_face.html">Face</a> *f, <a class="el" href="classug_1_1_grid_object.html">GridObject</a> *pParent=NULL, bool replacesParent=false)</td></tr>
<tr class="memdesc:a881661659f5808690326d4042ba088bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notified whenever a new element of the given type is created in the given grid.  <a href="classug_1_1_grid_observer.html#a881661659f5808690326d4042ba088bf">More...</a><br /></td></tr>
<tr class="separator:a881661659f5808690326d4042ba088bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72026a016ef098afedb0ed0c57654d15"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_grid_observer.html#a72026a016ef098afedb0ed0c57654d15">volume_created</a> (<a class="el" href="classug_1_1_grid.html">Grid</a> *grid, <a class="el" href="classug_1_1_volume.html">Volume</a> *vol, <a class="el" href="classug_1_1_grid_object.html">GridObject</a> *pParent=NULL, bool replacesParent=false)</td></tr>
<tr class="memdesc:a72026a016ef098afedb0ed0c57654d15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notified whenever a new element of the given type is created in the given grid.  <a href="classug_1_1_grid_observer.html#a72026a016ef098afedb0ed0c57654d15">More...</a><br /></td></tr>
<tr class="separator:a72026a016ef098afedb0ed0c57654d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a17cf8c78b1e87bbbb7dd36c8057a7ea1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_grid_observer.html#a17cf8c78b1e87bbbb7dd36c8057a7ea1">vertex_to_be_erased</a> (<a class="el" href="classug_1_1_grid.html">Grid</a> *grid, <a class="el" href="classug_1_1_vertex.html">Vertex</a> *vrt, <a class="el" href="classug_1_1_vertex.html">Vertex</a> *replacedBy=NULL)</td></tr>
<tr class="memdesc:a17cf8c78b1e87bbbb7dd36c8057a7ea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notified whenever an element of the given type is erased from the given grid.  <a href="classug_1_1_grid_observer.html#a17cf8c78b1e87bbbb7dd36c8057a7ea1">More...</a><br /></td></tr>
<tr class="separator:a17cf8c78b1e87bbbb7dd36c8057a7ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7ca49d8a723271f658a7cd78cad560b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_grid_observer.html#ae7ca49d8a723271f658a7cd78cad560b">edge_to_be_erased</a> (<a class="el" href="classug_1_1_grid.html">Grid</a> *grid, <a class="el" href="classug_1_1_edge.html">Edge</a> *e, <a class="el" href="classug_1_1_edge.html">Edge</a> *replacedBy=NULL)</td></tr>
<tr class="memdesc:ae7ca49d8a723271f658a7cd78cad560b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notified whenever an element of the given type is erased from the given grid.  <a href="classug_1_1_grid_observer.html#ae7ca49d8a723271f658a7cd78cad560b">More...</a><br /></td></tr>
<tr class="separator:ae7ca49d8a723271f658a7cd78cad560b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8946a9255bc70654627d1ef492d3139"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_grid_observer.html#ae8946a9255bc70654627d1ef492d3139">face_to_be_erased</a> (<a class="el" href="classug_1_1_grid.html">Grid</a> *grid, <a class="el" href="classug_1_1_face.html">Face</a> *f, <a class="el" href="classug_1_1_face.html">Face</a> *replacedBy=NULL)</td></tr>
<tr class="memdesc:ae8946a9255bc70654627d1ef492d3139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notified whenever an element of the given type is erased from the given grid.  <a href="classug_1_1_grid_observer.html#ae8946a9255bc70654627d1ef492d3139">More...</a><br /></td></tr>
<tr class="separator:ae8946a9255bc70654627d1ef492d3139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af17932064cfd1973e92531dae83c33e3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_grid_observer.html#af17932064cfd1973e92531dae83c33e3">volume_to_be_erased</a> (<a class="el" href="classug_1_1_grid.html">Grid</a> *grid, <a class="el" href="classug_1_1_volume.html">Volume</a> *vol, <a class="el" href="classug_1_1_volume.html">Volume</a> *replacedBy=NULL)</td></tr>
<tr class="memdesc:af17932064cfd1973e92531dae83c33e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notified whenever an element of the given type is erased from the given grid.  <a href="classug_1_1_grid_observer.html#af17932064cfd1973e92531dae83c33e3">More...</a><br /></td></tr>
<tr class="separator:af17932064cfd1973e92531dae83c33e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ae7251522c4b13db4612a2f31760f7f52"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_grid_observer.html#ae7251522c4b13db4612a2f31760f7f52">vertices_to_be_merged</a> (<a class="el" href="classug_1_1_grid.html">Grid</a> *grid, <a class="el" href="classug_1_1_vertex.html">Vertex</a> *target, <a class="el" href="classug_1_1_vertex.html">Vertex</a> *elem1, <a class="el" href="classug_1_1_vertex.html">Vertex</a> *elem2)</td></tr>
<tr class="memdesc:ae7251522c4b13db4612a2f31760f7f52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notified when two elements of the same type are going to be merged.  <a href="classug_1_1_grid_observer.html#ae7251522c4b13db4612a2f31760f7f52">More...</a><br /></td></tr>
<tr class="separator:ae7251522c4b13db4612a2f31760f7f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a822f91c91c62014bbb94af9447293d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_grid_observer.html#a5a822f91c91c62014bbb94af9447293d">edges_to_be_merged</a> (<a class="el" href="classug_1_1_grid.html">Grid</a> *grid, <a class="el" href="classug_1_1_edge.html">Edge</a> *target, <a class="el" href="classug_1_1_edge.html">Edge</a> *elem1, <a class="el" href="classug_1_1_edge.html">Edge</a> *elem2)</td></tr>
<tr class="memdesc:a5a822f91c91c62014bbb94af9447293d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notified when two elements of the same type are going to be merged.  <a href="classug_1_1_grid_observer.html#a5a822f91c91c62014bbb94af9447293d">More...</a><br /></td></tr>
<tr class="separator:a5a822f91c91c62014bbb94af9447293d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b9adadd7e51889f7b8840ea7db974a8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_grid_observer.html#a9b9adadd7e51889f7b8840ea7db974a8">faces_to_be_merged</a> (<a class="el" href="classug_1_1_grid.html">Grid</a> *grid, <a class="el" href="classug_1_1_face.html">Face</a> *target, <a class="el" href="classug_1_1_face.html">Face</a> *elem1, <a class="el" href="classug_1_1_face.html">Face</a> *elem2)</td></tr>
<tr class="memdesc:a9b9adadd7e51889f7b8840ea7db974a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notified when two elements of the same type are going to be merged.  <a href="classug_1_1_grid_observer.html#a9b9adadd7e51889f7b8840ea7db974a8">More...</a><br /></td></tr>
<tr class="separator:a9b9adadd7e51889f7b8840ea7db974a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5be264236cb594d882b3064664f39ab3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_grid_observer.html#a5be264236cb594d882b3064664f39ab3">volumes_to_be_merged</a> (<a class="el" href="classug_1_1_grid.html">Grid</a> *grid, <a class="el" href="classug_1_1_volume.html">Volume</a> *target, <a class="el" href="classug_1_1_volume.html">Volume</a> *elem1, <a class="el" href="classug_1_1_volume.html">Volume</a> *elem2)</td></tr>
<tr class="memdesc:a5be264236cb594d882b3064664f39ab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notified when two elements of the same type are going to be merged.  <a href="classug_1_1_grid_observer.html#a5be264236cb594d882b3064664f39ab3">More...</a><br /></td></tr>
<tr class="separator:a5be264236cb594d882b3064664f39ab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The grid observer defines an interface that can be specialized by classes that want to be informed about changes in a grid. If a class derives from <a class="el" href="classug_1_1_grid_observer.html">GridObserver</a>, it can be registered at a grid. Registration is usually performed through a member function of the observer class itself. Most observers can only be registered at one grid at a time.</p>
<p>Please note that methods of different observers are called in the order in which they were registered at the grid. The only exception are the vertex_to_be_erased, edge_to_be_erased, face_to_be_erased and volume_to_be_erased. Those method are called in reverse order of registration. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a94071d6999d20894445c4e7baa88e785"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94071d6999d20894445c4e7baa88e785">&#9670;&nbsp;</a></span>~GridObserver()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ug::GridObserver::~GridObserver </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a74ee0a20d46e6058074da8959bc39619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74ee0a20d46e6058074da8959bc39619">&#9670;&nbsp;</a></span>edge_created()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ug::GridObserver::edge_created </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid.html">Grid</a> *&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_edge.html">Edge</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid_object.html">GridObject</a> *&#160;</td>
          <td class="paramname"><em>pParent</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>replacesParent</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notified whenever a new element of the given type is created in the given grid. </p>
<p>Creation callbacks are called in the order in which the GridObservers were registered at the given grid.</p>
<p>If replacesParent is true, then pParent is of the same base type as the created object (e.g. in case of edge_created, the parent is an Edge*). This case usually appears, when a contraining object is replaced by a regular grid object if the same base type during refinement. The method is called with replacesParent == true by <a class="el" href="classug_1_1_grid.html#ac10ee97eabf9e5cb29d920ce77b82ac6" title="create a custom element and replaces an old one.">Grid::create_and_replace</a> methods.</p>
<p>Please note: If replacesParent == true, then a call to OBJECT_to_be_erased(grid, pParent, obj) will follow (OBJECT and obj are pseudonyms for the concrete type). </p>

<p>Reimplemented in <a class="el" href="classug_1_1_i_subset_handler.html#a8f60c2bc28aa15850826615f9428f304">ug::ISubsetHandler</a>, <a class="el" href="classug_1_1_i_selector.html#a22f91daf1722b45263249d17234196b5">ug::ISelector</a>, <a class="el" href="classug_1_1_periodic_boundary_manager.html#a96df00e0ad51a085be78f0421b93b89a">ug::PeriodicBoundaryManager</a>, <a class="el" href="classug_1_1_copy_attachment_handler.html#a7372366b17d585dcd168b48479a736d1">ug::CopyAttachmentHandler&lt; TElem, TAttachment &gt;</a>, <a class="el" href="classug_1_1_copy_attachment_handler.html#a7372366b17d585dcd168b48479a736d1">ug::CopyAttachmentHandler&lt; ug::Vertex, ug::Attachment&lt; ug::NeuriteProjector::SurfaceParams &gt; &gt;</a>, <a class="el" href="classug_1_1_bool_marker.html#af54c863c996b337ede7f24a5f36d8b07">ug::BoolMarker</a>, <a class="el" href="classug_1_1_distributed_grid_manager.html#aa23759b7101fb201062c5d112fb40ed4">ug::DistributedGridManager</a>, <a class="el" href="classug_1_1_multi_grid.html#a8b786827ac6b836498573832810aeb66">ug::MultiGrid</a>, <a class="el" href="classug_1_1_adaption_surface_grid_function.html#a0dd498880b806a3b244ebfbf02f13eed">ug::AdaptionSurfaceGridFunction&lt; TDomain &gt;</a>, and <a class="el" href="classug_1_1_delaunay_info.html#a5b25022c0a1d33cdccfce38d115737c2">ug::DelaunayInfo&lt; TAAPos &gt;</a>.</p>

</div>
</div>
<a id="ae7ca49d8a723271f658a7cd78cad560b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7ca49d8a723271f658a7cd78cad560b">&#9670;&nbsp;</a></span>edge_to_be_erased()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ug::GridObserver::edge_to_be_erased </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid.html">Grid</a> *&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_edge.html">Edge</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_edge.html">Edge</a> *&#160;</td>
          <td class="paramname"><em>replacedBy</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notified whenever an element of the given type is erased from the given grid. </p>
<p>Erase callbacks are called in reverse order in which the GridObservers were registered at the given grid.</p>
<p>if replacedBy != NULL the erased object is only replaced by another grid object of the same base type. This usually happens when constraining objects are replaced by regular objects in refinements. (E.g. a constraining edge by become a regular <a class="el" href="classug_1_1_edge.html" title="Base-class for edges.">Edge</a>; note that both objects are of type Edge*). </p>

<p>Reimplemented in <a class="el" href="classug_1_1_i_subset_handler.html#ab688519970797b103d400b1c48c3beb6">ug::ISubsetHandler</a>, <a class="el" href="classug_1_1_i_selector.html#a9d6940bff0cc1e5e05fbf2345f98a041">ug::ISelector</a>, <a class="el" href="classug_1_1_periodic_boundary_manager.html#ac1ac2d6f4f482b01622e5a48c828b57e">ug::PeriodicBoundaryManager</a>, <a class="el" href="classug_1_1_distributed_grid_manager.html#aeb869900523051672fcb448357e2e9f4">ug::DistributedGridManager</a>, <a class="el" href="classug_1_1_multi_grid.html#ac6fd17131c16842d1f75f759f0c934cb">ug::MultiGrid</a>, and <a class="el" href="classug_1_1_delaunay_info.html#af3c22f980ef33392b7d0603d2f0f69d9">ug::DelaunayInfo&lt; TAAPos &gt;</a>.</p>

</div>
</div>
<a id="a5a822f91c91c62014bbb94af9447293d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a822f91c91c62014bbb94af9447293d">&#9670;&nbsp;</a></span>edges_to_be_merged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ug::GridObserver::edges_to_be_merged </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid.html">Grid</a> *&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_edge.html">Edge</a> *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_edge.html">Edge</a> *&#160;</td>
          <td class="paramname"><em>elem1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_edge.html">Edge</a> *&#160;</td>
          <td class="paramname"><em>elem2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notified when two elements of the same type are going to be merged. </p>
<p>Note that this method is invoked by <a class="el" href="classug_1_1_grid.html#ac045932a053db8e94eef57bf7853c61f" title="notifies the grid that two objects will be merged.">Grid::objects_will_be_merged</a>, which is called from outside the grid class. Implementors of algorithms in which objects are merged are thus responsible to call <a class="el" href="classug_1_1_grid.html#ac045932a053db8e94eef57bf7853c61f" title="notifies the grid that two objects will be merged.">Grid::objects_will_be_merged</a>.</p>
<p>This callback is called in addition to ..._created and ..._to_be_erased callbacks and should thus only be used if small adjustments have to be made during a merge.</p>
<p>Note that target may be identical to elem1 or elem2. </p>

<p>Reimplemented in <a class="el" href="classug_1_1_i_subset_handler.html#a7fbe7d89b714474b7d04d3454aea6c2e">ug::ISubsetHandler</a>, <a class="el" href="classug_1_1_i_selector.html#ad255566535664449b23a827ba47f2b18">ug::ISelector</a>, and <a class="el" href="classug_1_1_bool_marker.html#ae6d94f4660d2c320a67198d892307968">ug::BoolMarker</a>.</p>

</div>
</div>
<a id="a3e6bfb8d606a813b0ff82d6712a2a6ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e6bfb8d606a813b0ff82d6712a2a6ec">&#9670;&nbsp;</a></span>elements_to_be_cleared()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ug::GridObserver::elements_to_be_cleared </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid.html">Grid</a> *&#160;</td>
          <td class="paramname"><em>grid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classug_1_1_i_subset_handler.html#ae330edfa27f6f291f0d8c1da522f216d">ug::ISubsetHandler</a>, <a class="el" href="classug_1_1_i_selector.html#a18bcff733a1f424a00dc152c73886410">ug::ISelector</a>, and <a class="el" href="classug_1_1_multi_grid.html#ad836ac437d7dce9ffa17c6f609ca769d">ug::MultiGrid</a>.</p>

</div>
</div>
<a id="a881661659f5808690326d4042ba088bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a881661659f5808690326d4042ba088bf">&#9670;&nbsp;</a></span>face_created()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ug::GridObserver::face_created </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid.html">Grid</a> *&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_face.html">Face</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid_object.html">GridObject</a> *&#160;</td>
          <td class="paramname"><em>pParent</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>replacesParent</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notified whenever a new element of the given type is created in the given grid. </p>
<p>Creation callbacks are called in the order in which the GridObservers were registered at the given grid.</p>
<p>If replacesParent is true, then pParent is of the same base type as the created object (e.g. in case of edge_created, the parent is an Edge*). This case usually appears, when a contraining object is replaced by a regular grid object if the same base type during refinement. The method is called with replacesParent == true by <a class="el" href="classug_1_1_grid.html#ac10ee97eabf9e5cb29d920ce77b82ac6" title="create a custom element and replaces an old one.">Grid::create_and_replace</a> methods.</p>
<p>Please note: If replacesParent == true, then a call to OBJECT_to_be_erased(grid, pParent, obj) will follow (OBJECT and obj are pseudonyms for the concrete type). </p>

<p>Reimplemented in <a class="el" href="classug_1_1_i_subset_handler.html#a9d39276f6b1de4cf80643245e833bbec">ug::ISubsetHandler</a>, <a class="el" href="classug_1_1_i_selector.html#af085e028cac079a6bb55da0e29b4e497">ug::ISelector</a>, <a class="el" href="classug_1_1_periodic_boundary_manager.html#a4cd07b9dee845f0abc37e180b00d5ec2">ug::PeriodicBoundaryManager</a>, <a class="el" href="classug_1_1_copy_attachment_handler.html#a50ed785eb8a2305726367480aa114ada">ug::CopyAttachmentHandler&lt; TElem, TAttachment &gt;</a>, <a class="el" href="classug_1_1_copy_attachment_handler.html#a50ed785eb8a2305726367480aa114ada">ug::CopyAttachmentHandler&lt; ug::Vertex, ug::Attachment&lt; ug::NeuriteProjector::SurfaceParams &gt; &gt;</a>, <a class="el" href="classug_1_1_bool_marker.html#aca1157bf271f01a6811abe291b706eb2">ug::BoolMarker</a>, <a class="el" href="classug_1_1_distributed_grid_manager.html#a6b1c4a5a8f10aaceb27a31270234fa03">ug::DistributedGridManager</a>, <a class="el" href="classug_1_1_multi_grid.html#a66afe57436e19b96965a42a2d3f87601">ug::MultiGrid</a>, <a class="el" href="classug_1_1_adaption_surface_grid_function.html#a7d0058da5db84dea8ddfe50723eaf8ea">ug::AdaptionSurfaceGridFunction&lt; TDomain &gt;</a>, and <a class="el" href="classug_1_1_delaunay_info.html#a36dd0759f8672ac1112f1e7e4166f23b">ug::DelaunayInfo&lt; TAAPos &gt;</a>.</p>

</div>
</div>
<a id="ae8946a9255bc70654627d1ef492d3139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8946a9255bc70654627d1ef492d3139">&#9670;&nbsp;</a></span>face_to_be_erased()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ug::GridObserver::face_to_be_erased </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid.html">Grid</a> *&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_face.html">Face</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_face.html">Face</a> *&#160;</td>
          <td class="paramname"><em>replacedBy</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notified whenever an element of the given type is erased from the given grid. </p>
<p>Erase callbacks are called in reverse order in which the GridObservers were registered at the given grid.</p>
<p>if replacedBy != NULL the erased object is only replaced by another grid object of the same base type. This usually happens when constraining objects are replaced by regular objects in refinements. (E.g. a constraining edge by become a regular <a class="el" href="classug_1_1_edge.html" title="Base-class for edges.">Edge</a>; note that both objects are of type Edge*). </p>

<p>Reimplemented in <a class="el" href="classug_1_1_i_subset_handler.html#ac3c3e5e587ceef29fc6d5fdce0268a55">ug::ISubsetHandler</a>, <a class="el" href="classug_1_1_i_selector.html#a6c0794d493faf3a27db5185e9818c964">ug::ISelector</a>, <a class="el" href="classug_1_1_periodic_boundary_manager.html#a20c9259d1a5745ff71ff6d0efae854ee">ug::PeriodicBoundaryManager</a>, <a class="el" href="classug_1_1_distributed_grid_manager.html#a4c4ca65a9d90ca20b0cf09815bc6ede1">ug::DistributedGridManager</a>, <a class="el" href="classug_1_1_multi_grid.html#accca2da6e1913ba6ed1a620099ce0103">ug::MultiGrid</a>, and <a class="el" href="classug_1_1_delaunay_info.html#ad77c06b0e7198cf250accc4bc5b25864">ug::DelaunayInfo&lt; TAAPos &gt;</a>.</p>

</div>
</div>
<a id="a9b9adadd7e51889f7b8840ea7db974a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b9adadd7e51889f7b8840ea7db974a8">&#9670;&nbsp;</a></span>faces_to_be_merged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ug::GridObserver::faces_to_be_merged </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid.html">Grid</a> *&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_face.html">Face</a> *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_face.html">Face</a> *&#160;</td>
          <td class="paramname"><em>elem1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_face.html">Face</a> *&#160;</td>
          <td class="paramname"><em>elem2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notified when two elements of the same type are going to be merged. </p>
<p>Note that this method is invoked by <a class="el" href="classug_1_1_grid.html#ac045932a053db8e94eef57bf7853c61f" title="notifies the grid that two objects will be merged.">Grid::objects_will_be_merged</a>, which is called from outside the grid class. Implementors of algorithms in which objects are merged are thus responsible to call <a class="el" href="classug_1_1_grid.html#ac045932a053db8e94eef57bf7853c61f" title="notifies the grid that two objects will be merged.">Grid::objects_will_be_merged</a>.</p>
<p>This callback is called in addition to ..._created and ..._to_be_erased callbacks and should thus only be used if small adjustments have to be made during a merge.</p>
<p>Note that target may be identical to elem1 or elem2. </p>

<p>Reimplemented in <a class="el" href="classug_1_1_i_subset_handler.html#ad2299c2690b6ae519f501a1effc735ef">ug::ISubsetHandler</a>, <a class="el" href="classug_1_1_i_selector.html#ab667e573334424148cbcf0ef154221cb">ug::ISelector</a>, and <a class="el" href="classug_1_1_bool_marker.html#ad3c62e1ac2aaf858b5a8ee49120d9351">ug::BoolMarker</a>.</p>

</div>
</div>
<a id="a61ddf58b3f6e237e55108563307dd9c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61ddf58b3f6e237e55108563307dd9c1">&#9670;&nbsp;</a></span>grid_to_be_destroyed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ug::GridObserver::grid_to_be_destroyed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid.html">Grid</a> *&#160;</td>
          <td class="paramname"><em>grid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classug_1_1_multi_grid_subset_handler.html#abafabc75fe9231190a4ae2bab7424d3d">ug::MultiGridSubsetHandler</a>, <a class="el" href="classug_1_1_i_subset_handler.html#a63c45987a00323bc433cb8637054db83">ug::ISubsetHandler</a>, <a class="el" href="classug_1_1_grid_subset_handler.html#ad1d698d3b0ef3f8ca93af9c8b101f906">ug::GridSubsetHandler</a>, <a class="el" href="classug_1_1_m_g_selector.html#a2f376120873772dabe50d89470549957">ug::MGSelector</a>, <a class="el" href="classug_1_1_i_selector.html#a0e0b40382fdc409fbf624ecc3db1f031">ug::ISelector</a>, <a class="el" href="classug_1_1_selector.html#a10f0f3fb6e157d6617a26335785e3c68">ug::Selector</a>, <a class="el" href="classug_1_1_periodic_boundary_manager.html#a4f653b5c6780a83ab107e176f3cb4aa0">ug::PeriodicBoundaryManager</a>, <a class="el" href="classug_1_1_bool_marker.html#a3d16bedfc2859545c9aac2a77ad4711e">ug::BoolMarker</a>, <a class="el" href="classug_1_1_hanging_node_refiner___multi_grid.html#af75f611a3998d9bc595ccc98aea6d454">ug::HangingNodeRefiner_MultiGrid</a>, <a class="el" href="classug_1_1_hanging_node_refiner___grid.html#af9fd75e3e7cfb98f724ff8f4f46813b3">ug::HangingNodeRefiner_Grid</a>, <a class="el" href="classug_1_1_hanging_node_refiner_base.html#a22f7e9aa9ff7bf7f71990160b3ce67e2">ug::HangingNodeRefinerBase&lt; TSelector &gt;</a>, <a class="el" href="classug_1_1_hanging_node_refiner_base.html#a22f7e9aa9ff7bf7f71990160b3ce67e2">ug::HangingNodeRefinerBase&lt; MGSelector &gt;</a>, <a class="el" href="classug_1_1_hanging_node_refiner_base.html#a22f7e9aa9ff7bf7f71990160b3ce67e2">ug::HangingNodeRefinerBase&lt; Selector &gt;</a>, <a class="el" href="classug_1_1_global_multi_grid_refiner.html#a8d62e7b9729fb6cf5d98448be2b85386">ug::GlobalMultiGridRefiner</a>, <a class="el" href="classug_1_1_global_fractured_media_refiner.html#aad1e3a9100b63fa2376b111814fc83ca">ug::GlobalFracturedMediaRefiner</a>, and <a class="el" href="classug_1_1_distributed_grid_manager.html#a09c0283a536340e52bb024876150f9c5">ug::DistributedGridManager</a>.</p>

</div>
</div>
<a id="adeab4893050fed4b7c5b50a646d3d623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeab4893050fed4b7c5b50a646d3d623">&#9670;&nbsp;</a></span>vertex_created()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ug::GridObserver::vertex_created </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid.html">Grid</a> *&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>vrt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid_object.html">GridObject</a> *&#160;</td>
          <td class="paramname"><em>pParent</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>replacesParent</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notified whenever a new element of the given type is created in the given grid. </p>
<p>Creation callbacks are called in the order in which the GridObservers were registered at the given grid.</p>
<p>If replacesParent is true, then pParent is of the same base type as the created object (e.g. in case of edge_created, the parent is an Edge*). This case usually appears, when a contraining object is replaced by a regular grid object if the same base type during refinement. The method is called with replacesParent == true by <a class="el" href="classug_1_1_grid.html#ac10ee97eabf9e5cb29d920ce77b82ac6" title="create a custom element and replaces an old one.">Grid::create_and_replace</a> methods.</p>
<p>Please note: If replacesParent == true, then a call to OBJECT_to_be_erased(grid, pParent, obj) will follow (OBJECT and obj are pseudonyms for the concrete type). </p>

<p>Reimplemented in <a class="el" href="classug_1_1_i_subset_handler.html#a372be941c44cf581bfa606de562bcd8e">ug::ISubsetHandler</a>, <a class="el" href="classug_1_1_i_selector.html#a9d4979a02d7d95f0196731635dccfd19">ug::ISelector</a>, <a class="el" href="classug_1_1_periodic_boundary_manager.html#ade2c6da75edd9f7e0015698ad81f69ac">ug::PeriodicBoundaryManager</a>, <a class="el" href="classug_1_1_copy_attachment_handler.html#ac414dff96ea0b7f6a050887968143364">ug::CopyAttachmentHandler&lt; TElem, TAttachment &gt;</a>, <a class="el" href="classug_1_1_copy_attachment_handler.html#ac414dff96ea0b7f6a050887968143364">ug::CopyAttachmentHandler&lt; ug::Vertex, ug::Attachment&lt; ug::NeuriteProjector::SurfaceParams &gt; &gt;</a>, <a class="el" href="classug_1_1_bool_marker.html#ada1a56b24e394d8998e75cc73f79cb75">ug::BoolMarker</a>, <a class="el" href="classug_1_1_distributed_grid_manager.html#a4665b9f92aede16b57eb68ab105c201a">ug::DistributedGridManager</a>, <a class="el" href="classug_1_1_multi_grid.html#a9ead689658fa5c78379fde006b8d1c44">ug::MultiGrid</a>, <a class="el" href="classug_1_1_adaption_surface_grid_function.html#aa53a37628f11ac4a7aa52faefd92bd62">ug::AdaptionSurfaceGridFunction&lt; TDomain &gt;</a>, and <a class="el" href="classug_1_1_delaunay_info.html#a1ad546b9a4ebc0a125ceafbec52356f4">ug::DelaunayInfo&lt; TAAPos &gt;</a>.</p>

</div>
</div>
<a id="a17cf8c78b1e87bbbb7dd36c8057a7ea1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17cf8c78b1e87bbbb7dd36c8057a7ea1">&#9670;&nbsp;</a></span>vertex_to_be_erased()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ug::GridObserver::vertex_to_be_erased </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid.html">Grid</a> *&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>vrt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>replacedBy</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notified whenever an element of the given type is erased from the given grid. </p>
<p>Erase callbacks are called in reverse order in which the GridObservers were registered at the given grid.</p>
<p>if replacedBy != NULL the erased object is only replaced by another grid object of the same base type. This usually happens when constraining objects are replaced by regular objects in refinements. (E.g. a constraining edge by become a regular <a class="el" href="classug_1_1_edge.html" title="Base-class for edges.">Edge</a>; note that both objects are of type Edge*). </p>

<p>Reimplemented in <a class="el" href="classug_1_1_i_subset_handler.html#a0c0330748989091e186e84f29a272965">ug::ISubsetHandler</a>, <a class="el" href="classug_1_1_i_selector.html#a7c2e658532b7c9b2d442b2678b2fb438">ug::ISelector</a>, <a class="el" href="classug_1_1_periodic_boundary_manager.html#ad05aedc04677bd0e80f15b372969cced">ug::PeriodicBoundaryManager</a>, <a class="el" href="classug_1_1_distributed_grid_manager.html#a88be5b0a2b42416a17e29d924d69098b">ug::DistributedGridManager</a>, and <a class="el" href="classug_1_1_multi_grid.html#a0d476f26492cdbfa43c72930e733fe03">ug::MultiGrid</a>.</p>

</div>
</div>
<a id="ae7251522c4b13db4612a2f31760f7f52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7251522c4b13db4612a2f31760f7f52">&#9670;&nbsp;</a></span>vertices_to_be_merged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ug::GridObserver::vertices_to_be_merged </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid.html">Grid</a> *&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>elem1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>elem2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notified when two elements of the same type are going to be merged. </p>
<p>Note that this method is invoked by <a class="el" href="classug_1_1_grid.html#ac045932a053db8e94eef57bf7853c61f" title="notifies the grid that two objects will be merged.">Grid::objects_will_be_merged</a>, which is called from outside the grid class. Implementors of algorithms in which objects are merged are thus responsible to call <a class="el" href="classug_1_1_grid.html#ac045932a053db8e94eef57bf7853c61f" title="notifies the grid that two objects will be merged.">Grid::objects_will_be_merged</a>.</p>
<p>This callback is called in addition to ..._created and ..._to_be_erased callbacks and should thus only be used if small adjustments have to be made during a merge.</p>
<p>Note that target may be identical to elem1 or elem2. </p>

<p>Reimplemented in <a class="el" href="classug_1_1_i_subset_handler.html#a47c3f2c6749f7f1484facebcfb725eee">ug::ISubsetHandler</a>, <a class="el" href="classug_1_1_i_selector.html#a203ffc92f9a39d3d30f541584c9e4eaf">ug::ISelector</a>, and <a class="el" href="classug_1_1_bool_marker.html#aadc2fb9113a259aab89a759289c66d25">ug::BoolMarker</a>.</p>

</div>
</div>
<a id="a72026a016ef098afedb0ed0c57654d15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72026a016ef098afedb0ed0c57654d15">&#9670;&nbsp;</a></span>volume_created()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ug::GridObserver::volume_created </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid.html">Grid</a> *&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_volume.html">Volume</a> *&#160;</td>
          <td class="paramname"><em>vol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid_object.html">GridObject</a> *&#160;</td>
          <td class="paramname"><em>pParent</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>replacesParent</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notified whenever a new element of the given type is created in the given grid. </p>
<p>Creation callbacks are called in the order in which the GridObservers were registered at the given grid.</p>
<p>If replacesParent is true, then pParent is of the same base type as the created object (e.g. in case of edge_created, the parent is an Edge*). This case usually appears, when a contraining object is replaced by a regular grid object if the same base type during refinement. The method is called with replacesParent == true by <a class="el" href="classug_1_1_grid.html#ac10ee97eabf9e5cb29d920ce77b82ac6" title="create a custom element and replaces an old one.">Grid::create_and_replace</a> methods.</p>
<p>Please note: If replacesParent == true, then a call to OBJECT_to_be_erased(grid, pParent, obj) will follow (OBJECT and obj are pseudonyms for the concrete type). </p>

<p>Reimplemented in <a class="el" href="classug_1_1_i_subset_handler.html#aaa78f6d38c58feefc7284324a40b904f">ug::ISubsetHandler</a>, <a class="el" href="classug_1_1_i_selector.html#aa48a3c895f9083f9e8ae65b4f7ee9696">ug::ISelector</a>, <a class="el" href="classug_1_1_copy_attachment_handler.html#a0960c73e3befaab897fb5b81d43e2d59">ug::CopyAttachmentHandler&lt; TElem, TAttachment &gt;</a>, <a class="el" href="classug_1_1_copy_attachment_handler.html#a0960c73e3befaab897fb5b81d43e2d59">ug::CopyAttachmentHandler&lt; ug::Vertex, ug::Attachment&lt; ug::NeuriteProjector::SurfaceParams &gt; &gt;</a>, <a class="el" href="classug_1_1_bool_marker.html#a3be44156d29842557edf1bc806754ea6">ug::BoolMarker</a>, <a class="el" href="classug_1_1_multi_grid.html#a35f93d27b3b3a0bd0e9a24b4c1042811">ug::MultiGrid</a>, <a class="el" href="classug_1_1_adaption_surface_grid_function.html#ac3c1f0684e6bb45de25e8aaab0d1f8e7">ug::AdaptionSurfaceGridFunction&lt; TDomain &gt;</a>, and <a class="el" href="classug_1_1_distributed_grid_manager.html#a0c4e6949db73ae6ba4b30c7ed05edf44">ug::DistributedGridManager</a>.</p>

</div>
</div>
<a id="af17932064cfd1973e92531dae83c33e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af17932064cfd1973e92531dae83c33e3">&#9670;&nbsp;</a></span>volume_to_be_erased()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ug::GridObserver::volume_to_be_erased </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid.html">Grid</a> *&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_volume.html">Volume</a> *&#160;</td>
          <td class="paramname"><em>vol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_volume.html">Volume</a> *&#160;</td>
          <td class="paramname"><em>replacedBy</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notified whenever an element of the given type is erased from the given grid. </p>
<p>Erase callbacks are called in reverse order in which the GridObservers were registered at the given grid.</p>
<p>if replacedBy != NULL the erased object is only replaced by another grid object of the same base type. This usually happens when constraining objects are replaced by regular objects in refinements. (E.g. a constraining edge by become a regular <a class="el" href="classug_1_1_edge.html" title="Base-class for edges.">Edge</a>; note that both objects are of type Edge*). </p>

<p>Reimplemented in <a class="el" href="classug_1_1_i_subset_handler.html#ac49dfaf0d33b26f0a1f7e43240ac411e">ug::ISubsetHandler</a>, <a class="el" href="classug_1_1_i_selector.html#a78e63dd202ced7530cd6ec2aa6462332">ug::ISelector</a>, <a class="el" href="classug_1_1_distributed_grid_manager.html#af495334527c1170766b3e257421aa29b">ug::DistributedGridManager</a>, and <a class="el" href="classug_1_1_multi_grid.html#a736cba95d6508d5d5cc8d4804d0e7f82">ug::MultiGrid</a>.</p>

</div>
</div>
<a id="a5be264236cb594d882b3064664f39ab3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5be264236cb594d882b3064664f39ab3">&#9670;&nbsp;</a></span>volumes_to_be_merged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ug::GridObserver::volumes_to_be_merged </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid.html">Grid</a> *&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_volume.html">Volume</a> *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_volume.html">Volume</a> *&#160;</td>
          <td class="paramname"><em>elem1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_volume.html">Volume</a> *&#160;</td>
          <td class="paramname"><em>elem2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notified when two elements of the same type are going to be merged. </p>
<p>Note that this method is invoked by <a class="el" href="classug_1_1_grid.html#ac045932a053db8e94eef57bf7853c61f" title="notifies the grid that two objects will be merged.">Grid::objects_will_be_merged</a>, which is called from outside the grid class. Implementors of algorithms in which objects are merged are thus responsible to call <a class="el" href="classug_1_1_grid.html#ac045932a053db8e94eef57bf7853c61f" title="notifies the grid that two objects will be merged.">Grid::objects_will_be_merged</a>.</p>
<p>This callback is called in addition to ..._created and ..._to_be_erased callbacks and should thus only be used if small adjustments have to be made during a merge.</p>
<p>Note that target may be identical to elem1 or elem2. </p>

<p>Reimplemented in <a class="el" href="classug_1_1_i_subset_handler.html#ac03c7b6d19989937f0a6fe675d69a3b6">ug::ISubsetHandler</a>, <a class="el" href="classug_1_1_i_selector.html#a63f89ab52bf0517848e9fca8361e3a7e">ug::ISelector</a>, and <a class="el" href="classug_1_1_bool_marker.html#a72bcf0cc987a9d671b74d393fe2f35c7">ug::BoolMarker</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>ugbase/lib_grid/grid/<a class="el" href="grid__observer_8h_source.html">grid_observer.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceug.html">ug</a></li><li class="navelem"><a class="el" href="classug_1_1_grid_observer.html">GridObserver</a></li>
    <li class="footer">Generated on Mon Aug 7 2023 01:03:47 for ug4 by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
