<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ug4: vertex util</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ug4
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__lib__grid__algorithms__vertex__util.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">vertex util<div class="ingroups"><a class="el" href="group__lib__grid.html">lib_grid</a> &raquo; <a class="el" href="group__lib__grid__algorithms.html">algorithms</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>contains methods to manipulate vertices  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaafbc69674722a7e02b72c6017321f07c"><td class="memTemplParams" colspan="2">template&lt;class TVrtIter , class TAPosition &gt; </td></tr>
<tr class="memitem:gaafbc69674722a7e02b72c6017321f07c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> TAPosition::ValueType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__vertex__util.html#gaafbc69674722a7e02b72c6017321f07c">ug::CalculateBarycenter</a> (TVrtIter vrtsBegin, TVrtIter vrtsEnd, <a class="el" href="classug_1_1_grid_1_1_vertex_attachment_accessor.html">Grid::VertexAttachmentAccessor</a>&lt; TAPosition &gt; &amp;aaPos)</td></tr>
<tr class="memdesc:gaafbc69674722a7e02b72c6017321f07c"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculates the barycenter of a set of vertices  <a href="group__lib__grid__algorithms__vertex__util.html#gaafbc69674722a7e02b72c6017321f07c">More...</a><br /></td></tr>
<tr class="separator:gaafbc69674722a7e02b72c6017321f07c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5e8fa8b773f83df4f63e0f75968bf6f"><td class="memTemplParams" colspan="2">template&lt;class TAAPosVRT &gt; </td></tr>
<tr class="memitem:gae5e8fa8b773f83df4f63e0f75968bf6f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__vertex__util.html#gae5e8fa8b773f83df4f63e0f75968bf6f">ug::CalculateBoundaryVertexNormal2D</a> (typename TAAPosVRT::ValueType &amp;nOut, <a class="el" href="classug_1_1_grid.html">Grid</a> &amp;grid, <a class="el" href="classug_1_1_vertex.html">Vertex</a> *vrt, TAAPosVRT &amp;aaPos)</td></tr>
<tr class="memdesc:gae5e8fa8b773f83df4f63e0f75968bf6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculates the normal of a boundary vertex using associated faces  <a href="group__lib__grid__algorithms__vertex__util.html#gae5e8fa8b773f83df4f63e0f75968bf6f">More...</a><br /></td></tr>
<tr class="separator:gae5e8fa8b773f83df4f63e0f75968bf6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c2796a9f87efa8c0cb25f5d8f8e3458"><td class="memTemplParams" colspan="2">template&lt;class TAAPosVRT &gt; </td></tr>
<tr class="memitem:ga4c2796a9f87efa8c0cb25f5d8f8e3458"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__vertex__util.html#ga4c2796a9f87efa8c0cb25f5d8f8e3458">ug::CalculateBoundaryVertexNormal3D</a> (<a class="el" href="group__vectors.html#ga894cdb8af74f7a563a94fb49c220fdcd">vector3</a> &amp;nOut, <a class="el" href="classug_1_1_grid.html">Grid</a> &amp;grid, <a class="el" href="classug_1_1_vertex.html">Vertex</a> *vrt, TAAPosVRT &amp;aaPos)</td></tr>
<tr class="memdesc:ga4c2796a9f87efa8c0cb25f5d8f8e3458"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculates the normal of a boundary vertex using associated volumes  <a href="group__lib__grid__algorithms__vertex__util.html#ga4c2796a9f87efa8c0cb25f5d8f8e3458">More...</a><br /></td></tr>
<tr class="separator:ga4c2796a9f87efa8c0cb25f5d8f8e3458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga856448e5373202bd158b71e971b9f828"><td class="memTemplParams" colspan="2">template&lt;class TVrtIter , class TAPosition &gt; </td></tr>
<tr class="memitem:ga856448e5373202bd158b71e971b9f828"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__vertex__util.html#ga856448e5373202bd158b71e971b9f828">ug::CalculateBoundingBox</a> (typename TAPosition::ValueType &amp;vMinOut, typename TAPosition::ValueType &amp;vMaxOut, TVrtIter vrtsBegin, TVrtIter vrtsEnd, <a class="el" href="classug_1_1_grid_1_1_attachment_accessor.html">Grid::AttachmentAccessor</a>&lt; <a class="el" href="classug_1_1_vertex.html">Vertex</a>, TAPosition &gt; &amp;aaPos)</td></tr>
<tr class="memdesc:ga856448e5373202bd158b71e971b9f828"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculates the BoundingBox  <a href="group__lib__grid__algorithms__vertex__util.html#ga856448e5373202bd158b71e971b9f828">More...</a><br /></td></tr>
<tr class="separator:ga856448e5373202bd158b71e971b9f828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadda169fdb0ab16b68097d933c642c613"><td class="memTemplParams" colspan="2">template&lt;class TVrtIter , class TAPosition &gt; </td></tr>
<tr class="memitem:gadda169fdb0ab16b68097d933c642c613"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> TAPosition::ValueType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__vertex__util.html#gadda169fdb0ab16b68097d933c642c613">ug::CalculateCenter</a> (TVrtIter vrtsBegin, TVrtIter vrtsEnd, <a class="el" href="classug_1_1_grid_1_1_attachment_accessor.html">Grid::AttachmentAccessor</a>&lt; <a class="el" href="classug_1_1_vertex.html">Vertex</a>, TAPosition &gt; &amp;aaPos)</td></tr>
<tr class="memdesc:gadda169fdb0ab16b68097d933c642c613"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculates the center of a set of vertices.  <a href="group__lib__grid__algorithms__vertex__util.html#gadda169fdb0ab16b68097d933c642c613">More...</a><br /></td></tr>
<tr class="separator:gadda169fdb0ab16b68097d933c642c613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c98c2d1d058d59c32717dd75d97055c"><td class="memTemplParams" colspan="2">template&lt;class TAAPosVRT &gt; </td></tr>
<tr class="memitem:ga8c98c2d1d058d59c32717dd75d97055c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__vertex__util.html#ga8c98c2d1d058d59c32717dd75d97055c">ug::CalculateVertexNormal</a> (<a class="el" href="group__vectors.html#ga894cdb8af74f7a563a94fb49c220fdcd">vector3</a> &amp;nOut, <a class="el" href="classug_1_1_grid.html">Grid</a> &amp;grid, <a class="el" href="classug_1_1_vertex.html">Vertex</a> *vrt, TAAPosVRT &amp;aaPos)</td></tr>
<tr class="memdesc:ga8c98c2d1d058d59c32717dd75d97055c"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculates the normal of a vertex using associated faces  <a href="group__lib__grid__algorithms__vertex__util.html#ga8c98c2d1d058d59c32717dd75d97055c">More...</a><br /></td></tr>
<tr class="separator:ga8c98c2d1d058d59c32717dd75d97055c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5221e89301cf0272f1a19cfe2ba9bab3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__vertex__util.html#ga5221e89301cf0272f1a19cfe2ba9bab3">ug::CollectSurfaceNeighborsSorted</a> (std::vector&lt; <a class="el" href="classug_1_1_vertex.html">Vertex</a> * &gt; &amp;vNeighborsOut, <a class="el" href="classug_1_1_grid.html">Grid</a> &amp;grid, <a class="el" href="classug_1_1_vertex.html">Vertex</a> *v)</td></tr>
<tr class="memdesc:ga5221e89301cf0272f1a19cfe2ba9bab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects neighbor-vertices in either clockwise or counter clockwise order.  <a href="group__lib__grid__algorithms__vertex__util.html#ga5221e89301cf0272f1a19cfe2ba9bab3">More...</a><br /></td></tr>
<tr class="separator:ga5221e89301cf0272f1a19cfe2ba9bab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70e52bc98786dfb349944e4aea1a4b93"><td class="memTemplParams" colspan="2">template&lt;class TVrtContainer1 , class TVrtContainer2 &gt; </td></tr>
<tr class="memitem:ga70e52bc98786dfb349944e4aea1a4b93"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__vertex__util.html#ga70e52bc98786dfb349944e4aea1a4b93">ug::CompareVertexContainer</a> (const TVrtContainer1 &amp;con1, const TVrtContainer2 &amp;con2)</td></tr>
<tr class="memdesc:ga70e52bc98786dfb349944e4aea1a4b93"><td class="mdescLeft">&#160;</td><td class="mdescRight">compares vertices in a container  <a href="group__lib__grid__algorithms__vertex__util.html#ga70e52bc98786dfb349944e4aea1a4b93">More...</a><br /></td></tr>
<tr class="separator:ga70e52bc98786dfb349944e4aea1a4b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6714b9ccee3ac300ae8bb4493ede02e1"><td class="memTemplParams" colspan="2">template&lt;class vector_t , class TAAPos &gt; </td></tr>
<tr class="memitem:ga6714b9ccee3ac300ae8bb4493ede02e1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__vertex__util.html#ga6714b9ccee3ac300ae8bb4493ede02e1">ug::ContainsPoint</a> (const <a class="el" href="classug_1_1_vertex.html">Vertex</a> *v, const vector_t &amp;<a class="elRef" href="../plugins/_biogas_8lua.html#a57f1028d958bb73c4e3c64e2077342fc">p</a>, TAAPos aaPos)</td></tr>
<tr class="memdesc:ga6714b9ccee3ac300ae8bb4493ede02e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given point lies on the given vertex.  <a href="group__lib__grid__algorithms__vertex__util.html#ga6714b9ccee3ac300ae8bb4493ede02e1">More...</a><br /></td></tr>
<tr class="separator:ga6714b9ccee3ac300ae8bb4493ede02e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefad3008d43f5a281ec1d7d5dca78cc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classug_1_1_vertex.html">Vertex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__vertex__util.html#gaefad3008d43f5a281ec1d7d5dca78cc0">ug::FindVertexByCoordiante</a> (<a class="el" href="group__vectors.html#ga894cdb8af74f7a563a94fb49c220fdcd">vector3</a> &amp;coord, <a class="el" href="namespaceug.html#a1903407556f1e2b80c006ae920ea8e0e">VertexIterator</a> iterBegin, <a class="el" href="namespaceug.html#a1903407556f1e2b80c006ae920ea8e0e">VertexIterator</a> iterEnd, <a class="el" href="classug_1_1_grid_1_1_vertex_attachment_accessor.html">Grid::VertexAttachmentAccessor</a>&lt; <a class="el" href="namespaceug.html#a780dd3524b97269f891365fd3c3b895a">APosition</a> &gt; &amp;aaPos)</td></tr>
<tr class="memdesc:gaefad3008d43f5a281ec1d7d5dca78cc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the vertex that is the closest to the given coordinate  <a href="group__lib__grid__algorithms__vertex__util.html#gaefad3008d43f5a281ec1d7d5dca78cc0">More...</a><br /></td></tr>
<tr class="separator:gaefad3008d43f5a281ec1d7d5dca78cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0385a01ac0f134d52a1398e6d826066"><td class="memTemplParams" colspan="2">template&lt;size_t dim&gt; </td></tr>
<tr class="memitem:gad0385a01ac0f134d52a1398e6d826066"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__vertex__util.html#gad0385a01ac0f134d52a1398e6d826066">ug::FindVertexByCoordinate</a> (const <a class="el" href="classug_1_1_math_vector.html">MathVector</a>&lt; <a class="elRef" href="../plugins/group__small__strain__mechanics.html#ga48fe27c9a0dffdcc67e1a84f77f632fc">dim</a> &gt; &amp;coord, size_t ncoords, const <a class="el" href="classug_1_1_math_vector.html">MathVector</a>&lt; <a class="elRef" href="../plugins/group__small__strain__mechanics.html#ga48fe27c9a0dffdcc67e1a84f77f632fc">dim</a> &gt; vCoords[])</td></tr>
<tr class="memdesc:gad0385a01ac0f134d52a1398e6d826066"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns (non-unique?) index of closest vertex  <a href="group__lib__grid__algorithms__vertex__util.html#gad0385a01ac0f134d52a1398e6d826066">More...</a><br /></td></tr>
<tr class="separator:gad0385a01ac0f134d52a1398e6d826066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3462fadc3d0f59d6a4177d60e647a2e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classug_1_1_edge.html">Edge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__vertex__util.html#ga3462fadc3d0f59d6a4177d60e647a2e8">ug::GetConnectedEdge</a> (<a class="el" href="classug_1_1_grid.html">Grid</a> &amp;g, <a class="el" href="classug_1_1_vertex.html">Vertex</a> *vrt, <a class="el" href="classug_1_1_face.html">Face</a> *tri)</td></tr>
<tr class="memdesc:ga3462fadc3d0f59d6a4177d60e647a2e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the edge in the triangle tri, which does not contain vrt.  <a href="group__lib__grid__algorithms__vertex__util.html#ga3462fadc3d0f59d6a4177d60e647a2e8">More...</a><br /></td></tr>
<tr class="separator:ga3462fadc3d0f59d6a4177d60e647a2e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee1128b8bc4a8fed99814b0126b9b454"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classug_1_1_vertex.html">Vertex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__vertex__util.html#gaee1128b8bc4a8fed99814b0126b9b454">ug::GetConnectedVertex</a> (<a class="el" href="classug_1_1_edge.html">Edge</a> *e, <a class="el" href="classug_1_1_vertex.html">Vertex</a> *v)</td></tr>
<tr class="memdesc:gaee1128b8bc4a8fed99814b0126b9b454"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the vertex that is connected to v via e.  <a href="group__lib__grid__algorithms__vertex__util.html#gaee1128b8bc4a8fed99814b0126b9b454">More...</a><br /></td></tr>
<tr class="separator:gaee1128b8bc4a8fed99814b0126b9b454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bae9d4d5288bbf36d46a8546209aca8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classug_1_1_vertex.html">Vertex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__vertex__util.html#ga0bae9d4d5288bbf36d46a8546209aca8">ug::GetConnectedVertex</a> (<a class="el" href="classug_1_1_edge_vertices.html">EdgeVertices</a> *e, <a class="el" href="classug_1_1_face.html">Face</a> *f)</td></tr>
<tr class="memdesc:ga0bae9d4d5288bbf36d46a8546209aca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the index of the first vertex that is contained in f and is not contained in e.  <a href="group__lib__grid__algorithms__vertex__util.html#ga0bae9d4d5288bbf36d46a8546209aca8">More...</a><br /></td></tr>
<tr class="separator:ga0bae9d4d5288bbf36d46a8546209aca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab444e4d5c443af5fabba6b0104c7a87"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__vertex__util.html#gaab444e4d5c443af5fabba6b0104c7a87">ug::GetConnectedVertexIndex</a> (<a class="el" href="classug_1_1_face.html">Face</a> *f, const <a class="el" href="classug_1_1_edge_descriptor.html">EdgeDescriptor</a> &amp;ed)</td></tr>
<tr class="memdesc:gaab444e4d5c443af5fabba6b0104c7a87"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the index of the first vertex that is contained in the specified face and is not contained in the given edge.  <a href="group__lib__grid__algorithms__vertex__util.html#gaab444e4d5c443af5fabba6b0104c7a87">More...</a><br /></td></tr>
<tr class="separator:gaab444e4d5c443af5fabba6b0104c7a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80dfafb1e562579e406b94c6c50ee9b2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__vertex__util.html#ga80dfafb1e562579e406b94c6c50ee9b2">ug::GetConnectedVertexIndex</a> (<a class="el" href="classug_1_1_face.html">Face</a> *f, const <a class="el" href="classug_1_1_edge_vertices.html">EdgeVertices</a> *e)</td></tr>
<tr class="separator:ga80dfafb1e562579e406b94c6c50ee9b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d4ce919a5c578ed819e67058723d332"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classug_1_1_vertex.html">Vertex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__vertex__util.html#ga0d4ce919a5c578ed819e67058723d332">ug::GetSharedVertex</a> (<a class="el" href="classug_1_1_i_vertex_group.html">IVertexGroup</a> *vrts0, <a class="el" href="classug_1_1_i_vertex_group.html">IVertexGroup</a> *vrts1)</td></tr>
<tr class="memdesc:ga0d4ce919a5c578ed819e67058723d332"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the first vertex of vrts0 that is also contained in vrts1 (or NULL if no such vertex exists)  <a href="group__lib__grid__algorithms__vertex__util.html#ga0d4ce919a5c578ed819e67058723d332">More...</a><br /></td></tr>
<tr class="separator:ga0d4ce919a5c578ed819e67058723d332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7dfe766ecd522261dd33e5e8e5a41a1b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__vertex__util.html#ga7dfe766ecd522261dd33e5e8e5a41a1b">ug::GetSharedVertices</a> (std::vector&lt; <a class="el" href="classug_1_1_vertex.html">Vertex</a> * &gt; &amp;vrtsOut, <a class="el" href="classug_1_1_i_vertex_group.html">IVertexGroup</a> *vrts0, <a class="el" href="classug_1_1_i_vertex_group.html">IVertexGroup</a> *vrts1)</td></tr>
<tr class="memdesc:ga7dfe766ecd522261dd33e5e8e5a41a1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">fills a vector with the vertices that are both contained in vrts0 and vrts1.  <a href="group__lib__grid__algorithms__vertex__util.html#ga7dfe766ecd522261dd33e5e8e5a41a1b">More...</a><br /></td></tr>
<tr class="separator:ga7dfe766ecd522261dd33e5e8e5a41a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc46f829211dc8ddd5cff1001178f765"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classug_1_1_vertex.html">Vertex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__vertex__util.html#gafc46f829211dc8ddd5cff1001178f765">ug::GetVertex</a> (<a class="el" href="classug_1_1_vertex.html">Vertex</a> *v, size_t i)</td></tr>
<tr class="memdesc:gafc46f829211dc8ddd5cff1001178f765"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the i'th vertex of a vertex  <a href="group__lib__grid__algorithms__vertex__util.html#gafc46f829211dc8ddd5cff1001178f765">More...</a><br /></td></tr>
<tr class="separator:gafc46f829211dc8ddd5cff1001178f765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf616966d82226b6c9af1b072d2e482c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__vertex__util.html#gaaf616966d82226b6c9af1b072d2e482c">ug::GetVertexIndex</a> (<a class="el" href="classug_1_1_edge_vertices.html">EdgeVertices</a> *e, <a class="el" href="classug_1_1_vertex.html">Vertex</a> *v)</td></tr>
<tr class="memdesc:gaaf616966d82226b6c9af1b072d2e482c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the index at which vertex v is found in the given edge  <a href="group__lib__grid__algorithms__vertex__util.html#gaaf616966d82226b6c9af1b072d2e482c">More...</a><br /></td></tr>
<tr class="separator:gaaf616966d82226b6c9af1b072d2e482c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48792c2aba7f3a2a37275b90b9ac8b9d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__vertex__util.html#ga48792c2aba7f3a2a37275b90b9ac8b9d">ug::GetVertexIndex</a> (<a class="el" href="classug_1_1_face_vertices.html">FaceVertices</a> *f, <a class="el" href="classug_1_1_vertex.html">Vertex</a> *v)</td></tr>
<tr class="memdesc:ga48792c2aba7f3a2a37275b90b9ac8b9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the index at which vertex v is found in the given face  <a href="group__lib__grid__algorithms__vertex__util.html#ga48792c2aba7f3a2a37275b90b9ac8b9d">More...</a><br /></td></tr>
<tr class="separator:ga48792c2aba7f3a2a37275b90b9ac8b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5151cea6aa053c8932b2977d99272a4d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__vertex__util.html#ga5151cea6aa053c8932b2977d99272a4d">ug::GetVertexIndex</a> (<a class="el" href="classug_1_1_volume_vertices.html">VolumeVertices</a> *vol, <a class="el" href="classug_1_1_vertex.html">Vertex</a> *v)</td></tr>
<tr class="memdesc:ga5151cea6aa053c8932b2977d99272a4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the index at which vertex v is found in the given volume  <a href="group__lib__grid__algorithms__vertex__util.html#ga5151cea6aa053c8932b2977d99272a4d">More...</a><br /></td></tr>
<tr class="separator:ga5151cea6aa053c8932b2977d99272a4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga278ac166fa59ab8608bee3e4a7b5c1fa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__vertex__util.html#ga278ac166fa59ab8608bee3e4a7b5c1fa">ug::IsBoundaryVertex1D</a> (<a class="el" href="classug_1_1_grid.html">Grid</a> &amp;grid, <a class="el" href="classug_1_1_vertex.html">Vertex</a> *v, <a class="el" href="structug_1_1_grid_1_1traits.html#a1bd114991c12becc6ca48862967dd9f2">Grid::edge_traits::callback</a> cbConsiderEdge=<a class="el" href="classug_1_1_consider_all.html">ConsiderAll</a>())</td></tr>
<tr class="memdesc:ga278ac166fa59ab8608bee3e4a7b5c1fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns whether a vertex lies on the boundary of a polygonal chain.  <a href="group__lib__grid__algorithms__vertex__util.html#ga278ac166fa59ab8608bee3e4a7b5c1fa">More...</a><br /></td></tr>
<tr class="separator:ga278ac166fa59ab8608bee3e4a7b5c1fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2027583d2c14c0b7ac9379df4c988ccf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__vertex__util.html#ga2027583d2c14c0b7ac9379df4c988ccf">ug::IsBoundaryVertex2D</a> (<a class="el" href="classug_1_1_grid.html">Grid</a> &amp;grid, <a class="el" href="classug_1_1_vertex.html">Vertex</a> *v)</td></tr>
<tr class="memdesc:ga2027583d2c14c0b7ac9379df4c988ccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns whether a vertex lies on the boundary of a 2D grid.  <a href="group__lib__grid__algorithms__vertex__util.html#ga2027583d2c14c0b7ac9379df4c988ccf">More...</a><br /></td></tr>
<tr class="separator:ga2027583d2c14c0b7ac9379df4c988ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e2bc9e8f5f8133db8ac2939f6ba178b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__vertex__util.html#ga7e2bc9e8f5f8133db8ac2939f6ba178b">ug::IsBoundaryVertex3D</a> (<a class="el" href="classug_1_1_grid.html">Grid</a> &amp;grid, <a class="el" href="classug_1_1_vertex.html">Vertex</a> *v)</td></tr>
<tr class="memdesc:ga7e2bc9e8f5f8133db8ac2939f6ba178b"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if a vertex lies on the boundary of a 3D grid.  <a href="group__lib__grid__algorithms__vertex__util.html#ga7e2bc9e8f5f8133db8ac2939f6ba178b">More...</a><br /></td></tr>
<tr class="separator:ga7e2bc9e8f5f8133db8ac2939f6ba178b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cbefc9fc997763a231d0f910376d3c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__vertex__util.html#ga0cbefc9fc997763a231d0f910376d3c1">ug::IsRegularSurfaceVertex</a> (<a class="el" href="classug_1_1_grid.html">Grid</a> &amp;grid, <a class="el" href="classug_1_1_vertex.html">Vertex</a> *v)</td></tr>
<tr class="memdesc:ga0cbefc9fc997763a231d0f910376d3c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if the vertex lies inside a regular surface  <a href="group__lib__grid__algorithms__vertex__util.html#ga0cbefc9fc997763a231d0f910376d3c1">More...</a><br /></td></tr>
<tr class="separator:ga0cbefc9fc997763a231d0f910376d3c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga968ae16e440ac72e9fb2760ef15cc28b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__vertex__util.html#ga968ae16e440ac72e9fb2760ef15cc28b">ug::LiesOnBoundary</a> (<a class="el" href="classug_1_1_grid.html">Grid</a> &amp;grid, <a class="el" href="classug_1_1_vertex.html">Vertex</a> *v)</td></tr>
<tr class="memdesc:ga968ae16e440ac72e9fb2760ef15cc28b"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true, if the vertex lies on a 1d, 2d or 3d boundary  <a href="group__lib__grid__algorithms__vertex__util.html#ga968ae16e440ac72e9fb2760ef15cc28b">More...</a><br /></td></tr>
<tr class="separator:ga968ae16e440ac72e9fb2760ef15cc28b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf44b3bf9a26a6ad362eae2e1b6345a3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__vertex__util.html#gaf44b3bf9a26a6ad362eae2e1b6345a3f">ug::MarkFixedCreaseVertices</a> (<a class="el" href="classug_1_1_grid.html">Grid</a> &amp;grid, <a class="el" href="namespaceug.html#a4077697589380822c2f46b597f550f4b">SubsetHandler</a> &amp;sh, int creaseSI, int fixedSI)</td></tr>
<tr class="separator:gaf44b3bf9a26a6ad362eae2e1b6345a3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga526c91d80e4f634cac8d617a52199afa"><td class="memTemplParams" colspan="2">template&lt;class TVrtIterator &gt; </td></tr>
<tr class="memitem:ga526c91d80e4f634cac8d617a52199afa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> <a class="el" href="classug_1_1_vertex.html">Vertex</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__vertex__util.html#ga526c91d80e4f634cac8d617a52199afa">ug::MergeMultipleVertices</a> (<a class="el" href="classug_1_1_grid.html">Grid</a> &amp;grid, TVrtIterator vrtsBegin, TVrtIterator vrtsEnd)</td></tr>
<tr class="memdesc:ga526c91d80e4f634cac8d617a52199afa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges all vertices between the given iterators into a single vertex.  <a href="group__lib__grid__algorithms__vertex__util.html#ga526c91d80e4f634cac8d617a52199afa">More...</a><br /></td></tr>
<tr class="separator:ga526c91d80e4f634cac8d617a52199afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga756bb139ffc1dd1ef5725086d83f2522"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__vertex__util.html#ga756bb139ffc1dd1ef5725086d83f2522">ug::MergeVertices</a> (<a class="el" href="classug_1_1_grid.html">Grid</a> &amp;grid, <a class="el" href="classug_1_1_vertex.html">Vertex</a> *v1, <a class="el" href="classug_1_1_vertex.html">Vertex</a> *v2)</td></tr>
<tr class="memdesc:ga756bb139ffc1dd1ef5725086d83f2522"><td class="mdescLeft">&#160;</td><td class="mdescRight">merges two vertices and restructures the adjacent elements.  <a href="group__lib__grid__algorithms__vertex__util.html#ga756bb139ffc1dd1ef5725086d83f2522">More...</a><br /></td></tr>
<tr class="separator:ga756bb139ffc1dd1ef5725086d83f2522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56cb44dd0a306072b484b980e6949468"><td class="memTemplParams" colspan="2">template&lt;class TIterator , class TAAPos &gt; </td></tr>
<tr class="memitem:ga56cb44dd0a306072b484b980e6949468"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__vertex__util.html#ga56cb44dd0a306072b484b980e6949468">ug::MoveVertices</a> (TIterator vrtsBegin, TIterator vrtsEnd, TAAPos aaPos, const typename TAAPos::ValueType &amp;offset)</td></tr>
<tr class="memdesc:ga56cb44dd0a306072b484b980e6949468"><td class="mdescLeft">&#160;</td><td class="mdescRight">moves vertices by the specified offset  <a href="group__lib__grid__algorithms__vertex__util.html#ga56cb44dd0a306072b484b980e6949468">More...</a><br /></td></tr>
<tr class="separator:ga56cb44dd0a306072b484b980e6949468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga307a8879682aad14b24df172ada00342"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__vertex__util.html#ga307a8879682aad14b24df172ada00342">ug::NumAssociatedEdges</a> (<a class="el" href="classug_1_1_grid.html">Grid</a> &amp;grid, <a class="el" href="classug_1_1_vertex.html">Vertex</a> *v)</td></tr>
<tr class="memdesc:ga307a8879682aad14b24df172ada00342"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the number of associated edges of the given vertex  <a href="group__lib__grid__algorithms__vertex__util.html#ga307a8879682aad14b24df172ada00342">More...</a><br /></td></tr>
<tr class="separator:ga307a8879682aad14b24df172ada00342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a826eba40e1813aa2f6866d59ed1926"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__vertex__util.html#ga3a826eba40e1813aa2f6866d59ed1926">ug::NumAssociatedFaces</a> (<a class="el" href="classug_1_1_grid.html">Grid</a> &amp;grid, <a class="el" href="classug_1_1_vertex.html">Vertex</a> *v)</td></tr>
<tr class="memdesc:ga3a826eba40e1813aa2f6866d59ed1926"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the number of associated faces of the given vertex  <a href="group__lib__grid__algorithms__vertex__util.html#ga3a826eba40e1813aa2f6866d59ed1926">More...</a><br /></td></tr>
<tr class="separator:ga3a826eba40e1813aa2f6866d59ed1926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b31afe8e8a41c95568826dfbfd0dd7a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__vertex__util.html#ga4b31afe8e8a41c95568826dfbfd0dd7a">ug::NumSharedVertices</a> (<a class="el" href="classug_1_1_i_vertex_group.html">IVertexGroup</a> *vrts0, <a class="el" href="classug_1_1_i_vertex_group.html">IVertexGroup</a> *vrts1)</td></tr>
<tr class="memdesc:ga4b31afe8e8a41c95568826dfbfd0dd7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of shared vertices between vrts0 and vrts1.  <a href="group__lib__grid__algorithms__vertex__util.html#ga4b31afe8e8a41c95568826dfbfd0dd7a">More...</a><br /></td></tr>
<tr class="separator:ga4b31afe8e8a41c95568826dfbfd0dd7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e891587ff8d12dede467105f3294e2e"><td class="memTemplParams" colspan="2">template&lt;class TAAPos &gt; </td></tr>
<tr class="memitem:ga9e891587ff8d12dede467105f3294e2e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__vertex__util.html#ga9e891587ff8d12dede467105f3294e2e">ug::TransformVertex</a> (<a class="el" href="classug_1_1_vertex.html">Vertex</a> *vrt, <a class="el" href="group__vectors.html#ga9dccf0b544ad1d673c172407ab8b2c4b">matrix33</a> &amp;m, TAAPos &amp;aaPos)</td></tr>
<tr class="memdesc:ga9e891587ff8d12dede467105f3294e2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">transforms a vertex by a given matrix  <a href="group__lib__grid__algorithms__vertex__util.html#ga9e891587ff8d12dede467105f3294e2e">More...</a><br /></td></tr>
<tr class="separator:ga9e891587ff8d12dede467105f3294e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bdf1d3beee9cc3540cdff32c428351d"><td class="memTemplParams" colspan="2">template&lt;class TIterator , class TAAPos &gt; </td></tr>
<tr class="memitem:ga0bdf1d3beee9cc3540cdff32c428351d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__vertex__util.html#ga0bdf1d3beee9cc3540cdff32c428351d">ug::TransformVertices</a> (TIterator vrtsBegin, TIterator vrtsEnd, <a class="el" href="group__vectors.html#ga9dccf0b544ad1d673c172407ab8b2c4b">matrix33</a> &amp;m, TAAPos &amp;aaPos)</td></tr>
<tr class="memdesc:ga0bdf1d3beee9cc3540cdff32c428351d"><td class="mdescLeft">&#160;</td><td class="mdescRight">transforms all given vertices by a given matrix  <a href="group__lib__grid__algorithms__vertex__util.html#ga0bdf1d3beee9cc3540cdff32c428351d">More...</a><br /></td></tr>
<tr class="separator:ga0bdf1d3beee9cc3540cdff32c428351d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f9cc2f74e43cf36c68b59a51b7184d4"><td class="memTemplParams" colspan="2">template&lt;class TAAPos &gt; </td></tr>
<tr class="memitem:ga0f9cc2f74e43cf36c68b59a51b7184d4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> <a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__vertex__util.html#ga0f9cc2f74e43cf36c68b59a51b7184d4">ug::VertexDistance</a> (<a class="el" href="classug_1_1_vertex.html">Vertex</a> *v0, <a class="el" href="classug_1_1_vertex.html">Vertex</a> *v1, TAAPos &amp;aaPos)</td></tr>
<tr class="memdesc:ga0f9cc2f74e43cf36c68b59a51b7184d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the distance between two vertices.  <a href="group__lib__grid__algorithms__vertex__util.html#ga0f9cc2f74e43cf36c68b59a51b7184d4">More...</a><br /></td></tr>
<tr class="separator:ga0f9cc2f74e43cf36c68b59a51b7184d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7c796988775ad24fd15c24087d8a81e"><td class="memTemplParams" colspan="2">template&lt;class TAAPos &gt; </td></tr>
<tr class="memitem:gab7c796988775ad24fd15c24087d8a81e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> <a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__vertex__util.html#gab7c796988775ad24fd15c24087d8a81e">ug::VertexDistanceSq</a> (<a class="el" href="classug_1_1_vertex.html">Vertex</a> *v0, <a class="el" href="classug_1_1_vertex.html">Vertex</a> *v1, TAAPos &amp;aaPos)</td></tr>
<tr class="memdesc:gab7c796988775ad24fd15c24087d8a81e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the squared distance between two vertices.  <a href="group__lib__grid__algorithms__vertex__util.html#gab7c796988775ad24fd15c24087d8a81e">More...</a><br /></td></tr>
<tr class="separator:gab7c796988775ad24fd15c24087d8a81e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95754779ac568465423ab030b6421c7f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__vertex__util.html#ga95754779ac568465423ab030b6421c7f">ug::CalculateVertexNormals</a> (<a class="el" href="classug_1_1_grid.html">Grid</a> &amp;grid, <a class="el" href="namespaceug.html#a780dd3524b97269f891365fd3c3b895a">APosition</a> &amp;aPos, <a class="el" href="namespaceug.html#a971c52fec411990d2bfb6ee27dbb0232">ANormal</a> &amp;aNorm)</td></tr>
<tr class="memdesc:ga95754779ac568465423ab030b6421c7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculates the normals of all vertices in grid and stores them in aNorm.  <a href="group__lib__grid__algorithms__vertex__util.html#ga95754779ac568465423ab030b6421c7f">More...</a><br /></td></tr>
<tr class="separator:ga95754779ac568465423ab030b6421c7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe72050ecf543aeda3950e6bd039e402"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__vertex__util.html#gabe72050ecf543aeda3950e6bd039e402">ug::CalculateVertexNormals</a> (<a class="el" href="classug_1_1_grid.html">Grid</a> &amp;grid, <a class="el" href="classug_1_1_grid_1_1_attachment_accessor.html">Grid::AttachmentAccessor</a>&lt; <a class="el" href="classug_1_1_vertex.html">Vertex</a>, <a class="el" href="namespaceug.html#a780dd3524b97269f891365fd3c3b895a">APosition</a> &gt; &amp;aaPos, <a class="el" href="classug_1_1_grid_1_1_attachment_accessor.html">Grid::AttachmentAccessor</a>&lt; <a class="el" href="classug_1_1_vertex.html">Vertex</a>, <a class="el" href="namespaceug.html#a971c52fec411990d2bfb6ee27dbb0232">ANormal</a> &gt; &amp;aaNorm)</td></tr>
<tr class="memdesc:gabe72050ecf543aeda3950e6bd039e402"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculates the normals of all vertices in grid and stores them in aNorm.  <a href="group__lib__grid__algorithms__vertex__util.html#gabe72050ecf543aeda3950e6bd039e402">More...</a><br /></td></tr>
<tr class="separator:gabe72050ecf543aeda3950e6bd039e402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ef4b61a6c2f18a940efa1cf74d7e47d"><td class="memTemplParams" colspan="2">template&lt;int dim, class TVrtIterator &gt; </td></tr>
<tr class="memitem:ga0ef4b61a6c2f18a940efa1cf74d7e47d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__vertex__util.html#ga0ef4b61a6c2f18a940efa1cf74d7e47d">ug::RemoveDoubles</a> (<a class="el" href="classug_1_1_grid.html">Grid</a> &amp;grid, const TVrtIterator &amp;iterBegin, const TVrtIterator &amp;iterEnd, <a class="el" href="classug_1_1_attachment.html">Attachment</a>&lt; <a class="el" href="classug_1_1_math_vector.html">MathVector</a>&lt; <a class="elRef" href="../plugins/group__small__strain__mechanics.html#ga48fe27c9a0dffdcc67e1a84f77f632fc">dim</a> &gt; &gt; &amp;aPos, <a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a> threshold)</td></tr>
<tr class="memdesc:ga0ef4b61a6c2f18a940efa1cf74d7e47d"><td class="mdescLeft">&#160;</td><td class="mdescRight">merges all vertices that are closer to each other than the specified threshold.  <a href="group__lib__grid__algorithms__vertex__util.html#ga0ef4b61a6c2f18a940efa1cf74d7e47d">More...</a><br /></td></tr>
<tr class="separator:ga0ef4b61a6c2f18a940efa1cf74d7e47d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3624945d6c779bbfb5d470d874016da9"><td class="memTemplParams" colspan="2">template&lt;int dim, class TVrtIterator , class TAAPos &gt; </td></tr>
<tr class="memitem:ga3624945d6c779bbfb5d470d874016da9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__vertex__util.html#ga3624945d6c779bbfb5d470d874016da9">ug::RemoveDoubles</a> (<a class="el" href="classug_1_1_grid.html">Grid</a> &amp;grid, const TVrtIterator &amp;iterBegin, const TVrtIterator &amp;iterEnd, TAAPos aaPos, <a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a> threshold)</td></tr>
<tr class="memdesc:ga3624945d6c779bbfb5d470d874016da9"><td class="mdescLeft">&#160;</td><td class="mdescRight">merges all vertices that are closer to each other than the specified threshold.  <a href="group__lib__grid__algorithms__vertex__util.html#ga3624945d6c779bbfb5d470d874016da9">More...</a><br /></td></tr>
<tr class="separator:ga3624945d6c779bbfb5d470d874016da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d62206577ce50c9346088054bfc08c7"><td class="memTemplParams" colspan="2">template&lt;class TVertexPositionAttachmentAccessor &gt; </td></tr>
<tr class="memitem:ga7d62206577ce50c9346088054bfc08c7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> TVertexPositionAttachmentAccessor::ValueType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__vertex__util.html#ga7d62206577ce50c9346088054bfc08c7">ug::CalculateCenter</a> (const <a class="el" href="classug_1_1_vertex.html">Vertex</a> *v, TVertexPositionAttachmentAccessor &amp;aaPosVRT)</td></tr>
<tr class="memdesc:ga7d62206577ce50c9346088054bfc08c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the position of the vertex.  <a href="group__lib__grid__algorithms__vertex__util.html#ga7d62206577ce50c9346088054bfc08c7">More...</a><br /></td></tr>
<tr class="separator:ga7d62206577ce50c9346088054bfc08c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59dc50db7fd4e667691d61da0b2f5267"><td class="memTemplParams" colspan="2">template&lt;class TAAPosVRT , class TAAWeightVRT &gt; </td></tr>
<tr class="memitem:ga59dc50db7fd4e667691d61da0b2f5267"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> TAAPosVRT::ValueType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__vertex__util.html#ga59dc50db7fd4e667691d61da0b2f5267">ug::CalculateCenter</a> (const <a class="el" href="classug_1_1_vertex.html">Vertex</a> *v, TAAPosVRT &amp;aaPos, TAAWeightVRT &amp;aaWeight)</td></tr>
<tr class="memdesc:ga59dc50db7fd4e667691d61da0b2f5267"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the position of the vertex.  <a href="group__lib__grid__algorithms__vertex__util.html#ga59dc50db7fd4e667691d61da0b2f5267">More...</a><br /></td></tr>
<tr class="separator:ga59dc50db7fd4e667691d61da0b2f5267"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>contains methods to manipulate vertices </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaafbc69674722a7e02b72c6017321f07c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaafbc69674722a7e02b72c6017321f07c">&#9670;&nbsp;</a></span>CalculateBarycenter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TVrtIter , class TAPosition &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> TAPosition::ValueType ug::CalculateBarycenter </td>
          <td>(</td>
          <td class="paramtype">TVrtIter&#160;</td>
          <td class="paramname"><em>vrtsBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TVrtIter&#160;</td>
          <td class="paramname"><em>vrtsEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid_1_1_vertex_attachment_accessor.html">Grid::VertexAttachmentAccessor</a>&lt; TAPosition &gt; &amp;&#160;</td>
          <td class="paramname"><em>aaPos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculates the barycenter of a set of vertices </p>

<p class="reference">References <a class="el" href="group__vectors.html#ga945c247d94409091fd35fdbbcb5032c2">ug::VecAdd()</a>, <a class="el" href="group__vectors.html#gaa0cd3e6bb61c8e341541f8cf3065ec6d">ug::VecScale()</a>, and <a class="el" href="group__vectors.html#ga37c542a5b243f331a1d8bb74d331ba4e">ug::VecSet()</a>.</p>

</div>
</div>
<a id="gae5e8fa8b773f83df4f63e0f75968bf6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5e8fa8b773f83df4f63e0f75968bf6f">&#9670;&nbsp;</a></span>CalculateBoundaryVertexNormal2D()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TAAPosVRT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> void ug::CalculateBoundaryVertexNormal2D </td>
          <td>(</td>
          <td class="paramtype">typename TAAPosVRT::ValueType &amp;&#160;</td>
          <td class="paramname"><em>nOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid.html">Grid</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>vrt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TAAPosVRT &amp;&#160;</td>
          <td class="paramname"><em>aaPos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculates the normal of a boundary vertex using associated faces </p>
<p>TAAPosVRT has to be an attachment accessor for the vector2 or vector3 type that works on the vertices in grid.</p>
<p>Note that this method makes only sense if called for a boundary vertex, which is connected to some volume elements.</p>
<p>The returned normal is normalized and will point outwards of the area defined by the associated volumes.</p>
<p>Note that this method assumes, that all faces do lie in the x-y-plane. </p>

<p class="reference">References <a class="el" href="group__lib__grid__algorithms__neighborhood__util.html#gaf82709887c879e120297650ef61c14ce">ug::CollectAssociated()</a>, <a class="el" href="classug_1_1_face.html#a58d3b73e59ed266bdb6558c759ec0d51">ug::Face::edge_desc()</a>, <a class="el" href="group__lib__grid__algorithms__edge__util.html#ga0cce38c830ab3f7e4257d0e62f690868">ug::EdgeContains()</a>, <a class="el" href="classug_1_1_grid.html#a631569f60d18f00177e8cf24e5b3e3ff">ug::Grid::get_edge()</a>, <a class="el" href="group__lib__grid__algorithms__edge__util.html#ga5bf1afd38411b7139354752323bbd9d4">ug::IsBoundaryEdge2D()</a>, <a class="el" href="classug_1_1_face.html#abeecffdd8770d3a32117739c415b5241">ug::Face::num_sides()</a>, <a class="el" href="group__vectors.html#ga53ae2dda87330ab64fb2a5901606b3e4">ug::VecNormalize()</a>, <a class="el" href="group__vectors.html#ga37c542a5b243f331a1d8bb74d331ba4e">ug::VecSet()</a>, and <a class="el" href="classug_1_1_edge_vertices.html#a0f2ec2644877a1354489544f43c71206">ug::EdgeVertices::vertex()</a>.</p>

<p class="reference">Referenced by <a class="el" href="namespaceug.html#a5910504e9f899018d8b7ff00b247bdba">ug::ExpandFractures2d()</a>.</p>

</div>
</div>
<a id="ga4c2796a9f87efa8c0cb25f5d8f8e3458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c2796a9f87efa8c0cb25f5d8f8e3458">&#9670;&nbsp;</a></span>CalculateBoundaryVertexNormal3D()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TAAPosVRT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> void ug::CalculateBoundaryVertexNormal3D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__vectors.html#ga894cdb8af74f7a563a94fb49c220fdcd">vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>nOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid.html">Grid</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>vrt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TAAPosVRT &amp;&#160;</td>
          <td class="paramname"><em>aaPos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculates the normal of a boundary vertex using associated volumes </p>
<p>TAAPosVRT has to be an attachment accessor for the vector3 type that works on the vertices in grid.</p>
<p>Note that this method makes only sense if called for a boundary vertex, which is connected to some volume elements.</p>
<p>The returned normal is normalized and will point outwards of the area defined by the associated volumes. </p>

<p class="reference">References <a class="el" href="group__lib__grid__algorithms__edge__util.html#ga47d8d9dc1634d72a7500de9fe2e1f7a3">ug::CalculateNormal()</a>, <a class="el" href="group__lib__grid__algorithms__neighborhood__util.html#gaf82709887c879e120297650ef61c14ce">ug::CollectAssociated()</a>, <a class="el" href="classug_1_1_volume.html#a2cc6c78635a58f178b7e9a48255df5a0">ug::Volume::face_desc()</a>, <a class="el" href="group__lib__grid__algorithms__face__util.html#ga749cd2682d933d3923aed6387b564d4d">ug::FaceContains()</a>, <a class="el" href="classug_1_1_grid.html#a6970549d629877a26e896ed00f309210">ug::Grid::get_face()</a>, <a class="el" href="group__lib__grid__algorithms__face__util.html#ga13333d7cf4577f562d1a92d1b3fc4c5e">ug::IsBoundaryFace3D()</a>, <a class="el" href="classug_1_1_volume.html#ade9c76e7ace8fab2b63de266f89380aa">ug::Volume::num_sides()</a>, <a class="el" href="group__vectors.html#ga945c247d94409091fd35fdbbcb5032c2">ug::VecAdd()</a>, <a class="el" href="group__vectors.html#ga53ae2dda87330ab64fb2a5901606b3e4">ug::VecNormalize()</a>, and <a class="el" href="group__vectors.html#ga37c542a5b243f331a1d8bb74d331ba4e">ug::VecSet()</a>.</p>

<p class="reference">Referenced by <a class="el" href="namespaceug.html#a7590b56787a7aac08577dddeaf9c9cc1">ug::ExpandFractures3d()</a>.</p>

</div>
</div>
<a id="ga856448e5373202bd158b71e971b9f828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga856448e5373202bd158b71e971b9f828">&#9670;&nbsp;</a></span>CalculateBoundingBox()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TVrtIter , class TAPosition &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> void ug::CalculateBoundingBox </td>
          <td>(</td>
          <td class="paramtype">typename TAPosition::ValueType &amp;&#160;</td>
          <td class="paramname"><em>vMinOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename TAPosition::ValueType &amp;&#160;</td>
          <td class="paramname"><em>vMaxOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TVrtIter&#160;</td>
          <td class="paramname"><em>vrtsBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TVrtIter&#160;</td>
          <td class="paramname"><em>vrtsEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid_1_1_attachment_accessor.html">Grid::AttachmentAccessor</a>&lt; <a class="el" href="classug_1_1_vertex.html">Vertex</a>, TAPosition &gt; &amp;&#160;</td>
          <td class="paramname"><em>aaPos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculates the BoundingBox </p>

<p class="reference">References <a class="elRef" href="../plugins/group__small__strain__mechanics.html#ga425548c7b0fe054612f37d1f3a4826b6">dim</a>.</p>

</div>
</div>
<a id="ga59dc50db7fd4e667691d61da0b2f5267"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59dc50db7fd4e667691d61da0b2f5267">&#9670;&nbsp;</a></span>CalculateCenter() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TAAPosVRT , class TAAWeightVRT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> TAAPosVRT::ValueType ug::CalculateCenter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classug_1_1_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TAAPosVRT &amp;&#160;</td>
          <td class="paramname"><em>aaPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TAAWeightVRT &amp;&#160;</td>
          <td class="paramname"><em>aaWeight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the position of the vertex. </p>
<p>Main purpose is to allow the use of vertices in template-methods that call CalculateCenter </p>

</div>
</div>
<a id="ga7d62206577ce50c9346088054bfc08c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d62206577ce50c9346088054bfc08c7">&#9670;&nbsp;</a></span>CalculateCenter() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TVertexPositionAttachmentAccessor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> TVertexPositionAttachmentAccessor::ValueType ug::CalculateCenter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classug_1_1_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TVertexPositionAttachmentAccessor &amp;&#160;</td>
          <td class="paramname"><em>aaPosVRT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the position of the vertex. </p>
<p>Main purpose is to allow the use of vertices in template-methods that call CalculateCenter </p>

</div>
</div>
<a id="gadda169fdb0ab16b68097d933c642c613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadda169fdb0ab16b68097d933c642c613">&#9670;&nbsp;</a></span>CalculateCenter() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TVrtIter , class TAPosition &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> TAPosition::ValueType ug::CalculateCenter </td>
          <td>(</td>
          <td class="paramtype">TVrtIter&#160;</td>
          <td class="paramname"><em>vrtsBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TVrtIter&#160;</td>
          <td class="paramname"><em>vrtsEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid_1_1_attachment_accessor.html">Grid::AttachmentAccessor</a>&lt; <a class="el" href="classug_1_1_vertex.html">Vertex</a>, TAPosition &gt; &amp;&#160;</td>
          <td class="paramname"><em>aaPos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculates the center of a set of vertices. </p>
<p>The difference to CalculateBarycenter is that this method returns the center of the bounding box which contains the given set of vertices. </p>

<p class="reference">References <a class="el" href="namespaceug.html#a6e489824436f472c8264ba6cb4e1e2e9">ug::CalculateBoundingBox()</a>, and <a class="el" href="group__vectors.html#ga385f702a22b3b6236e783b2bc014f87f">ug::VecScaleAdd()</a>.</p>

</div>
</div>
<a id="ga8c98c2d1d058d59c32717dd75d97055c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c98c2d1d058d59c32717dd75d97055c">&#9670;&nbsp;</a></span>CalculateVertexNormal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TAAPosVRT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> void ug::CalculateVertexNormal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__vectors.html#ga894cdb8af74f7a563a94fb49c220fdcd">vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>nOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid.html">Grid</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>vrt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TAAPosVRT &amp;&#160;</td>
          <td class="paramname"><em>aaPos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculates the normal of a vertex using associated faces </p>
<p>TAAPosVRT has to be an attachment accessor for the vector3 type that works on the vertices in grid. </p>

<p class="reference">References <a class="el" href="classug_1_1_grid.html#a106cc182d347f7dcbb80cb166b9cba4e">ug::Grid::associated_faces_begin()</a>, <a class="el" href="classug_1_1_grid.html#ab9a41c2c814038390f068d76a4792af3">ug::Grid::associated_faces_end()</a>, <a class="el" href="group__lib__grid__algorithms__edge__util.html#ga47d8d9dc1634d72a7500de9fe2e1f7a3">ug::CalculateNormal()</a>, <a class="el" href="group__vectors.html#ga945c247d94409091fd35fdbbcb5032c2">ug::VecAdd()</a>, and <a class="el" href="group__vectors.html#ga53ae2dda87330ab64fb2a5901606b3e4">ug::VecNormalize()</a>.</p>

<p class="reference">Referenced by <a class="el" href="namespaceug.html#a05cd8e208a02e98281f7d824acd9bd5f">ug::SlopeSmooth()</a>, <a class="el" href="namespaceug.html#a59ab638a05e05520bb78fccf8c6d57ab">ug::SnapMarkerPointToGridVertex()</a>, <a class="el" href="group__lib__grid__algorithms__face__util.html#gac5dd5ed95ed5f64fd5d29133769324be">ug::Triangulate()</a>, <a class="el" href="namespaceug.html#a2c1b8ee1c15c3e6f5d83acb1ceaf7d6e">ug::TrySplit()</a>, and <a class="el" href="namespaceug.html#a6db1169a622721210a01277c9920fbab">ug::WeightedNormalSmooth()</a>.</p>

</div>
</div>
<a id="ga95754779ac568465423ab030b6421c7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95754779ac568465423ab030b6421c7f">&#9670;&nbsp;</a></span>CalculateVertexNormals() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> bool ug::CalculateVertexNormals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid.html">Grid</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceug.html#a780dd3524b97269f891365fd3c3b895a">APosition</a> &amp;&#160;</td>
          <td class="paramname"><em>aPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceug.html#a971c52fec411990d2bfb6ee27dbb0232">ANormal</a> &amp;&#160;</td>
          <td class="paramname"><em>aNorm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculates the normals of all vertices in grid and stores them in aNorm. </p>
<p>aPos has to be attached to grid. If some attachments were not attached correctly, the method returns false. </p>

<p class="reference">References <a class="el" href="classug_1_1_grid.html#a623e8985971c1f933385f848959b3844">ug::Grid::attach_to()</a>, and <a class="el" href="classug_1_1_grid.html#a69edbfd1e8115492e6445c7fd375ae78">ug::Grid::has_attachment()</a>.</p>

</div>
</div>
<a id="gabe72050ecf543aeda3950e6bd039e402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe72050ecf543aeda3950e6bd039e402">&#9670;&nbsp;</a></span>CalculateVertexNormals() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> bool ug::CalculateVertexNormals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid.html">Grid</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid_1_1_attachment_accessor.html">Grid::AttachmentAccessor</a>&lt; <a class="el" href="classug_1_1_vertex.html">Vertex</a>, <a class="el" href="namespaceug.html#a780dd3524b97269f891365fd3c3b895a">APosition</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>aaPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid_1_1_attachment_accessor.html">Grid::AttachmentAccessor</a>&lt; <a class="el" href="classug_1_1_vertex.html">Vertex</a>, <a class="el" href="namespaceug.html#a971c52fec411990d2bfb6ee27dbb0232">ANormal</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>aaNorm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculates the normals of all vertices in grid and stores them in aNorm. </p>
<p>aPos has to be attached to grid. If some attachments were not attached correctly, the method returns false. </p>

<p class="reference">References <a class="el" href="classug_1_1_grid.html#ac61deaa5a86f28e8e78fa481467f5d45">ug::Grid::begin()</a>, <a class="el" href="group__lib__grid__algorithms__edge__util.html#ga47d8d9dc1634d72a7500de9fe2e1f7a3">ug::CalculateNormal()</a>, <a class="el" href="classug_1_1_grid.html#aecec2b9e3e45241347497a58de7aa13a">ug::Grid::end()</a>, <a class="el" href="classug_1_1_face_vertices.html#a91c22d6b5fcc4c90e359685aafe2aa19">ug::FaceVertices::num_vertices()</a>, <a class="el" href="group__vectors.html#ga945c247d94409091fd35fdbbcb5032c2">ug::VecAdd()</a>, <a class="el" href="group__vectors.html#ga53ae2dda87330ab64fb2a5901606b3e4">ug::VecNormalize()</a>, and <a class="el" href="classug_1_1_face_vertices.html#a8f18cc58d9b6142a2d3728cfe55159d1">ug::FaceVertices::vertex()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__lib__grid__algorithms__remeshing.html#gab217fe44fb42f01be0dab1a46c2908ae">ug::AdjustEdgeLength()</a>.</p>

</div>
</div>
<a id="ga5221e89301cf0272f1a19cfe2ba9bab3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5221e89301cf0272f1a19cfe2ba9bab3">&#9670;&nbsp;</a></span>CollectSurfaceNeighborsSorted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> bool ug::CollectSurfaceNeighborsSorted </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classug_1_1_vertex.html">Vertex</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>vNeighborsOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid.html">Grid</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collects neighbor-vertices in either clockwise or counter clockwise order. </p>
<p>Please note: This algorithm uses <a class="el" href="classug_1_1_grid.html#a886c89b50e8f2980bfcdf74e65b23683" title="marks the object. Calls are only valid between calls to Grid::begin_marking and Grid::end_marking.">Grid::mark</a>.</p>
<p>This method will only work if the triangles connected to the given vertex are homeomorphic to the unit-disc.</p>
<p>Current implementation requires FACEOPT_AUTOGENERATE_EDGES (could be avoided). </p>

<p class="reference">References <a class="el" href="classug_1_1_grid.html#a12abfbc3c3ea8447b9297cc67d37d39a">ug::Grid::associated_edges_begin()</a>, <a class="el" href="classug_1_1_grid.html#a106cc182d347f7dcbb80cb166b9cba4e">ug::Grid::associated_faces_begin()</a>, <a class="el" href="classug_1_1_grid.html#ab9a41c2c814038390f068d76a4792af3">ug::Grid::associated_faces_end()</a>, <a class="el" href="classug_1_1_grid.html#a9b6fe1a67b9fa0d1dcb5b18d8cc23dd9">ug::Grid::associated_volumes_begin()</a>, <a class="el" href="classug_1_1_grid.html#ae4fba41614633b0b6e56e2bed4cf4e26">ug::Grid::associated_volumes_end()</a>, <a class="el" href="classug_1_1_grid.html#a9d45fe5cb040ee7e1be8f683f257790d">ug::Grid::begin_marking()</a>, <a class="el" href="group__lib__grid__algorithms__neighborhood__util.html#ga0e3a178c0d6a639afb8068d60191ee1c">ug::CollectEdges()</a>, <a class="el" href="group__lib__grid__algorithms__edge__util.html#ga0cce38c830ab3f7e4257d0e62f690868">ug::EdgeContains()</a>, <a class="el" href="group__lib__grid.html#gga3191186b24de51adb225ea234971df0ea41e559550a6eb4b85b9a02e4fcca8e5c">ug::EDGEOPT_STORE_ASSOCIATED_FACES</a>, <a class="el" href="classug_1_1_grid.html#a0dfadffbcf794fe5136b4a8ba4a86959">ug::Grid::end_marking()</a>, <a class="el" href="group__lib__grid.html#ggad5f5a639937a67f1018d12996992f6f3a91ebc7149fdaed37fc203643bb6e3994">ug::FACEOPT_AUTOGENERATE_EDGES</a>, <a class="el" href="group__lib__grid__algorithms__edge__util.html#ga6530a13a5990c960cfd2f1f066e0be8c">ug::GetAssociatedFaces()</a>, <a class="el" href="group__lib__grid__algorithms__vertex__util.html#ga0bae9d4d5288bbf36d46a8546209aca8">ug::GetConnectedVertex()</a>, <a class="el" href="group__lib__grid__algorithms__vertex__util.html#ga5151cea6aa053c8932b2977d99272a4d">ug::GetVertexIndex()</a>, <a class="el" href="classug_1_1_grid.html#a448f44e49cf1facf5346d9ca8b449337">ug::Grid::is_marked()</a>, <a class="el" href="classug_1_1_grid.html#a886c89b50e8f2980bfcdf74e65b23683">ug::Grid::mark()</a>, <a class="el" href="classug_1_1_face_vertices.html#a91c22d6b5fcc4c90e359685aafe2aa19">ug::FaceVertices::num_vertices()</a>, <a class="el" href="classug_1_1_grid.html#a70dcd73e1a869fc9b3970c6645a587d0">ug::Grid::num_volumes()</a>, <a class="el" href="classug_1_1_grid.html#a1a52ff3974dd27f9cce544226c43586c">ug::Grid::option_is_enabled()</a>, and <a class="el" href="classug_1_1_face_vertices.html#a8f18cc58d9b6142a2d3728cfe55159d1">ug::FaceVertices::vertex()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__lib__grid__algorithms__refinement__subdivision.html#gaf938e924ef3fa6118391b370b2c3349f">ug::ProjectToLimitPLoop()</a>.</p>

</div>
</div>
<a id="ga70e52bc98786dfb349944e4aea1a4b93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70e52bc98786dfb349944e4aea1a4b93">&#9670;&nbsp;</a></span>CompareVertexContainer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TVrtContainer1 , class TVrtContainer2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> bool ug::CompareVertexContainer </td>
          <td>(</td>
          <td class="paramtype">const TVrtContainer1 &amp;&#160;</td>
          <td class="paramname"><em>con1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TVrtContainer2 &amp;&#160;</td>
          <td class="paramname"><em>con2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compares vertices in a container </p>
<p>If you want to compare <a class="el" href="classug_1_1_edge.html" title="Base-class for edges.">Edge</a>, <a class="el" href="classug_1_1_face.html" title="Faces are 2-dimensional objects.">Face</a>, <a class="el" href="classug_1_1_volume.html" title="Volumes are 3-dimensional objects.">Volume</a>, <a class="el" href="classug_1_1_edge_descriptor.html" title="Can be used to store information about an edge and to construct an edge.">EdgeDescriptor</a>, <a class="el" href="classug_1_1_face_descriptor.html" title="Can be queried for the edges and vertices of a face.">FaceDescriptor</a> or <a class="el" href="classug_1_1_volume_descriptor.html" title="Holds a set of vertices which represent the corners of a volume element.">VolumeDescriptor</a> with other <a class="el" href="classug_1_1_edge.html" title="Base-class for edges.">Edge</a>, ... then please use CompareVertices instead.</p>
<p>TVrtContainer has to feature the following methods (or compatible ones): int size(): has to return the numbe of vertices in the container. Vertex* operator[](int index): has to return the i-th vertex.</p>
<p>Good types would be: <a class="el" href="classug_1_1_edge_vertices.html" title="holds the vertices of an Edge or an EdgeDescriptor.">EdgeVertices</a>, <a class="el" href="classug_1_1_face_vertices.html">FaceVertices</a>, <a class="el" href="classug_1_1_volume_vertices.html" title="holds the vertices of a Volume or a VolumeDescriptor">VolumeVertices</a>, <a class="el" href="classug_1_1_edge.html" title="Base-class for edges.">Edge</a>, <a class="el" href="classug_1_1_face.html" title="Faces are 2-dimensional objects.">Face</a>, <a class="el" href="classug_1_1_volume.html" title="Volumes are 3-dimensional objects.">Volume</a>, ..., std::vector&lt;Vertex*&gt;, ...</p>
<p>returns true if con1 and con2 contain the same vertices. </p>

</div>
</div>
<a id="ga6714b9ccee3ac300ae8bb4493ede02e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6714b9ccee3ac300ae8bb4493ede02e1">&#9670;&nbsp;</a></span>ContainsPoint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class vector_t , class TAAPos &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> bool ug::ContainsPoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classug_1_1_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_t &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TAAPos&#160;</td>
          <td class="paramname"><em>aaPos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given point lies on the given vertex. </p>
<p>The method simply checks, whether coordinates are identical. This method is of no particular use, except for completeness regarding the use of ConatinsPoint in template-programming. </p>

<p class="reference">References <a class="elRef" href="../plugins/_biogas_8lua.html#a57f1028d958bb73c4e3c64e2077342fc">p</a>.</p>

</div>
</div>
<a id="gaefad3008d43f5a281ec1d7d5dca78cc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaefad3008d43f5a281ec1d7d5dca78cc0">&#9670;&nbsp;</a></span>FindVertexByCoordiante()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classug_1_1_vertex.html">Vertex</a>* ug::FindVertexByCoordiante </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__vectors.html#ga894cdb8af74f7a563a94fb49c220fdcd">vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>coord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceug.html#a1903407556f1e2b80c006ae920ea8e0e">VertexIterator</a>&#160;</td>
          <td class="paramname"><em>iterBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceug.html#a1903407556f1e2b80c006ae920ea8e0e">VertexIterator</a>&#160;</td>
          <td class="paramname"><em>iterEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid_1_1_vertex_attachment_accessor.html">Grid::VertexAttachmentAccessor</a>&lt; <a class="el" href="namespaceug.html#a780dd3524b97269f891365fd3c3b895a">APosition</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>aaPos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the vertex that is the closest to the given coordinate </p>
<p>returns NULL if no vertex was found (if iterBegin == iterEnd). </p>

<p class="reference">References <a class="el" href="group__vectors.html#ga7da70ab2d2c942a82b582f1cc7888069">ug::VecDistanceSq()</a>.</p>

</div>
</div>
<a id="gad0385a01ac0f134d52a1398e6d826066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0385a01ac0f134d52a1398e6d826066">&#9670;&nbsp;</a></span>FindVertexByCoordinate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int ug::FindVertexByCoordinate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classug_1_1_math_vector.html">MathVector</a>&lt; <a class="elRef" href="../plugins/group__small__strain__mechanics.html#ga48fe27c9a0dffdcc67e1a84f77f632fc">dim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>coord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ncoords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classug_1_1_math_vector.html">MathVector</a>&lt; <a class="elRef" href="../plugins/group__small__strain__mechanics.html#ga48fe27c9a0dffdcc67e1a84f77f632fc">dim</a> &gt;&#160;</td>
          <td class="paramname"><em>vCoords</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns (non-unique?) index of closest vertex </p>
<p>returns -1 iff ncoords == 0 </p>

<p class="reference">References <a class="el" href="group__vectors.html#ga92e42e49d0d212e50fc214803cf06e78">ug::VecDistance()</a>, and <a class="el" href="group__vectors.html#ga7da70ab2d2c942a82b582f1cc7888069">ug::VecDistanceSq()</a>.</p>

</div>
</div>
<a id="ga3462fadc3d0f59d6a4177d60e647a2e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3462fadc3d0f59d6a4177d60e647a2e8">&#9670;&nbsp;</a></span>GetConnectedEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> <a class="el" href="classug_1_1_edge.html">Edge</a> * ug::GetConnectedEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid.html">Grid</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>vrt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_face.html">Face</a> *&#160;</td>
          <td class="paramname"><em>tri</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the edge in the triangle tri, which does not contain vrt. </p>
<p>Make sure that tri is a triangle! </p>

<p class="reference">References <a class="el" href="classug_1_1_face.html#a58d3b73e59ed266bdb6558c759ec0d51">ug::Face::edge_desc()</a>, <a class="el" href="group__lib__grid__algorithms__edge__util.html#ga0cce38c830ab3f7e4257d0e62f690868">ug::EdgeContains()</a>, <a class="el" href="classug_1_1_grid.html#a631569f60d18f00177e8cf24e5b3e3ff">ug::Grid::get_edge()</a>, and <a class="el" href="classug_1_1_face.html#ab2a35640fa0837cabc630c7287cd4340">ug::Face::num_edges()</a>.</p>

<p class="reference">Referenced by <a class="el" href="namespaceug.html#a05cd8e208a02e98281f7d824acd9bd5f">ug::SlopeSmooth()</a>, <a class="el" href="namespaceug.html#a805486111a1d81df475536251c7a6688">ug::TryCollapse()</a>, and <a class="el" href="namespaceug.html#ae7cf7ae92c0894c5501684a9e61b2746">ug::WeightedFaceSmooth()</a>.</p>

</div>
</div>
<a id="gaee1128b8bc4a8fed99814b0126b9b454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee1128b8bc4a8fed99814b0126b9b454">&#9670;&nbsp;</a></span>GetConnectedVertex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> <a class="el" href="classug_1_1_vertex.html">Vertex</a> * ug::GetConnectedVertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_edge.html">Edge</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the vertex that is connected to v via e. </p>
<p>returns NULL if v is not contained in e. </p>

<p class="reference">References <a class="el" href="classug_1_1_edge_vertices.html#a0f2ec2644877a1354489544f43c71206">ug::EdgeVertices::vertex()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__lib__grid__algorithms__remeshing.html#gaa6cdff940793032a9dac5582b475ee86">ug::AdaptSurfaceGridToCylinder()</a>, <a class="el" href="namespaceug.html#ade3f4f396966d0400b214282e9fa77a8">ug::CalculateSmoothCreaseManifoldPosInParentLevelLoopScheme()</a>, <a class="el" href="namespaceug.html#a670fd9a1468187d3d1f34b1c711d0ac9">ug::CalculateSmoothManifoldPosInParentLevelButterflyScheme()</a>, <a class="el" href="namespaceug.html#a6aa7a66ccdf4c13b829dc2f2cfa8bd62">ug::CalculateSmoothManifoldPosInParentLevelLoopScheme()</a>, <a class="el" href="group__lib__grid__algorithms__edge__util.html#ga2c12f2972755f9635e2834b0d954ead2">ug::CollapseEdge()</a>, <a class="el" href="namespaceug.html#abefd8861fcde8abc309cc732d580c013">ug::CollectConstraining()</a>, <a class="el" href="group__lib__grid__algorithms__neighborhood__util.html#gada8aee34f6f23920bac25802273647e1">ug::CollectNeighbors()</a>, <a class="el" href="group__lib__grid__algorithms__polychain__util.html#gaf931eaa7c43bd6777b19c2d8e624bc0f">ug::CreatePolyChain()</a>, <a class="el" href="namespaceug.html#a8ff8a352f8a8ca629bb6db200b22f099">ug::CreateQuadrilateral_NoRegistration()</a>, <a class="el" href="namespaceug.html#ae4bdfe829dadd19a65c8258630862e45">ug::ExportGridToUG_2D()</a>, <a class="el" href="namespaceug.html#a12b454f96e5779591a62ea52bdd80955">ug::ExtrudeLayers()</a>, <a class="el" href="group__lib__grid__algorithms__polychain__util.html#ga62c755743eeea86198da2e6346d90ac2">ug::GetNextSectionOfPolyChain()</a>, <a class="el" href="classug_1_1_delaunay_info.html#a0c7aa0b1f44d37ed3f3767f12420b54c">ug::DelaunayInfo&lt; TAAPos &gt;::init_marks()</a>, <a class="el" href="namespaceug.html#af0346339b646c98da4aba9fc967e729f">ug::LaplacianSmooth()</a>, <a class="el" href="namespaceug.html#a1f9980d74102b0d13df6658e3d76cd45">ug::MakeDelaunay()</a>, <a class="el" href="namespaceug.html#ace5df27b4125551954543fbe2eec12be">ug::MarkCorners()</a>, <a class="el" href="group__lib__grid__algorithms__edge__util.html#ga397492a903ffbec777ca5dda0d5be44b">ug::MinimizeEdgeLength_SwapsOnly()</a>, <a class="el" href="namespaceug.html#af32c1177e1b1acd0784c8a9fd42153d9">ug::MultiEdgeSplit()</a>, <a class="el" href="classug_1_1_subdivision_projector.html#afb7bb52886b5f1ce474cf0882224426a">ug::SubdivisionProjector::new_vertex()</a>, <a class="el" href="group__lib__grid__algorithms__refinement__subdivision.html#gaf938e924ef3fa6118391b370b2c3349f">ug::ProjectToLimitPLoop()</a>, <a class="el" href="group__lib__grid__algorithms__refinement__subdivision.html#gae0d3fd849c0dbdf64f258be46c646354">ug::ProjectToLimitSubdivBoundary()</a>, <a class="el" href="namespaceug.html#ad9b0103faf0eb6055d28275af533bcf8">ug::QualityGridGeneration()</a>, <a class="el" href="classug_1_1_subdivision_projector.html#a732bf4e0f3fd63e0c4f82dfe4d01296f">ug::SubdivisionProjector::refinement_begins()</a>, <a class="el" href="namespaceug.html#a1542104ac2ce93ffd11d323508e03f52">ug::ReplaceByQuadrilaterals_EdgeBased()</a>, <a class="el" href="namespaceug.html#a4bcdf37160ed5fe2770def62671534d6">ug::SelectKinkVertices()</a>, <a class="el" href="group__lib__grid__algorithms__selection__util.html#gaddeb745d2f782ee3727f8129d0281a08">ug::SelectSmoothEdgePath()</a>, <a class="el" href="namespaceug.html#a6d95ea88313c70843660707a79133274">ug::SimplifyPolylines()</a>, <a class="el" href="namespaceug.html#a05cd8e208a02e98281f7d824acd9bd5f">ug::SlopeSmooth()</a>, <a class="el" href="group__lib__grid__algorithms__polychain__util.html#ga75568f0b7fca5283caf4bd72371eaeac">ug::SplitIrregularPolyChain()</a>, <a class="el" href="namespaceug.html#a42dc806fbc8c63f5fe430fda32bfa471">ug::WeightedEdgeSmooth()</a>, and <a class="el" href="namespaceug.html#a6db1169a622721210a01277c9920fbab">ug::WeightedNormalSmooth()</a>.</p>

</div>
</div>
<a id="ga0bae9d4d5288bbf36d46a8546209aca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0bae9d4d5288bbf36d46a8546209aca8">&#9670;&nbsp;</a></span>GetConnectedVertex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> <a class="el" href="classug_1_1_vertex.html">Vertex</a> * ug::GetConnectedVertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_edge_vertices.html">EdgeVertices</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_face.html">Face</a> *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the index of the first vertex that is contained in f and is not contained in e. </p>

<p class="reference">References <a class="el" href="classug_1_1_face_vertices.html#a91c22d6b5fcc4c90e359685aafe2aa19">ug::FaceVertices::num_vertices()</a>, <a class="el" href="classug_1_1_edge_vertices.html#a0f2ec2644877a1354489544f43c71206">ug::EdgeVertices::vertex()</a>, and <a class="el" href="classug_1_1_face_vertices.html#a8f18cc58d9b6142a2d3728cfe55159d1">ug::FaceVertices::vertex()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__lib__grid__algorithms__vertex__util.html#ga5221e89301cf0272f1a19cfe2ba9bab3">ug::CollectSurfaceNeighborsSorted()</a>.</p>

</div>
</div>
<a id="gaab444e4d5c443af5fabba6b0104c7a87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab444e4d5c443af5fabba6b0104c7a87">&#9670;&nbsp;</a></span>GetConnectedVertexIndex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> int ug::GetConnectedVertexIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_face.html">Face</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classug_1_1_edge_descriptor.html">EdgeDescriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>ed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the index of the first vertex that is contained in the specified face and is not contained in the given edge. </p>

<p class="reference">References <a class="el" href="group__lib__grid__algorithms__vertex__util.html#ga80dfafb1e562579e406b94c6c50ee9b2">ug::GetConnectedVertexIndex()</a>.</p>

<p class="reference">Referenced by <a class="el" href="namespaceug.html#a1542104ac2ce93ffd11d323508e03f52">ug::ReplaceByQuadrilaterals_EdgeBased()</a>.</p>

</div>
</div>
<a id="ga80dfafb1e562579e406b94c6c50ee9b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80dfafb1e562579e406b94c6c50ee9b2">&#9670;&nbsp;</a></span>GetConnectedVertexIndex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> int ug::GetConnectedVertexIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_face.html">Face</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classug_1_1_edge_vertices.html">EdgeVertices</a> *&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="classug_1_1_face_vertices.html#a91c22d6b5fcc4c90e359685aafe2aa19">ug::FaceVertices::num_vertices()</a>, <a class="el" href="classug_1_1_edge_vertices.html#a0f2ec2644877a1354489544f43c71206">ug::EdgeVertices::vertex()</a>, and <a class="el" href="classug_1_1_face_vertices.html#a8f18cc58d9b6142a2d3728cfe55159d1">ug::FaceVertices::vertex()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__lib__grid__algorithms__vertex__util.html#gaab444e4d5c443af5fabba6b0104c7a87">ug::GetConnectedVertexIndex()</a>.</p>

</div>
</div>
<a id="ga0d4ce919a5c578ed819e67058723d332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d4ce919a5c578ed819e67058723d332">&#9670;&nbsp;</a></span>GetSharedVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> <a class="el" href="classug_1_1_vertex.html">Vertex</a> * ug::GetSharedVertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_i_vertex_group.html">IVertexGroup</a> *&#160;</td>
          <td class="paramname"><em>vrts0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_i_vertex_group.html">IVertexGroup</a> *&#160;</td>
          <td class="paramname"><em>vrts1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the first vertex of vrts0 that is also contained in vrts1 (or NULL if no such vertex exists) </p>

<p class="reference">References <a class="el" href="classug_1_1_i_vertex_group.html#a0b02aa326e045929f6aab037f8ea0233">ug::IVertexGroup::size()</a>, and <a class="el" href="classug_1_1_i_vertex_group.html#abceee6448ff1533f87534e8fd9a33b24">ug::IVertexGroup::vertices()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__lib__grid__algorithms__edge__util.html#ga2c12f2972755f9635e2834b0d954ead2">ug::CollapseEdge()</a>.</p>

</div>
</div>
<a id="ga7dfe766ecd522261dd33e5e8e5a41a1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7dfe766ecd522261dd33e5e8e5a41a1b">&#9670;&nbsp;</a></span>GetSharedVertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ug::GetSharedVertices </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classug_1_1_vertex.html">Vertex</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>vrtsOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_i_vertex_group.html">IVertexGroup</a> *&#160;</td>
          <td class="paramname"><em>vrts0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_i_vertex_group.html">IVertexGroup</a> *&#160;</td>
          <td class="paramname"><em>vrts1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>fills a vector with the vertices that are both contained in vrts0 and vrts1. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of shared vertices </dd></dl>

<p class="reference">References <a class="el" href="classug_1_1_i_vertex_group.html#a0b02aa326e045929f6aab037f8ea0233">ug::IVertexGroup::size()</a>, and <a class="el" href="classug_1_1_i_vertex_group.html#abceee6448ff1533f87534e8fd9a33b24">ug::IVertexGroup::vertices()</a>.</p>

</div>
</div>
<a id="gafc46f829211dc8ddd5cff1001178f765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc46f829211dc8ddd5cff1001178f765">&#9670;&nbsp;</a></span>GetVertex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classug_1_1_vertex.html">Vertex</a> * ug::GetVertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the i'th vertex of a vertex </p>
<p>This function simply returns the vertex itself. It is added for completeness, such that the function can be used in template code. </p>

<p class="reference">References <a class="el" href="group__ugbase__common.html#ga0b928ef153b78f1b5e025638cf28f841">UG_ASSERT</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__lib__grid__algorithms__geom__obj__misc.html#gad2306084cdb328bc619e3941902b1170">ug::CalculateBoundingBox()</a>, <a class="el" href="namespaceug.html#af945d52bbb907abcb9dff3e423187e5d">ug::CollectCornerCoordinates()</a>, <a class="el" href="classug_1_1_grid_points_ordering.html#a5bf7579cf48f7ed092226e9149f3fa76">ug::GridPointsOrdering&lt; TDomain, TAlgebra &gt;::count_sizes()</a>, <a class="el" href="classug_1_1_v_t_k_output.html#a0239be26972a1793a2e0fa74b841c29f">ug::VTKOutput&lt; TDim &gt;::count_sizes()</a>, <a class="el" href="group__refinement__bridge.html#ga74eb659b949e6286a606a1e0accdcff1">ug::MarkForRefinement_ContainsSurfaceNode()</a>, <a class="el" href="classug_1_1_grid_points_ordering.html#a15fd318991c2e809898612ff92bd6d00">ug::GridPointsOrdering&lt; TDomain, TAlgebra &gt;::number_points_elementwise()</a>, <a class="el" href="classug_1_1_v_t_k_output.html#a05d5fd30e2700029c05b06765ee03e0e">ug::VTKOutput&lt; TDim &gt;::write_nodal_data_elementwise()</a>, <a class="el" href="classug_1_1_v_t_k_output.html#a1afeef300424e1e92318e31f8b216657">ug::VTKOutput&lt; TDim &gt;::write_nodal_values_elementwise()</a>, and <a class="el" href="classug_1_1_v_t_k_output.html#ac9b902c020d2478f96b7a0950e6af455">ug::VTKOutput&lt; TDim &gt;::write_points_elementwise()</a>.</p>

</div>
</div>
<a id="gaaf616966d82226b6c9af1b072d2e482c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf616966d82226b6c9af1b072d2e482c">&#9670;&nbsp;</a></span>GetVertexIndex() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> int ug::GetVertexIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_edge_vertices.html">EdgeVertices</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the index at which vertex v is found in the given edge </p>
<p>returns -1 if the vertex was not found. </p>

<p class="reference">References <a class="el" href="classug_1_1_edge_vertices.html#a0f2ec2644877a1354489544f43c71206">ug::EdgeVertices::vertex()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classug_1_1_hanging_node_refiner_base.html#aeec7f03c6905a87e02f7bed0411b597b">ug::HangingNodeRefinerBase&lt; TSelector &gt;::assign_hnode_marks()</a>, <a class="el" href="namespaceug.html#ad932a22e1be2a0886532c80b993e2aaf">ug::CalculateConstrainedSmoothVolumePosInTopLevel()</a>, <a class="el" href="namespaceug.html#a22bc0665f3d822eace7d8fadbf81b6d5">ug::CalculateSmoothVolumePosInTopLevel()</a>, <a class="el" href="namespaceug.html#abb032cb93fdc9683f704ff56475c007f">ug::ComputeOrientationOffsetLagrange()</a>, <a class="el" href="namespaceug.html#a8ff8a352f8a8ca629bb6db200b22f099">ug::CreateQuadrilateral_NoRegistration()</a>, <a class="el" href="namespaceug.html#a22c44c68da507544d3aa6d9394769665">ug::FaceIsOnRightSide()</a>, <a class="el" href="group__lib__grid__algorithms__edge__util.html#gab71f0105ef482356bab57a65bc535624">ug::FixEdgeOrientation()</a>, <a class="el" href="classug_1_1_i_refiner.html#a615aa48d59030c11599609b775e4c4cc">ug::IRefiner::get_local_face_mark()</a>, <a class="el" href="namespaceug.html#adeff1790eedba598dcfb5bf5d616fc1a">ug::GetRightLeftUnitIndex()</a>, <a class="el" href="namespaceug.html#a4fb92158b445d7c4bb702d51f0443b0a">ug::ReplaceLowValenceVertices()</a>, <a class="el" href="namespaceug.html#a0f353c86d4eb3dde7d50d112ad2bb44d">ug::ReplaceValence3Vertices()</a>, and <a class="el" href="namespaceug.html#ac59cfae14833394225e59b5dee1e9014">ug::WriteNG()</a>.</p>

</div>
</div>
<a id="ga48792c2aba7f3a2a37275b90b9ac8b9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48792c2aba7f3a2a37275b90b9ac8b9d">&#9670;&nbsp;</a></span>GetVertexIndex() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> int ug::GetVertexIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_face_vertices.html">FaceVertices</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the index at which vertex v is found in the given face </p>
<p>returns -1 if the vertex was not found. </p>

<p class="reference">References <a class="el" href="classug_1_1_face_vertices.html#a91c22d6b5fcc4c90e359685aafe2aa19">ug::FaceVertices::num_vertices()</a>, and <a class="el" href="classug_1_1_face_vertices.html#a8f18cc58d9b6142a2d3728cfe55159d1">ug::FaceVertices::vertex()</a>.</p>

</div>
</div>
<a id="ga5151cea6aa053c8932b2977d99272a4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5151cea6aa053c8932b2977d99272a4d">&#9670;&nbsp;</a></span>GetVertexIndex() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> int ug::GetVertexIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_volume_vertices.html">VolumeVertices</a> *&#160;</td>
          <td class="paramname"><em>vol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the index at which vertex v is found in the given volume </p>
<p>returns -1 if the vertex was not found. </p>

<p class="reference">References <a class="el" href="classug_1_1_volume_vertices.html#aceb9eb86aed97692ec38612e87c74dda">ug::VolumeVertices::num_vertices()</a>, and <a class="el" href="classug_1_1_volume_vertices.html#a3ba78eccd3b42fb57565d072de0e99e7">ug::VolumeVertices::vertex()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__lib__grid__algorithms__vertex__util.html#ga5221e89301cf0272f1a19cfe2ba9bab3">ug::CollectSurfaceNeighborsSorted()</a>.</p>

</div>
</div>
<a id="ga278ac166fa59ab8608bee3e4a7b5c1fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga278ac166fa59ab8608bee3e4a7b5c1fa">&#9670;&nbsp;</a></span>IsBoundaryVertex1D()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> bool ug::IsBoundaryVertex1D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid.html">Grid</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structug_1_1_grid_1_1traits.html#a1bd114991c12becc6ca48862967dd9f2">Grid::edge_traits::callback</a>&#160;</td>
          <td class="paramname"><em>cbConsiderEdge</em> = <code><a class="el" href="classug_1_1_consider_all.html">ConsiderAll</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns whether a vertex lies on the boundary of a polygonal chain. </p>
<p>The polygonal chain may be part of a bigger grid containing faces and volume elements. To distinguish which edges should be part of the polygonal chain, you may specify a callback to identify them. </p>

<p class="reference">References <a class="el" href="classug_1_1_grid.html#a12abfbc3c3ea8447b9297cc67d37d39a">ug::Grid::associated_edges_begin()</a>, <a class="el" href="classug_1_1_grid.html#a578b44c6af08b6614f3df6aac3be8080">ug::Grid::associated_edges_end()</a>, <a class="el" href="classug_1_1_grid.html#ae94bdb2aa02392c63f9f15bde3d21328">ug::Grid::enable_options()</a>, <a class="el" href="group__ugbase__common.html#ga158a8c64f24645c7478298399825737f">LOG</a>, <a class="el" href="classug_1_1_grid.html#a1a52ff3974dd27f9cce544226c43586c">ug::Grid::option_is_enabled()</a>, and <a class="el" href="group__lib__grid.html#gga2d5555a08ac1dffc02be104256f71d73a326347072f1834c47c8cd0cf197e30a6">ug::VRTOPT_STORE_ASSOCIATED_EDGES</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__lib__grid__algorithms__polychain__util.html#ga3169521f903204a5df10d043005aa1be">ug::GetFirstSectionOfPolyChain()</a>, and <a class="el" href="group__lib__grid__algorithms__vertex__util.html#ga968ae16e440ac72e9fb2760ef15cc28b">ug::LiesOnBoundary()</a>.</p>

</div>
</div>
<a id="ga2027583d2c14c0b7ac9379df4c988ccf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2027583d2c14c0b7ac9379df4c988ccf">&#9670;&nbsp;</a></span>IsBoundaryVertex2D()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> bool ug::IsBoundaryVertex2D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid.html">Grid</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns whether a vertex lies on the boundary of a 2D grid. </p>
<p>A vertex is regarded as a 2d boundary vertex if it lies on a 2d boundary edge. if EDGEOPT_STORE_ASSOCIATED_FACES and VRTOPT_STORE_ASSOCIATED_EDGES are enabled, the algorithm will be faster. </p>

<p class="reference">References <a class="el" href="classug_1_1_grid.html#a12abfbc3c3ea8447b9297cc67d37d39a">ug::Grid::associated_edges_begin()</a>, <a class="el" href="classug_1_1_grid.html#a578b44c6af08b6614f3df6aac3be8080">ug::Grid::associated_edges_end()</a>, <a class="el" href="classug_1_1_grid.html#ae94bdb2aa02392c63f9f15bde3d21328">ug::Grid::enable_options()</a>, <a class="el" href="group__lib__grid.html#ggad5f5a639937a67f1018d12996992f6f3a91ebc7149fdaed37fc203643bb6e3994">ug::FACEOPT_AUTOGENERATE_EDGES</a>, <a class="el" href="group__lib__grid__algorithms__edge__util.html#ga5bf1afd38411b7139354752323bbd9d4">ug::IsBoundaryEdge2D()</a>, <a class="el" href="group__ugbase__common.html#ga158a8c64f24645c7478298399825737f">LOG</a>, <a class="el" href="classug_1_1_grid.html#a1a52ff3974dd27f9cce544226c43586c">ug::Grid::option_is_enabled()</a>, and <a class="el" href="group__lib__grid.html#gga2d5555a08ac1dffc02be104256f71d73a326347072f1834c47c8cd0cf197e30a6">ug::VRTOPT_STORE_ASSOCIATED_EDGES</a>.</p>

<p class="reference">Referenced by <a class="el" href="namespaceug.html#a5910504e9f899018d8b7ff00b247bdba">ug::ExpandFractures2d()</a>, <a class="el" href="namespaceug.html#ae4bdfe829dadd19a65c8258630862e45">ug::ExportGridToUG_2D()</a>, <a class="el" href="group__lib__grid__algorithms__vertex__util.html#ga968ae16e440ac72e9fb2760ef15cc28b">ug::LiesOnBoundary()</a>, <a class="el" href="group__lib__grid__algorithms__refinement__subdivision.html#gaf938e924ef3fa6118391b370b2c3349f">ug::ProjectToLimitPLoop()</a>, and <a class="el" href="group__lib__grid__algorithms__refinement__subdivision.html#gae0d3fd849c0dbdf64f258be46c646354">ug::ProjectToLimitSubdivBoundary()</a>.</p>

</div>
</div>
<a id="ga7e2bc9e8f5f8133db8ac2939f6ba178b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e2bc9e8f5f8133db8ac2939f6ba178b">&#9670;&nbsp;</a></span>IsBoundaryVertex3D()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> bool ug::IsBoundaryVertex3D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid.html">Grid</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns true if a vertex lies on the boundary of a 3D grid. </p>
<p>A vertex is regarded as a 3d boundary vertex if it lies on a 3d boundary face. if FACEOPT_STORE_ASSOCIATED_VOLUMES and VRTOPT_STORE_ASSOCIATED_FACES are enabled, the algorithm will be faster. </p>

<p class="reference">References <a class="el" href="classug_1_1_grid.html#a106cc182d347f7dcbb80cb166b9cba4e">ug::Grid::associated_faces_begin()</a>, <a class="el" href="classug_1_1_grid.html#ab9a41c2c814038390f068d76a4792af3">ug::Grid::associated_faces_end()</a>, <a class="el" href="classug_1_1_grid.html#ae94bdb2aa02392c63f9f15bde3d21328">ug::Grid::enable_options()</a>, <a class="el" href="group__lib__grid__algorithms__face__util.html#gafd8032868d5b1b81c1d0171156ce7acd">ug::IsVolumeBoundaryFace()</a>, <a class="el" href="group__ugbase__common.html#ga158a8c64f24645c7478298399825737f">LOG</a>, <a class="el" href="classug_1_1_grid.html#a1a52ff3974dd27f9cce544226c43586c">ug::Grid::option_is_enabled()</a>, <a class="el" href="group__lib__grid.html#gga1f929733097f2c587b05fa7c1f1f6502ae2c73031331562ca82b4a849a4f36874">ug::VOLOPT_AUTOGENERATE_FACES</a>, and <a class="el" href="group__lib__grid.html#gga2d5555a08ac1dffc02be104256f71d73a55b0e0ef49ac3698c2c0d2935821933b">ug::VRTOPT_STORE_ASSOCIATED_FACES</a>.</p>

<p class="reference">Referenced by <a class="el" href="namespaceug.html#a57abf95963a57af5e27eccb2dcec0ec6">ug::DistributeExpansionMarks3D()</a>, <a class="el" href="namespaceug.html#a7590b56787a7aac08577dddeaf9c9cc1">ug::ExpandFractures3d()</a>, and <a class="el" href="group__lib__grid__algorithms__vertex__util.html#ga968ae16e440ac72e9fb2760ef15cc28b">ug::LiesOnBoundary()</a>.</p>

</div>
</div>
<a id="ga0cbefc9fc997763a231d0f910376d3c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0cbefc9fc997763a231d0f910376d3c1">&#9670;&nbsp;</a></span>IsRegularSurfaceVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> bool ug::IsRegularSurfaceVertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid.html">Grid</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns true if the vertex lies inside a regular surface </p>
<p>This algorithm indirectly uses <a class="el" href="classug_1_1_grid.html#a886c89b50e8f2980bfcdf74e65b23683" title="marks the object. Calls are only valid between calls to Grid::begin_marking and Grid::end_marking.">Grid::mark</a>.</p>
<p>The vertex is regarded as a regular surface vertex, if all associated edges are connected to exactly 2 faces. </p>

<p class="reference">References <a class="el" href="classug_1_1_grid.html#a12abfbc3c3ea8447b9297cc67d37d39a">ug::Grid::associated_edges_begin()</a>, <a class="el" href="classug_1_1_grid.html#a578b44c6af08b6614f3df6aac3be8080">ug::Grid::associated_edges_end()</a>, and <a class="el" href="group__lib__grid__algorithms__vertex__util.html#ga3a826eba40e1813aa2f6866d59ed1926">ug::NumAssociatedFaces()</a>.</p>

</div>
</div>
<a id="ga968ae16e440ac72e9fb2760ef15cc28b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga968ae16e440ac72e9fb2760ef15cc28b">&#9670;&nbsp;</a></span>LiesOnBoundary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> bool ug::LiesOnBoundary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid.html">Grid</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns true, if the vertex lies on a 1d, 2d or 3d boundary </p>

<p class="reference">References <a class="el" href="group__lib__grid__algorithms__vertex__util.html#ga278ac166fa59ab8608bee3e4a7b5c1fa">ug::IsBoundaryVertex1D()</a>, <a class="el" href="group__lib__grid__algorithms__vertex__util.html#ga2027583d2c14c0b7ac9379df4c988ccf">ug::IsBoundaryVertex2D()</a>, <a class="el" href="group__lib__grid__algorithms__vertex__util.html#ga7e2bc9e8f5f8133db8ac2939f6ba178b">ug::IsBoundaryVertex3D()</a>, and <a class="el" href="classug_1_1_grid.html#a544579dbb0f7a011880b43c8302934dc">ug::Grid::num()</a>.</p>

</div>
</div>
<a id="gaf44b3bf9a26a6ad362eae2e1b6345a3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf44b3bf9a26a6ad362eae2e1b6345a3f">&#9670;&nbsp;</a></span>MarkFixedCreaseVertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> void ug::MarkFixedCreaseVertices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid.html">Grid</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceug.html#a4077697589380822c2f46b597f550f4b">SubsetHandler</a> &amp;&#160;</td>
          <td class="paramname"><em>sh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>creaseSI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fixedSI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Uses <a class="el" href="classug_1_1_grid.html#a886c89b50e8f2980bfcdf74e65b23683" title="marks the object. Calls are only valid between calls to Grid::begin_marking and Grid::end_marking.">Grid::mark()</a></p>
<p>Vertices that are adjacent with more than two crease-edges are regarded as a fixed vertex. </p>

<p class="reference">References <a class="el" href="classug_1_1_grid_subset_handler.html#a2344691e472126f245181b9fa534d70e">ug::GridSubsetHandler::assign_subset()</a>, <a class="el" href="classug_1_1_grid.html#a12abfbc3c3ea8447b9297cc67d37d39a">ug::Grid::associated_edges_begin()</a>, <a class="el" href="classug_1_1_grid.html#a578b44c6af08b6614f3df6aac3be8080">ug::Grid::associated_edges_end()</a>, <a class="el" href="classug_1_1_grid_subset_handler.html#ad8a3e34644aa2d55cf1328ef6cfb9588">ug::GridSubsetHandler::begin()</a>, <a class="el" href="classug_1_1_grid.html#a9d45fe5cb040ee7e1be8f683f257790d">ug::Grid::begin_marking()</a>, <a class="el" href="classug_1_1_grid_subset_handler.html#a61bfa76ef2ebd6412c1a30d7b12d9f5f">ug::GridSubsetHandler::end()</a>, <a class="el" href="classug_1_1_grid.html#a0dfadffbcf794fe5136b4a8ba4a86959">ug::Grid::end_marking()</a>, <a class="el" href="classug_1_1_i_subset_handler.html#ab322bfc9560e86b563145b9e264d385e">ug::ISubsetHandler::get_subset_index()</a>, <a class="el" href="classug_1_1_grid.html#a448f44e49cf1facf5346d9ca8b449337">ug::Grid::is_marked()</a>, <a class="el" href="classug_1_1_grid.html#a886c89b50e8f2980bfcdf74e65b23683">ug::Grid::mark()</a>, <a class="el" href="classug_1_1_grid_subset_handler.html#af5e0bd51f199eded2f503d61e3dcdc5b">ug::GridSubsetHandler::num()</a>, and <a class="el" href="classug_1_1_i_subset_handler.html#abe054731d7c51a58815c64cc767d8e08">ug::ISubsetHandler::num_subsets()</a>.</p>

</div>
</div>
<a id="ga526c91d80e4f634cac8d617a52199afa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga526c91d80e4f634cac8d617a52199afa">&#9670;&nbsp;</a></span>MergeMultipleVertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TVrtIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> <a class="el" href="classug_1_1_vertex.html">Vertex</a>* ug::MergeMultipleVertices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid.html">Grid</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TVrtIterator&#160;</td>
          <td class="paramname"><em>vrtsBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TVrtIterator&#160;</td>
          <td class="paramname"><em>vrtsEnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges all vertices between the given iterators into a single vertex. </p>
<p>Note that connected elements may be removed or replaced during this process. The method returns the remaining vertex in the given list (*vrtsBegin). </p>

<p class="reference">References <a class="el" href="group__lib__grid__algorithms__vertex__util.html#ga756bb139ffc1dd1ef5725086d83f2522">ug::MergeVertices()</a>.</p>

</div>
</div>
<a id="ga756bb139ffc1dd1ef5725086d83f2522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga756bb139ffc1dd1ef5725086d83f2522">&#9670;&nbsp;</a></span>MergeVertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> void ug::MergeVertices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid.html">Grid</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>merges two vertices and restructures the adjacent elements. </p>
<p>Since vertex v2 has to be removed in the process, the associated elements of this vertex have to be replaced by new ones. Values attached to old elements are passed on to the new ones using grid::pass_on_values. </p>

<p class="reference">References <a class="el" href="classug_1_1_grid.html#a12abfbc3c3ea8447b9297cc67d37d39a">ug::Grid::associated_edges_begin()</a>, <a class="el" href="classug_1_1_grid.html#a578b44c6af08b6614f3df6aac3be8080">ug::Grid::associated_edges_end()</a>, <a class="el" href="classug_1_1_grid.html#a106cc182d347f7dcbb80cb166b9cba4e">ug::Grid::associated_faces_begin()</a>, <a class="el" href="classug_1_1_grid.html#ab9a41c2c814038390f068d76a4792af3">ug::Grid::associated_faces_end()</a>, <a class="el" href="classug_1_1_grid.html#a9b6fe1a67b9fa0d1dcb5b18d8cc23dd9">ug::Grid::associated_volumes_begin()</a>, <a class="el" href="classug_1_1_grid.html#ae4fba41614633b0b6e56e2bed4cf4e26">ug::Grid::associated_volumes_end()</a>, <a class="elRef" href="../plugins/group__promesh.html#gacfc9a7208dee05060f98b7b14d626c40">CollapseEdge()</a>, <a class="el" href="classug_1_1_grid.html#a08bdbe8721c2428711596264bd073335">ug::Grid::create_by_cloning()</a>, <a class="el" href="classug_1_1_grid.html#ae94bdb2aa02392c63f9f15bde3d21328">ug::Grid::enable_options()</a>, <a class="el" href="classug_1_1_grid.html#a94e7d19731e2d384bd0dc1b70a173cfc">ug::Grid::erase()</a>, <a class="el" href="group__lib__grid__algorithms__geom__obj__misc.html#ga1c54c22fd814fc8bdeddeb58417a79bf">ug::EraseConnectingElements()</a>, <a class="el" href="classug_1_1_grid.html#a631569f60d18f00177e8cf24e5b3e3ff">ug::Grid::get_edge()</a>, <a class="el" href="classug_1_1_grid.html#a6970549d629877a26e896ed00f309210">ug::Grid::get_face()</a>, <a class="el" href="group__ugbase__common.html#ga158a8c64f24645c7478298399825737f">LOG</a>, <a class="el" href="classug_1_1_grid.html#ad6ab1515b0c210c91a7262e59d9da2d7">ug::Grid::num_edges()</a>, <a class="el" href="classug_1_1_grid.html#a998c99dbae3769c7168dfc27a9411833">ug::Grid::num_faces()</a>, <a class="el" href="classug_1_1_face_vertices.html#a91c22d6b5fcc4c90e359685aafe2aa19">ug::FaceVertices::num_vertices()</a>, <a class="el" href="classug_1_1_volume_vertices.html#aceb9eb86aed97692ec38612e87c74dda">ug::VolumeVertices::num_vertices()</a>, <a class="el" href="classug_1_1_grid.html#a70dcd73e1a869fc9b3970c6645a587d0">ug::Grid::num_volumes()</a>, <a class="el" href="classug_1_1_grid.html#ac045932a053db8e94eef57bf7853c61f">ug::Grid::objects_will_be_merged()</a>, <a class="el" href="classug_1_1_grid.html#a1a52ff3974dd27f9cce544226c43586c">ug::Grid::option_is_enabled()</a>, <a class="el" href="classug_1_1_face_descriptor.html#a5671fc960e79a48bfcb85724e789b498">ug::FaceDescriptor::set_num_vertices()</a>, <a class="el" href="classug_1_1_volume_descriptor.html#ab60768126bb470249334fc56a5c6b331">ug::VolumeDescriptor::set_num_vertices()</a>, <a class="el" href="classug_1_1_face_descriptor.html#adea79f793190321746f6953e994f5a5f">ug::FaceDescriptor::set_vertex()</a>, <a class="el" href="classug_1_1_volume_descriptor.html#a1a18dbc15bbcd8624fe98e99ef049d59">ug::VolumeDescriptor::set_vertex()</a>, <a class="el" href="classug_1_1_edge_descriptor.html#a3af38a29930413dde59b6ecd0922fae5">ug::EdgeDescriptor::set_vertices()</a>, <a class="el" href="classug_1_1_edge_vertices.html#a0f2ec2644877a1354489544f43c71206">ug::EdgeVertices::vertex()</a>, <a class="el" href="classug_1_1_face_vertices.html#a8f18cc58d9b6142a2d3728cfe55159d1">ug::FaceVertices::vertex()</a>, <a class="el" href="classug_1_1_volume_vertices.html#a3ba78eccd3b42fb57565d072de0e99e7">ug::VolumeVertices::vertex()</a>, <a class="el" href="group__lib__grid.html#gga2d5555a08ac1dffc02be104256f71d73a326347072f1834c47c8cd0cf197e30a6">ug::VRTOPT_STORE_ASSOCIATED_EDGES</a>, <a class="el" href="group__lib__grid.html#gga2d5555a08ac1dffc02be104256f71d73a55b0e0ef49ac3698c2c0d2935821933b">ug::VRTOPT_STORE_ASSOCIATED_FACES</a>, and <a class="el" href="group__lib__grid.html#gga2d5555a08ac1dffc02be104256f71d73a7839f7bdda8775d1c6f5896d0c76c7dc">ug::VRTOPT_STORE_ASSOCIATED_VOLUMES</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__lib__grid__algorithms__vertex__util.html#ga526c91d80e4f634cac8d617a52199afa">ug::MergeMultipleVertices()</a>, <a class="el" href="group__lib__grid__algorithms__vertex__util.html#ga3624945d6c779bbfb5d470d874016da9">ug::RemoveDoubles()</a>, <a class="el" href="namespaceug.html#a66fe4246082c39400c8c25bdaf531dc2">ug::ResolveEdgeEdgeIntersection()</a>, <a class="el" href="namespaceug.html#ab49bd7b2589650c86c2e3c5354ab23a7">ug::ResolveEdgeFaceIntersection()</a>, and <a class="el" href="namespaceug.html#abd58f586cf30c647da872c5b4fb93ecf">ug::ResolveVertexEdgeIntersection()</a>.</p>

</div>
</div>
<a id="ga56cb44dd0a306072b484b980e6949468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56cb44dd0a306072b484b980e6949468">&#9670;&nbsp;</a></span>MoveVertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TIterator , class TAAPos &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ug::MoveVertices </td>
          <td>(</td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>vrtsBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>vrtsEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TAAPos&#160;</td>
          <td class="paramname"><em>aaPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename TAAPos::ValueType &amp;&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>moves vertices by the specified offset </p>

</div>
</div>
<a id="ga307a8879682aad14b24df172ada00342"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga307a8879682aad14b24df172ada00342">&#9670;&nbsp;</a></span>NumAssociatedEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> int ug::NumAssociatedEdges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid.html">Grid</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the number of associated edges of the given vertex </p>

<p class="reference">References <a class="el" href="classug_1_1_grid.html#acfb4b5a6a7a0d46df0bdd25bbe55e74b">ug::Grid::associated_elements()</a>, and <a class="el" href="classug_1_1_pointer_const_array.html#a4f421ad36ddde79f62d80a4f1a633dc0">ug::PointerConstArray&lt; TPtr &gt;::size()</a>.</p>

<p class="reference">Referenced by <a class="el" href="namespaceug.html#a500c334f1f91ba7c83e38cc61cbbfd10">ug::PerformTetrahedralization()</a>.</p>

</div>
</div>
<a id="ga3a826eba40e1813aa2f6866d59ed1926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a826eba40e1813aa2f6866d59ed1926">&#9670;&nbsp;</a></span>NumAssociatedFaces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> int ug::NumAssociatedFaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid.html">Grid</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the number of associated faces of the given vertex </p>

<p class="reference">References <a class="el" href="classug_1_1_grid.html#acfb4b5a6a7a0d46df0bdd25bbe55e74b">ug::Grid::associated_elements()</a>, and <a class="el" href="classug_1_1_pointer_const_array.html#a4f421ad36ddde79f62d80a4f1a633dc0">ug::PointerConstArray&lt; TPtr &gt;::size()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__lib__grid__algorithms__vertex__util.html#ga0cbefc9fc997763a231d0f910376d3c1">ug::IsRegularSurfaceVertex()</a>.</p>

</div>
</div>
<a id="ga4b31afe8e8a41c95568826dfbfd0dd7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b31afe8e8a41c95568826dfbfd0dd7a">&#9670;&nbsp;</a></span>NumSharedVertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ug::NumSharedVertices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_i_vertex_group.html">IVertexGroup</a> *&#160;</td>
          <td class="paramname"><em>vrts0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_i_vertex_group.html">IVertexGroup</a> *&#160;</td>
          <td class="paramname"><em>vrts1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of shared vertices between vrts0 and vrts1. </p>

<p class="reference">References <a class="el" href="classug_1_1_i_vertex_group.html#a0b02aa326e045929f6aab037f8ea0233">ug::IVertexGroup::size()</a>, and <a class="el" href="classug_1_1_i_vertex_group.html#abceee6448ff1533f87534e8fd9a33b24">ug::IVertexGroup::vertices()</a>.</p>

</div>
</div>
<a id="ga0ef4b61a6c2f18a940efa1cf74d7e47d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ef4b61a6c2f18a940efa1cf74d7e47d">&#9670;&nbsp;</a></span>RemoveDoubles() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class TVrtIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> void ug::RemoveDoubles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid.html">Grid</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TVrtIterator &amp;&#160;</td>
          <td class="paramname"><em>iterBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TVrtIterator &amp;&#160;</td>
          <td class="paramname"><em>iterEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_attachment.html">Attachment</a>&lt; <a class="el" href="classug_1_1_math_vector.html">MathVector</a>&lt; <a class="elRef" href="../plugins/group__small__strain__mechanics.html#ga48fe27c9a0dffdcc67e1a84f77f632fc">dim</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>aPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a>&#160;</td>
          <td class="paramname"><em>threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>merges all vertices that are closer to each other than the specified threshold. </p>
<p>The current implementation sadly enforces some restrictions to the container from which iterBegin and iterEnd stem. Only <a class="el" href="classug_1_1_grid.html" title="Manages the elements of a grid and their interconnection.">Grid</a>, <a class="el" href="classug_1_1_multi_grid.html">MultiGrid</a>, <a class="el" href="classug_1_1_selector.html" title="specialization of ISelector for a grid of class Grid.">Selector</a>, <a class="el" href="classug_1_1_m_g_selector.html" title="specialization of ISelector for grids of class MultiGrid.">MGSelector</a>, SubsetHandler, MGSubsetHandler and similar containers are allowed. This is due to an implementation detail in the algorithm that should be removed in future revisins.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000025">Todo:</a></b></dt><dd>remove container restrictions as described above.</dd></dl>

<p class="reference">References <a class="el" href="classug_1_1_grid.html#ace5ab805d91e2051d93f4d54d24fa605">ug::Grid::has_vertex_attachment()</a>.</p>

</div>
</div>
<a id="ga3624945d6c779bbfb5d470d874016da9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3624945d6c779bbfb5d470d874016da9">&#9670;&nbsp;</a></span>RemoveDoubles() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class TVrtIterator , class TAAPos &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> void ug::RemoveDoubles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid.html">Grid</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TVrtIterator &amp;&#160;</td>
          <td class="paramname"><em>iterBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TVrtIterator &amp;&#160;</td>
          <td class="paramname"><em>iterEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TAAPos&#160;</td>
          <td class="paramname"><em>aaPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a>&#160;</td>
          <td class="paramname"><em>threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>merges all vertices that are closer to each other than the specified threshold. </p>
<p>The current implementation sadly enforces some restrictions to the container from which iterBegin and iterEnd stem. Only <a class="el" href="classug_1_1_grid.html" title="Manages the elements of a grid and their interconnection.">Grid</a>, <a class="el" href="classug_1_1_multi_grid.html">MultiGrid</a>, <a class="el" href="classug_1_1_selector.html" title="specialization of ISelector for a grid of class Grid.">Selector</a>, <a class="el" href="classug_1_1_m_g_selector.html" title="specialization of ISelector for grids of class MultiGrid.">MGSelector</a>, SubsetHandler, MGSubsetHandler and similar containers are allowed. This is due to an implementation detail in the algorithm that should be removed in future revisins.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000025">Todo:</a></b></dt><dd>remove container restrictions as described above.</dd></dl>

<p class="reference">References <a class="el" href="classug_1_1_grid.html#adb6caced6744d79f36ff3fad01feee6b">ug::Grid::attach_to_vertices()</a>, <a class="el" href="classug_1_1_k_d_tree_static.html#abd9044d6d735caacab7f25cd0b6652d7">ug::KDTreeStatic&lt; TPositionAttachment, numDimensions, TVector &gt;::create_from_grid()</a>, <a class="el" href="classug_1_1_grid.html#aaff9f1777ab9b258b7f8786fe8dbe12c">ug::Grid::detach_from_vertices()</a>, <a class="el" href="classug_1_1_k_d_tree_static.html#aaf8136387abac4080f4a8b59eab6e5e6">ug::KDTreeStatic&lt; TPositionAttachment, numDimensions, TVector &gt;::get_neighbourhood()</a>, <a class="el" href="group__lib__grid__algorithms__trees.html#ggac7c3d5a00e1647b0ce7e2b00d57fe0daa7693dffed6ac342c0725e9c9f60d3e7e">ug::KDSD_LARGEST</a>, <a class="el" href="group__lib__grid__algorithms__vertex__util.html#ga756bb139ffc1dd1ef5725086d83f2522">ug::MergeVertices()</a>, <a class="el" href="classug_1_1_grid.html#aa4ec9e185aa495cfcced70c2b588be97">ug::Grid::num_vertices()</a>, and <a class="el" href="group__vectors.html#ga7da70ab2d2c942a82b582f1cc7888069">ug::VecDistanceSq()</a>.</p>

</div>
</div>
<a id="ga9e891587ff8d12dede467105f3294e2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e891587ff8d12dede467105f3294e2e">&#9670;&nbsp;</a></span>TransformVertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TAAPos &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> void ug::TransformVertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>vrt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__vectors.html#ga9dccf0b544ad1d673c172407ab8b2c4b">matrix33</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TAAPos &amp;&#160;</td>
          <td class="paramname"><em>aaPos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>transforms a vertex by a given matrix </p>

<p class="reference">References <a class="el" href="group__ugbase__math.html#gab755dfcc4823f5a150c931e1fdca6c78">ug::MatVecMult()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__lib__grid__algorithms__vertex__util.html#ga0bdf1d3beee9cc3540cdff32c428351d">ug::TransformVertices()</a>.</p>

</div>
</div>
<a id="ga0bdf1d3beee9cc3540cdff32c428351d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0bdf1d3beee9cc3540cdff32c428351d">&#9670;&nbsp;</a></span>TransformVertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TIterator , class TAAPos &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> void ug::TransformVertices </td>
          <td>(</td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>vrtsBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>vrtsEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__vectors.html#ga9dccf0b544ad1d673c172407ab8b2c4b">matrix33</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TAAPos &amp;&#160;</td>
          <td class="paramname"><em>aaPos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>transforms all given vertices by a given matrix </p>

<p class="reference">References <a class="el" href="group__lib__grid__algorithms__vertex__util.html#ga9e891587ff8d12dede467105f3294e2e">ug::TransformVertex()</a>.</p>

</div>
</div>
<a id="ga0f9cc2f74e43cf36c68b59a51b7184d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f9cc2f74e43cf36c68b59a51b7184d4">&#9670;&nbsp;</a></span>VertexDistance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TAAPos &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> <a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a> ug::VertexDistance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TAAPos &amp;&#160;</td>
          <td class="paramname"><em>aaPos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the distance between two vertices. </p>

<p class="reference">References <a class="el" href="group__vectors.html#ga92e42e49d0d212e50fc214803cf06e78">ug::VecDistance()</a>.</p>

<p class="reference">Referenced by <a class="el" href="namespaceug.html#a994f8e6f78aabf365faf0c2c5c189239">ug::is_anisotropic()</a>.</p>

</div>
</div>
<a id="gab7c796988775ad24fd15c24087d8a81e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7c796988775ad24fd15c24087d8a81e">&#9670;&nbsp;</a></span>VertexDistanceSq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TAAPos &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> <a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a> ug::VertexDistanceSq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TAAPos &amp;&#160;</td>
          <td class="paramname"><em>aaPos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the squared distance between two vertices. </p>

<p class="reference">References <a class="el" href="group__vectors.html#ga7da70ab2d2c942a82b582f1cc7888069">ug::VecDistanceSq()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__lib__grid__algorithms__edge__util.html#ga397492a903ffbec777ca5dda0d5be44b">ug::MinimizeEdgeLength_SwapsOnly()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Mar 4 2024 00:54:06 for ug4 by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
