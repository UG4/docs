<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ug4: ug::OperatorInverseIterator&lt; TAlgebra &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ug4
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classug_1_1_operator_inverse_iterator.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classug_1_1_operator_inverse_iterator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ug::OperatorInverseIterator&lt; TAlgebra &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="operator__inverse__iterator_8h_source.html">operator_inverse_iterator.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for ug::OperatorInverseIterator&lt; TAlgebra &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="classug_1_1_operator_inverse_iterator.png" usemap="#ug::OperatorInverseIterator_3C_20TAlgebra_20_3E_map" alt=""/>
  <map id="ug::OperatorInverseIterator_3C_20TAlgebra_20_3E_map" name="ug::OperatorInverseIterator_3C_20TAlgebra_20_3E_map">
<area href="classug_1_1_i_linear_iterator.html" alt="ug::ILinearIterator&lt; TAlgebra::vector_type &gt;" shape="rect" coords="0,0,260,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ad1094144fc5a39d2242ca5b4cf8a8f1a"><td class="memItemLeft" align="right" valign="top">typedef TAlgebra&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_operator_inverse_iterator.html#ad1094144fc5a39d2242ca5b4cf8a8f1a">algebra_type</a></td></tr>
<tr class="memdesc:ad1094144fc5a39d2242ca5b4cf8a8f1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Algebra type.  <a href="classug_1_1_operator_inverse_iterator.html#ad1094144fc5a39d2242ca5b4cf8a8f1a">More...</a><br /></td></tr>
<tr class="separator:ad1094144fc5a39d2242ca5b4cf8a8f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19e50066676e7a66d7f23cace2e78aba"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classug_1_1_i_preconditioner.html">IPreconditioner</a>&lt; TAlgebra &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_operator_inverse_iterator.html#a19e50066676e7a66d7f23cace2e78aba">base_type</a></td></tr>
<tr class="memdesc:a19e50066676e7a66d7f23cace2e78aba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base type.  <a href="classug_1_1_operator_inverse_iterator.html#a19e50066676e7a66d7f23cace2e78aba">More...</a><br /></td></tr>
<tr class="separator:a19e50066676e7a66d7f23cace2e78aba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7527a252e4f57433342a58cb97062ed3"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classug_1_1_i_preconditioner.html">IPreconditioner</a>&lt; TAlgebra &gt;::<a class="el" href="classug_1_1_operator_inverse_iterator.html#a7527a252e4f57433342a58cb97062ed3">matrix_operator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_operator_inverse_iterator.html#a7527a252e4f57433342a58cb97062ed3">matrix_operator_type</a></td></tr>
<tr class="memdesc:a7527a252e4f57433342a58cb97062ed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix Operator type.  <a href="classug_1_1_operator_inverse_iterator.html#a7527a252e4f57433342a58cb97062ed3">More...</a><br /></td></tr>
<tr class="separator:a7527a252e4f57433342a58cb97062ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a368e268936594413f5af2e1def609ecd"><td class="memItemLeft" align="right" valign="top">typedef TAlgebra::matrix_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_operator_inverse_iterator.html#a368e268936594413f5af2e1def609ecd">matrix_type</a></td></tr>
<tr class="memdesc:a368e268936594413f5af2e1def609ecd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix type.  <a href="classug_1_1_operator_inverse_iterator.html#a368e268936594413f5af2e1def609ecd">More...</a><br /></td></tr>
<tr class="separator:a368e268936594413f5af2e1def609ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09d5ffdb03a740beb3e066a4402f9fdd"><td class="memItemLeft" align="right" valign="top">typedef TAlgebra::vector_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_operator_inverse_iterator.html#a09d5ffdb03a740beb3e066a4402f9fdd">vector_type</a></td></tr>
<tr class="memdesc:a09d5ffdb03a740beb3e066a4402f9fdd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classug_1_1_vector.html">Vector</a> type.  <a href="classug_1_1_operator_inverse_iterator.html#a09d5ffdb03a740beb3e066a4402f9fdd">More...</a><br /></td></tr>
<tr class="separator:a09d5ffdb03a740beb3e066a4402f9fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classug_1_1_i_linear_iterator"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classug_1_1_i_linear_iterator')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classug_1_1_i_linear_iterator.html">ug::ILinearIterator&lt; TAlgebra::vector_type &gt;</a></td></tr>
<tr class="memitem:a7a54a9eabc77a3121f5526febb25d825 inherit pub_types_classug_1_1_i_linear_iterator"><td class="memItemLeft" align="right" valign="top">typedef <a class="elRef" href="../plugins/namespaceug_1_1_demo_plugin.html#ac9b1c611e1f3622c954d4a2a604349e1">TAlgebra::vector_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_i_linear_iterator.html#a7a54a9eabc77a3121f5526febb25d825">codomain_function_type</a></td></tr>
<tr class="memdesc:a7a54a9eabc77a3121f5526febb25d825 inherit pub_types_classug_1_1_i_linear_iterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Range space.  <a href="classug_1_1_i_linear_iterator.html#a7a54a9eabc77a3121f5526febb25d825">More...</a><br /></td></tr>
<tr class="separator:a7a54a9eabc77a3121f5526febb25d825 inherit pub_types_classug_1_1_i_linear_iterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a8964b8c1e183414871acf84083cb3e inherit pub_types_classug_1_1_i_linear_iterator"><td class="memItemLeft" align="right" valign="top">typedef <a class="elRef" href="../plugins/namespaceug_1_1_demo_plugin.html#ac9b1c611e1f3622c954d4a2a604349e1">TAlgebra::vector_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_i_linear_iterator.html#a8a8964b8c1e183414871acf84083cb3e">domain_function_type</a></td></tr>
<tr class="memdesc:a8a8964b8c1e183414871acf84083cb3e inherit pub_types_classug_1_1_i_linear_iterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Domain space.  <a href="classug_1_1_i_linear_iterator.html#a8a8964b8c1e183414871acf84083cb3e">More...</a><br /></td></tr>
<tr class="separator:a8a8964b8c1e183414871acf84083cb3e inherit pub_types_classug_1_1_i_linear_iterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3cf43c14a05172189403d87946b9afed"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_operator_inverse_iterator.html#a3cf43c14a05172189403d87946b9afed">apply</a> (<a class="el" href="classug_1_1_operator_inverse_iterator.html#a09d5ffdb03a740beb3e066a4402f9fdd">vector_type</a> &amp;c, const <a class="el" href="classug_1_1_operator_inverse_iterator.html#a09d5ffdb03a740beb3e066a4402f9fdd">vector_type</a> &amp;d)</td></tr>
<tr class="memdesc:a3cf43c14a05172189403d87946b9afed"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute new correction c = B*d  <a href="classug_1_1_operator_inverse_iterator.html#a3cf43c14a05172189403d87946b9afed">More...</a><br /></td></tr>
<tr class="separator:a3cf43c14a05172189403d87946b9afed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e5034ee1989d6e3281b75abe4ab5d69"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_operator_inverse_iterator.html#a6e5034ee1989d6e3281b75abe4ab5d69">apply_update_defect</a> (<a class="el" href="classug_1_1_operator_inverse_iterator.html#a09d5ffdb03a740beb3e066a4402f9fdd">vector_type</a> &amp;c, <a class="el" href="classug_1_1_operator_inverse_iterator.html#a09d5ffdb03a740beb3e066a4402f9fdd">vector_type</a> &amp;d)</td></tr>
<tr class="memdesc:a6e5034ee1989d6e3281b75abe4ab5d69"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute new correction c = B*d and update defect d := d - A*c  <a href="classug_1_1_operator_inverse_iterator.html#a6e5034ee1989d6e3281b75abe4ab5d69">More...</a><br /></td></tr>
<tr class="separator:a6e5034ee1989d6e3281b75abe4ab5d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9416c9a1976767431f0eedb2d03661d6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="classug_1_1_i_linear_iterator.html">ILinearIterator</a>&lt; <a class="el" href="classug_1_1_operator_inverse_iterator.html#a09d5ffdb03a740beb3e066a4402f9fdd">vector_type</a>, <a class="el" href="classug_1_1_operator_inverse_iterator.html#a09d5ffdb03a740beb3e066a4402f9fdd">vector_type</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_operator_inverse_iterator.html#a9416c9a1976767431f0eedb2d03661d6">clone</a> ()</td></tr>
<tr class="memdesc:a9416c9a1976767431f0eedb2d03661d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">clone  <a href="classug_1_1_operator_inverse_iterator.html#a9416c9a1976767431f0eedb2d03661d6">More...</a><br /></td></tr>
<tr class="separator:a9416c9a1976767431f0eedb2d03661d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad563d8a7553bb8746258d849fd2af74d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_operator_inverse_iterator.html#ad563d8a7553bb8746258d849fd2af74d">init</a> (<a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="classug_1_1_i_linear_operator.html">ILinearOperator</a>&lt; <a class="el" href="classug_1_1_operator_inverse_iterator.html#a09d5ffdb03a740beb3e066a4402f9fdd">vector_type</a> &gt; &gt; J, const <a class="el" href="classug_1_1_operator_inverse_iterator.html#a09d5ffdb03a740beb3e066a4402f9fdd">vector_type</a> &amp;u)</td></tr>
<tr class="separator:ad563d8a7553bb8746258d849fd2af74d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51356fc31ffde95d563fca76a6b1e554"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_operator_inverse_iterator.html#a51356fc31ffde95d563fca76a6b1e554">init</a> (<a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="classug_1_1_i_linear_operator.html">ILinearOperator</a>&lt; <a class="el" href="classug_1_1_operator_inverse_iterator.html#a09d5ffdb03a740beb3e066a4402f9fdd">vector_type</a> &gt; &gt; L)</td></tr>
<tr class="separator:a51356fc31ffde95d563fca76a6b1e554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a900e7f067f394a8e881acfd6bc8cc225"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_operator_inverse_iterator.html#a900e7f067f394a8e881acfd6bc8cc225">name</a> () const</td></tr>
<tr class="memdesc:a900e7f067f394a8e881acfd6bc8cc225"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the name of iterator  <a href="classug_1_1_operator_inverse_iterator.html#a900e7f067f394a8e881acfd6bc8cc225">More...</a><br /></td></tr>
<tr class="separator:a900e7f067f394a8e881acfd6bc8cc225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a796b098df74d3d1c6f3b529648952500"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_operator_inverse_iterator.html#a796b098df74d3d1c6f3b529648952500">OperatorInverseIterator</a> (<a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="classug_1_1_i_linear_operator_inverse.html">ILinearOperatorInverse</a>&lt; <a class="el" href="classug_1_1_operator_inverse_iterator.html#a09d5ffdb03a740beb3e066a4402f9fdd">vector_type</a> &gt; &gt; opInv)</td></tr>
<tr class="memdesc:a796b098df74d3d1c6f3b529648952500"><td class="mdescLeft">&#160;</td><td class="mdescRight">default constructor  <a href="classug_1_1_operator_inverse_iterator.html#a796b098df74d3d1c6f3b529648952500">More...</a><br /></td></tr>
<tr class="separator:a796b098df74d3d1c6f3b529648952500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34a5f6fbb44aec1dd1f97b6fd009ed2a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_operator_inverse_iterator.html#a34a5f6fbb44aec1dd1f97b6fd009ed2a">supports_parallel</a> () const</td></tr>
<tr class="memdesc:a34a5f6fbb44aec1dd1f97b6fd009ed2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns if parallel solving is supported  <a href="classug_1_1_operator_inverse_iterator.html#a34a5f6fbb44aec1dd1f97b6fd009ed2a">More...</a><br /></td></tr>
<tr class="separator:a34a5f6fbb44aec1dd1f97b6fd009ed2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add6a67d91dfc534ccfe1a9981439a439"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_operator_inverse_iterator.html#add6a67d91dfc534ccfe1a9981439a439">~OperatorInverseIterator</a> ()</td></tr>
<tr class="separator:add6a67d91dfc534ccfe1a9981439a439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classug_1_1_i_linear_iterator"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classug_1_1_i_linear_iterator')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classug_1_1_i_linear_iterator.html">ug::ILinearIterator&lt; TAlgebra::vector_type &gt;</a></td></tr>
<tr class="memitem:a418ce3a32db18417d9783f7d094c2945 inherit pub_methods_classug_1_1_i_linear_iterator"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_i_linear_iterator.html#a418ce3a32db18417d9783f7d094c2945">config_string</a> () const</td></tr>
<tr class="separator:a418ce3a32db18417d9783f7d094c2945 inherit pub_methods_classug_1_1_i_linear_iterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa437a6b8395a5ced9f88a4fed5b1bd77 inherit pub_methods_classug_1_1_i_linear_iterator"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="classug_1_1_i_damping.html">IDamping</a>&lt; <a class="elRef" href="../plugins/namespaceug_1_1_demo_plugin.html#ac9b1c611e1f3622c954d4a2a604349e1">TAlgebra::vector_type</a>, <a class="elRef" href="../plugins/namespaceug_1_1_demo_plugin.html#ac9b1c611e1f3622c954d4a2a604349e1">TAlgebra::vector_type</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_i_linear_iterator.html#aa437a6b8395a5ced9f88a4fed5b1bd77">damping</a> ()</td></tr>
<tr class="memdesc:aa437a6b8395a5ced9f88a4fed5b1bd77 inherit pub_methods_classug_1_1_i_linear_iterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the scaling  <a href="classug_1_1_i_linear_iterator.html#aa437a6b8395a5ced9f88a4fed5b1bd77">More...</a><br /></td></tr>
<tr class="separator:aa437a6b8395a5ced9f88a4fed5b1bd77 inherit pub_methods_classug_1_1_i_linear_iterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefc546bf97351373f54619ab9b5b8a46 inherit pub_methods_classug_1_1_i_linear_iterator"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_i_linear_iterator.html#aefc546bf97351373f54619ab9b5b8a46">ILinearIterator</a> ()</td></tr>
<tr class="memdesc:aefc546bf97351373f54619ab9b5b8a46 inherit pub_methods_classug_1_1_i_linear_iterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor  <a href="classug_1_1_i_linear_iterator.html#aefc546bf97351373f54619ab9b5b8a46">More...</a><br /></td></tr>
<tr class="separator:aefc546bf97351373f54619ab9b5b8a46 inherit pub_methods_classug_1_1_i_linear_iterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea663dfc186d01de17e335a6e42a57ff inherit pub_methods_classug_1_1_i_linear_iterator"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_i_linear_iterator.html#aea663dfc186d01de17e335a6e42a57ff">ILinearIterator</a> (const <a class="el" href="classug_1_1_i_linear_iterator.html">ILinearIterator</a>&lt; <a class="elRef" href="../plugins/namespaceug_1_1_demo_plugin.html#ac9b1c611e1f3622c954d4a2a604349e1">TAlgebra::vector_type</a>, <a class="elRef" href="../plugins/namespaceug_1_1_demo_plugin.html#ac9b1c611e1f3622c954d4a2a604349e1">TAlgebra::vector_type</a> &gt; &amp;parent)</td></tr>
<tr class="memdesc:aea663dfc186d01de17e335a6e42a57ff inherit pub_methods_classug_1_1_i_linear_iterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy constructor  <a href="classug_1_1_i_linear_iterator.html#aea663dfc186d01de17e335a6e42a57ff">More...</a><br /></td></tr>
<tr class="separator:aea663dfc186d01de17e335a6e42a57ff inherit pub_methods_classug_1_1_i_linear_iterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a974eed8cfc9e2bc0b6bbc64a44b4ce8a inherit pub_methods_classug_1_1_i_linear_iterator"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_i_linear_iterator.html#a974eed8cfc9e2bc0b6bbc64a44b4ce8a">init</a> (<a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="classug_1_1_i_linear_operator.html">ILinearOperator</a>&lt; <a class="elRef" href="../plugins/namespaceug_1_1_demo_plugin.html#ac9b1c611e1f3622c954d4a2a604349e1">TAlgebra::vector_type</a>, <a class="elRef" href="../plugins/namespaceug_1_1_demo_plugin.html#ac9b1c611e1f3622c954d4a2a604349e1">TAlgebra::vector_type</a> &gt; &gt; J, const <a class="elRef" href="../plugins/namespaceug_1_1_demo_plugin.html#ac9b1c611e1f3622c954d4a2a604349e1">TAlgebra::vector_type</a> &amp;u)=0</td></tr>
<tr class="memdesc:a974eed8cfc9e2bc0b6bbc64a44b4ce8a inherit pub_methods_classug_1_1_i_linear_iterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">initialize for operator J(u) and linearization point u  <a href="classug_1_1_i_linear_iterator.html#a974eed8cfc9e2bc0b6bbc64a44b4ce8a">More...</a><br /></td></tr>
<tr class="separator:a974eed8cfc9e2bc0b6bbc64a44b4ce8a inherit pub_methods_classug_1_1_i_linear_iterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a306fe0f0062f16fe7000c88bf4ffddc3 inherit pub_methods_classug_1_1_i_linear_iterator"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_i_linear_iterator.html#a306fe0f0062f16fe7000c88bf4ffddc3">init</a> (<a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="classug_1_1_i_linear_operator.html">ILinearOperator</a>&lt; <a class="elRef" href="../plugins/namespaceug_1_1_demo_plugin.html#ac9b1c611e1f3622c954d4a2a604349e1">TAlgebra::vector_type</a>, <a class="elRef" href="../plugins/namespaceug_1_1_demo_plugin.html#ac9b1c611e1f3622c954d4a2a604349e1">TAlgebra::vector_type</a> &gt; &gt; L)=0</td></tr>
<tr class="memdesc:a306fe0f0062f16fe7000c88bf4ffddc3 inherit pub_methods_classug_1_1_i_linear_iterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">initialize for linear operator L  <a href="classug_1_1_i_linear_iterator.html#a306fe0f0062f16fe7000c88bf4ffddc3">More...</a><br /></td></tr>
<tr class="separator:a306fe0f0062f16fe7000c88bf4ffddc3 inherit pub_methods_classug_1_1_i_linear_iterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1deaa4063fddd6a5b2a409730e81befb inherit pub_methods_classug_1_1_i_linear_iterator"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_i_linear_iterator.html#a1deaa4063fddd6a5b2a409730e81befb">set_damp</a> (<a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a> factor)</td></tr>
<tr class="memdesc:a1deaa4063fddd6a5b2a409730e81befb inherit pub_methods_classug_1_1_i_linear_iterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the damping to a constant factor  <a href="classug_1_1_i_linear_iterator.html#a1deaa4063fddd6a5b2a409730e81befb">More...</a><br /></td></tr>
<tr class="separator:a1deaa4063fddd6a5b2a409730e81befb inherit pub_methods_classug_1_1_i_linear_iterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2801c0b3a3a7844da204768578aa4e60 inherit pub_methods_classug_1_1_i_linear_iterator"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_i_linear_iterator.html#a2801c0b3a3a7844da204768578aa4e60">set_damp</a> (<a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="classug_1_1_i_damping.html">IDamping</a>&lt; <a class="elRef" href="../plugins/namespaceug_1_1_demo_plugin.html#ac9b1c611e1f3622c954d4a2a604349e1">TAlgebra::vector_type</a>, <a class="elRef" href="../plugins/namespaceug_1_1_demo_plugin.html#ac9b1c611e1f3622c954d4a2a604349e1">TAlgebra::vector_type</a> &gt; &gt; spScaling)</td></tr>
<tr class="memdesc:a2801c0b3a3a7844da204768578aa4e60 inherit pub_methods_classug_1_1_i_linear_iterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets a scaling for the correction  <a href="classug_1_1_i_linear_iterator.html#a2801c0b3a3a7844da204768578aa4e60">More...</a><br /></td></tr>
<tr class="separator:a2801c0b3a3a7844da204768578aa4e60 inherit pub_methods_classug_1_1_i_linear_iterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7171232f6c9c7d9cdf2e4284b7a37b67 inherit pub_methods_classug_1_1_i_linear_iterator"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_i_linear_iterator.html#a7171232f6c9c7d9cdf2e4284b7a37b67">~ILinearIterator</a> ()</td></tr>
<tr class="memdesc:a7171232f6c9c7d9cdf2e4284b7a37b67 inherit pub_methods_classug_1_1_i_linear_iterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">virtual destructor  <a href="classug_1_1_i_linear_iterator.html#a7171232f6c9c7d9cdf2e4284b7a37b67">More...</a><br /></td></tr>
<tr class="separator:a7171232f6c9c7d9cdf2e4284b7a37b67 inherit pub_methods_classug_1_1_i_linear_iterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a243919b70e4cbdb0959428a764d24ac5"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_operator_inverse_iterator.html#a243919b70e4cbdb0959428a764d24ac5">m_name</a></td></tr>
<tr class="separator:a243919b70e4cbdb0959428a764d24ac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a5a7289e7f4be9c322e3f45afc3f00942"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="classug_1_1_i_linear_operator_inverse.html">ILinearOperatorInverse</a>&lt; <a class="el" href="classug_1_1_operator_inverse_iterator.html#a09d5ffdb03a740beb3e066a4402f9fdd">vector_type</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_operator_inverse_iterator.html#a5a7289e7f4be9c322e3f45afc3f00942">m_opInv</a></td></tr>
<tr class="separator:a5a7289e7f4be9c322e3f45afc3f00942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classug_1_1_i_linear_iterator"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classug_1_1_i_linear_iterator')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classug_1_1_i_linear_iterator.html">ug::ILinearIterator&lt; TAlgebra::vector_type &gt;</a></td></tr>
<tr class="memitem:a061ffcb25819046dd8bfba3626049208 inherit pro_attribs_classug_1_1_i_linear_iterator"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="classug_1_1_i_damping.html">IDamping</a>&lt; <a class="elRef" href="../plugins/namespaceug_1_1_demo_plugin.html#ac9b1c611e1f3622c954d4a2a604349e1">TAlgebra::vector_type</a>, <a class="elRef" href="../plugins/namespaceug_1_1_demo_plugin.html#ac9b1c611e1f3622c954d4a2a604349e1">TAlgebra::vector_type</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_i_linear_iterator.html#a061ffcb25819046dd8bfba3626049208">m_spDamping</a></td></tr>
<tr class="memdesc:a061ffcb25819046dd8bfba3626049208 inherit pro_attribs_classug_1_1_i_linear_iterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">the scaling  <a href="classug_1_1_i_linear_iterator.html#a061ffcb25819046dd8bfba3626049208">More...</a><br /></td></tr>
<tr class="separator:a061ffcb25819046dd8bfba3626049208 inherit pro_attribs_classug_1_1_i_linear_iterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename TAlgebra&gt;<br />
class ug::OperatorInverseIterator&lt; TAlgebra &gt;</h3>

<p>a LinearIterator which can uses <a class="el" href="classug_1_1_i_linear_operator_inverse.html" title="describes an inverse linear mapping X-&gt;Y">ILinearOperatorInverse</a> to perform B^{-1} this is for the case that some class needs a preconditioner, but we'd like to use a linear solver example: 4x AMG as preconditioner </p><div class="fragment"><div class="line">linSolver = LinearSolver()</div>
<div class="line">linSolver:set_preconditioner(amg)</div>
<div class="line">linSolver:set_convergence_check(ConvCheck(4, 0, 0, false) )</div>
<div class="line">oii = <a class="code" href="classug_1_1_operator_inverse_iterator.html#a796b098df74d3d1c6f3b529648952500">OperatorInverseIterator</a>(linSolver)</div>
<div class="line">someObject:set_preconditioner(oii)</div>
<div class="ttc" id="aclassug_1_1_operator_inverse_iterator_html_a796b098df74d3d1c6f3b529648952500"><div class="ttname"><a href="classug_1_1_operator_inverse_iterator.html#a796b098df74d3d1c6f3b529648952500">ug::OperatorInverseIterator::OperatorInverseIterator</a></div><div class="ttdeci">OperatorInverseIterator(SmartPtr&lt; ILinearOperatorInverse&lt; vector_type &gt; &gt; opInv)</div><div class="ttdoc">default constructor</div><div class="ttdef"><b>Definition:</b> operator_inverse_iterator.h:92</div></div>
</div><!-- fragment --> </div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ad1094144fc5a39d2242ca5b4cf8a8f1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1094144fc5a39d2242ca5b4cf8a8f1a">&#9670;&nbsp;</a></span>algebra_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TAlgebra &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef TAlgebra <a class="el" href="classug_1_1_operator_inverse_iterator.html">ug::OperatorInverseIterator</a>&lt; TAlgebra &gt;::<a class="el" href="classug_1_1_operator_inverse_iterator.html#ad1094144fc5a39d2242ca5b4cf8a8f1a">algebra_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Algebra type. </p>

</div>
</div>
<a id="a19e50066676e7a66d7f23cace2e78aba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19e50066676e7a66d7f23cace2e78aba">&#9670;&nbsp;</a></span>base_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TAlgebra &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classug_1_1_i_preconditioner.html">IPreconditioner</a>&lt;TAlgebra&gt; <a class="el" href="classug_1_1_operator_inverse_iterator.html">ug::OperatorInverseIterator</a>&lt; TAlgebra &gt;::<a class="el" href="classug_1_1_operator_inverse_iterator.html#a19e50066676e7a66d7f23cace2e78aba">base_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Base type. </p>

</div>
</div>
<a id="a7527a252e4f57433342a58cb97062ed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7527a252e4f57433342a58cb97062ed3">&#9670;&nbsp;</a></span>matrix_operator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TAlgebra &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classug_1_1_i_preconditioner.html">IPreconditioner</a>&lt;TAlgebra&gt;::<a class="el" href="classug_1_1_operator_inverse_iterator.html#a7527a252e4f57433342a58cb97062ed3">matrix_operator_type</a> <a class="el" href="classug_1_1_operator_inverse_iterator.html">ug::OperatorInverseIterator</a>&lt; TAlgebra &gt;::<a class="el" href="classug_1_1_operator_inverse_iterator.html#a7527a252e4f57433342a58cb97062ed3">matrix_operator_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix Operator type. </p>

</div>
</div>
<a id="a368e268936594413f5af2e1def609ecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a368e268936594413f5af2e1def609ecd">&#9670;&nbsp;</a></span>matrix_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TAlgebra &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef TAlgebra::matrix_type <a class="el" href="classug_1_1_operator_inverse_iterator.html">ug::OperatorInverseIterator</a>&lt; TAlgebra &gt;::<a class="el" href="classug_1_1_operator_inverse_iterator.html#a368e268936594413f5af2e1def609ecd">matrix_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix type. </p>

</div>
</div>
<a id="a09d5ffdb03a740beb3e066a4402f9fdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09d5ffdb03a740beb3e066a4402f9fdd">&#9670;&nbsp;</a></span>vector_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TAlgebra &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef TAlgebra::vector_type <a class="el" href="classug_1_1_operator_inverse_iterator.html">ug::OperatorInverseIterator</a>&lt; TAlgebra &gt;::<a class="el" href="classug_1_1_operator_inverse_iterator.html#a09d5ffdb03a740beb3e066a4402f9fdd">vector_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classug_1_1_vector.html">Vector</a> type. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a796b098df74d3d1c6f3b529648952500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a796b098df74d3d1c6f3b529648952500">&#9670;&nbsp;</a></span>OperatorInverseIterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TAlgebra &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classug_1_1_operator_inverse_iterator.html">ug::OperatorInverseIterator</a>&lt; TAlgebra &gt;::<a class="el" href="classug_1_1_operator_inverse_iterator.html">OperatorInverseIterator</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="classug_1_1_i_linear_operator_inverse.html">ILinearOperatorInverse</a>&lt; <a class="el" href="classug_1_1_operator_inverse_iterator.html#a09d5ffdb03a740beb3e066a4402f9fdd">vector_type</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>opInv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>default constructor </p>

<p class="reference">References <a class="el" href="classug_1_1_operator_inverse_iterator.html#a243919b70e4cbdb0959428a764d24ac5">ug::OperatorInverseIterator&lt; TAlgebra &gt;::m_name</a>, and <a class="el" href="classug_1_1_operator_inverse_iterator.html#a5a7289e7f4be9c322e3f45afc3f00942">ug::OperatorInverseIterator&lt; TAlgebra &gt;::m_opInv</a>.</p>

</div>
</div>
<a id="add6a67d91dfc534ccfe1a9981439a439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add6a67d91dfc534ccfe1a9981439a439">&#9670;&nbsp;</a></span>~OperatorInverseIterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TAlgebra &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classug_1_1_operator_inverse_iterator.html">ug::OperatorInverseIterator</a>&lt; TAlgebra &gt;::~<a class="el" href="classug_1_1_operator_inverse_iterator.html">OperatorInverseIterator</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3cf43c14a05172189403d87946b9afed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cf43c14a05172189403d87946b9afed">&#9670;&nbsp;</a></span>apply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TAlgebra &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classug_1_1_operator_inverse_iterator.html">ug::OperatorInverseIterator</a>&lt; TAlgebra &gt;::apply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_operator_inverse_iterator.html#a09d5ffdb03a740beb3e066a4402f9fdd">vector_type</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classug_1_1_operator_inverse_iterator.html#a09d5ffdb03a740beb3e066a4402f9fdd">vector_type</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compute new correction c = B*d </p>
<p>This method applies the iterator operator, i.e. c = B*d. The domain function d remains unchanged. Note, that this method can always be implemented by creating a copy of d and calling apply_update_defect with this copy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>defect </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">c</td><td>correction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool success flag </dd></dl>

<p>Implements <a class="el" href="classug_1_1_i_linear_iterator.html#a293e586f2b9bc1affab1aed75b89387c">ug::ILinearIterator&lt; TAlgebra::vector_type &gt;</a>.</p>

<p class="reference">References <a class="el" href="classug_1_1_operator_inverse_iterator.html#a5a7289e7f4be9c322e3f45afc3f00942">ug::OperatorInverseIterator&lt; TAlgebra &gt;::m_opInv</a>.</p>

</div>
</div>
<a id="a6e5034ee1989d6e3281b75abe4ab5d69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e5034ee1989d6e3281b75abe4ab5d69">&#9670;&nbsp;</a></span>apply_update_defect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TAlgebra &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classug_1_1_operator_inverse_iterator.html">ug::OperatorInverseIterator</a>&lt; TAlgebra &gt;::apply_update_defect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_operator_inverse_iterator.html#a09d5ffdb03a740beb3e066a4402f9fdd">vector_type</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_operator_inverse_iterator.html#a09d5ffdb03a740beb3e066a4402f9fdd">vector_type</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compute new correction c = B*d and update defect d := d - A*c </p>
<p>This method applies the inverse operator, i.e. c = B*d. The domain function d is changed in the way, that the defect d := d - A*c is returned in the function. This is always useful, when the iterating algorithm can (or must) update the defect during computation (this is e.g. the case for the geometric multigrid method). Note, that this method can always be implemented by calling apply and then computing d := d - A*c.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d</td><td>defect </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>correction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool success flag </dd></dl>

<p>Implements <a class="el" href="classug_1_1_i_linear_iterator.html#a0c0ffc2bfb32edb2cef566b14d815556">ug::ILinearIterator&lt; TAlgebra::vector_type &gt;</a>.</p>

<p class="reference">References <a class="el" href="classug_1_1_operator_inverse_iterator.html#a5a7289e7f4be9c322e3f45afc3f00942">ug::OperatorInverseIterator&lt; TAlgebra &gt;::m_opInv</a>.</p>

</div>
</div>
<a id="a9416c9a1976767431f0eedb2d03661d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9416c9a1976767431f0eedb2d03661d6">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TAlgebra &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt;<a class="el" href="classug_1_1_i_linear_iterator.html">ILinearIterator</a>&lt;<a class="el" href="classug_1_1_operator_inverse_iterator.html#a09d5ffdb03a740beb3e066a4402f9fdd">vector_type</a>, <a class="el" href="classug_1_1_operator_inverse_iterator.html#a09d5ffdb03a740beb3e066a4402f9fdd">vector_type</a>&gt; &gt; <a class="el" href="classug_1_1_operator_inverse_iterator.html">ug::OperatorInverseIterator</a>&lt; TAlgebra &gt;::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>clone </p>

<p>Implements <a class="el" href="classug_1_1_i_linear_iterator.html#acc249ee1efa7994db8e732772728d5c1">ug::ILinearIterator&lt; TAlgebra::vector_type &gt;</a>.</p>

<p class="reference">References <a class="el" href="group__ugbase__common__util.html#gaaf72bcd4f74729e4a43694267e8590d8">SPNULL</a>, and <a class="el" href="group__ugbase__common.html#ga0b928ef153b78f1b5e025638cf28f841">UG_ASSERT</a>.</p>

</div>
</div>
<a id="ad563d8a7553bb8746258d849fd2af74d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad563d8a7553bb8746258d849fd2af74d">&#9670;&nbsp;</a></span>init() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TAlgebra &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classug_1_1_operator_inverse_iterator.html">ug::OperatorInverseIterator</a>&lt; TAlgebra &gt;::init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="classug_1_1_i_linear_operator.html">ILinearOperator</a>&lt; <a class="el" href="classug_1_1_operator_inverse_iterator.html#a09d5ffdb03a740beb3e066a4402f9fdd">vector_type</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classug_1_1_operator_inverse_iterator.html#a09d5ffdb03a740beb3e066a4402f9fdd">vector_type</a> &amp;&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="classug_1_1_operator_inverse_iterator.html#a5a7289e7f4be9c322e3f45afc3f00942">ug::OperatorInverseIterator&lt; TAlgebra &gt;::m_opInv</a>, <a class="el" href="classug_1_1_operator_inverse_iterator.html#a900e7f067f394a8e881acfd6bc8cc225">ug::OperatorInverseIterator&lt; TAlgebra &gt;::name()</a>, and <a class="el" href="group__ugbase__common.html#ga849480b16e1d7c49266a92cd5db63942">UG_LOG</a>.</p>

</div>
</div>
<a id="a51356fc31ffde95d563fca76a6b1e554"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51356fc31ffde95d563fca76a6b1e554">&#9670;&nbsp;</a></span>init() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TAlgebra &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classug_1_1_operator_inverse_iterator.html">ug::OperatorInverseIterator</a>&lt; TAlgebra &gt;::init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="classug_1_1_i_linear_operator.html">ILinearOperator</a>&lt; <a class="el" href="classug_1_1_operator_inverse_iterator.html#a09d5ffdb03a740beb3e066a4402f9fdd">vector_type</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>L</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="classug_1_1_operator_inverse_iterator.html#a5a7289e7f4be9c322e3f45afc3f00942">ug::OperatorInverseIterator&lt; TAlgebra &gt;::m_opInv</a>, <a class="el" href="classug_1_1_operator_inverse_iterator.html#a900e7f067f394a8e881acfd6bc8cc225">ug::OperatorInverseIterator&lt; TAlgebra &gt;::name()</a>, and <a class="el" href="group__ugbase__common.html#ga849480b16e1d7c49266a92cd5db63942">UG_LOG</a>.</p>

</div>
</div>
<a id="a900e7f067f394a8e881acfd6bc8cc225"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a900e7f067f394a8e881acfd6bc8cc225">&#9670;&nbsp;</a></span>name()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TAlgebra &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* <a class="el" href="classug_1_1_operator_inverse_iterator.html">ug::OperatorInverseIterator</a>&lt; TAlgebra &gt;::name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the name of iterator </p>
<p>This method returns the name of the iterator operator. This function is typically needed, when the iterator operator is used inside of another operator and some debug output should be printed</p>
<dl class="section return"><dt>Returns</dt><dd>const char* name of inverse operator </dd></dl>

<p>Implements <a class="el" href="classug_1_1_i_linear_iterator.html#ade314890710f60784c7f9c57597f6842">ug::ILinearIterator&lt; TAlgebra::vector_type &gt;</a>.</p>

<p class="reference">References <a class="el" href="classug_1_1_operator_inverse_iterator.html#a243919b70e4cbdb0959428a764d24ac5">ug::OperatorInverseIterator&lt; TAlgebra &gt;::m_name</a>.</p>

<p class="reference">Referenced by <a class="el" href="classug_1_1_operator_inverse_iterator.html#a51356fc31ffde95d563fca76a6b1e554">ug::OperatorInverseIterator&lt; TAlgebra &gt;::init()</a>.</p>

</div>
</div>
<a id="a34a5f6fbb44aec1dd1f97b6fd009ed2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34a5f6fbb44aec1dd1f97b6fd009ed2a">&#9670;&nbsp;</a></span>supports_parallel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TAlgebra &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classug_1_1_operator_inverse_iterator.html">ug::OperatorInverseIterator</a>&lt; TAlgebra &gt;::supports_parallel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns if parallel solving is supported </p>

<p>Implements <a class="el" href="classug_1_1_i_linear_iterator.html#a0b857bd37bb750ab867343e799fc2d48">ug::ILinearIterator&lt; TAlgebra::vector_type &gt;</a>.</p>

<p class="reference">References <a class="el" href="classug_1_1_operator_inverse_iterator.html#a5a7289e7f4be9c322e3f45afc3f00942">ug::OperatorInverseIterator&lt; TAlgebra &gt;::m_opInv</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a243919b70e4cbdb0959428a764d24ac5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a243919b70e4cbdb0959428a764d24ac5">&#9670;&nbsp;</a></span>m_name</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TAlgebra &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classug_1_1_operator_inverse_iterator.html">ug::OperatorInverseIterator</a>&lt; TAlgebra &gt;::m_name</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="classug_1_1_operator_inverse_iterator.html#a900e7f067f394a8e881acfd6bc8cc225">ug::OperatorInverseIterator&lt; TAlgebra &gt;::name()</a>, and <a class="el" href="classug_1_1_operator_inverse_iterator.html#a796b098df74d3d1c6f3b529648952500">ug::OperatorInverseIterator&lt; TAlgebra &gt;::OperatorInverseIterator()</a>.</p>

</div>
</div>
<a id="a5a7289e7f4be9c322e3f45afc3f00942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a7289e7f4be9c322e3f45afc3f00942">&#9670;&nbsp;</a></span>m_opInv</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TAlgebra &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt;<a class="el" href="classug_1_1_i_linear_operator_inverse.html">ILinearOperatorInverse</a>&lt;<a class="el" href="classug_1_1_operator_inverse_iterator.html#a09d5ffdb03a740beb3e066a4402f9fdd">vector_type</a>&gt; &gt; <a class="el" href="classug_1_1_operator_inverse_iterator.html">ug::OperatorInverseIterator</a>&lt; TAlgebra &gt;::m_opInv</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="classug_1_1_operator_inverse_iterator.html#a3cf43c14a05172189403d87946b9afed">ug::OperatorInverseIterator&lt; TAlgebra &gt;::apply()</a>, <a class="el" href="classug_1_1_operator_inverse_iterator.html#a6e5034ee1989d6e3281b75abe4ab5d69">ug::OperatorInverseIterator&lt; TAlgebra &gt;::apply_update_defect()</a>, <a class="el" href="classug_1_1_operator_inverse_iterator.html#a51356fc31ffde95d563fca76a6b1e554">ug::OperatorInverseIterator&lt; TAlgebra &gt;::init()</a>, <a class="el" href="classug_1_1_operator_inverse_iterator.html#a796b098df74d3d1c6f3b529648952500">ug::OperatorInverseIterator&lt; TAlgebra &gt;::OperatorInverseIterator()</a>, and <a class="el" href="classug_1_1_operator_inverse_iterator.html#a34a5f6fbb44aec1dd1f97b6fd009ed2a">ug::OperatorInverseIterator&lt; TAlgebra &gt;::supports_parallel()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>ugbase/lib_algebra/operator/preconditioner/<a class="el" href="operator__inverse__iterator_8h_source.html">operator_inverse_iterator.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceug.html">ug</a></li><li class="navelem"><a class="el" href="classug_1_1_operator_inverse_iterator.html">OperatorInverseIterator</a></li>
    <li class="footer">Generated on Mon Aug 28 2023 00:53:22 for ug4 by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
