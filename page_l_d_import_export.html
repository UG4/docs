<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ug4: Data Import / Data Export</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ug4
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('page_l_d_import_export.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Data Import / Data Export </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This page gives an introduction to the idea of the import/export/linker idea used in ug to couple several discretizations.</p>
<ul>
<li><a class="el" href="page_l_d_import_export.html#secPreliminaries">Preliminaries</a></li>
<li><a class="el" href="page_l_d_import_export.html#secImport">Import</a></li>
<li><a class="el" href="page_l_d_import_export.html#secComputationJacobian">Computation of Jacobian</a></li>
<li><a class="el" href="page_l_d_user_data.html#secUserData">UserData</a></li>
<li><a class="el" href="page_l_d_import_export.html#secExport">Export</a></li>
<li><a class="el" href="page_l_d_import_export.html#secLinker">Linker</a></li>
</ul>
<p><br  />
</p>
<hr  />
 <h1><a class="anchor" id="secPreliminaries"></a>
Preliminaries</h1>
<hr  />
<p>Assume, the whole problem can be logically partitioned into some smaller problems. (The partition may not be unique, several possibilities may be thinkable. Then, the following strategy is applicable to every possibility). This smaller parts of the whole problem are called <b>systems</b>. Let \(n_{sys}\) be the number of systems. Assume, that the numerical solution can be partitioned in the same way into subsolutions, that are related to exactly one system, i.e. one can find a splitting of the whole solution like </p><p class="formulaDsp">
\[ \vec{u} = \bigotimes_{s=1}^{n_{sys}} \vec{u}^s \]
</p>
<p> where we have some index set \( I_s \) to describe the unknowns of the part of the solution belonging to system \(s\). One may say informally, that system \( s \) "owns" its unknown solution \( \vec{u}^s\).</p>
<p>Lets introduce some numbers: </p><ul>
<li>
\(N_s := |I_s|\): number of unknowns of system s </li>
<li>
\(N := |\bigotimes\limits_{s=1}^{n_{sys}}I_s| = \sum\limits_{s=1}^{n_{sys}} N_s\): number of all unknowns </li>
</ul>
<p>Thus, the vector \(\vec{u}\) is build up by \(N\) scalar values, while each of the subsolutions \( \vec{u}^s \) has \( N_s\) scalar entries, i.e. for every \( i \in I \) one finds \( \vec{u}_i \in \mathbb{R}\), and for every \( i \in I_s\) one has \( \vec{u}^s_i \in \mathbb{R}\).</p>
<p>In the common discretization schemes, one usually computes a defect, that uses the same index set \( I \) as the solution, since then the resulting linear system matrix is quadratic (and hopefully invertible).</p>
<p>Therefore, lets assume to have a discretization producing \( N \) discrete equations. We can group those equation to one vector called defect, that must be equal to zero, if a solution has been found. Formally, we write</p>
<p class="formulaDsp">
\begin{align*} \vec{d}(\vec{u}): \mathbb{R}^N &amp;\mapsto \mathbb{R}^N, \\ J(\vec{u}): \mathbb{R}^N &amp;\mapsto \mathbb{R}^{N \times N}. \end{align*}
</p>
<p> Here, we already introduced the jacobian matrix, which is the derivative of the defect with respect to the unknown solution, i.e. each entry of the jacobian is given by </p><p class="formulaDsp">
\[ J(\vec{u})_{ij} := \frac{\partial \vec{d}_i}{\partial \vec{u}_j}. \]
</p>
<p>Using the partition of the index set into the index sets of the systems, one can again split the defect into its system components: </p><p class="formulaDsp">
\[ \vec{d}(\vec{u}) = \bigotimes_{s=1}^{n_{sys}} \vec{d}^s(\vec{u}), \]
</p>
<p> and the same holds for the jacobian matrix </p><p class="formulaDsp">
\[ J(\vec{u}) = \bigotimes_{s=1}^{n_{sys}} \bigotimes_{t=1}^{n_{sys}} J^{st}(\vec{u}), \]
</p>
<p> where we introduced a abbreviation for the inter-system jacobian </p><p class="formulaDsp">
\begin{align*} J^{st}(\vec{u}) &amp;:= \frac{\partial \vec{d}^s}{\partial \vec{u}^t},\\ J^{st}(\vec{u})_{ij} &amp;:= \frac{\partial \vec{d}^s_i}{\partial \vec{u}^t_j}. \end{align*}
</p>
<hr  />
 <h1><a class="anchor" id="secImport"></a>
Import</h1>
<hr  />
<p>Up till now, there has been no restriction of the dependency of the defect to the unknown solutions. Now, we make the strong assumption, that the defect related to system \( s\) does explicitly only depend on the subsolution \( \vec{u}^s \). It may, however, depend implicitly on the whole solution \( \vec{u} \). This implicit dependency is realized by the use of objects called <b>imports</b>. The most important task of an import is to compute data of some c++-type at some given integration points and some time step. In the following we denote the c++-type by \( \mathcal{D}\) and assume, that this type is isomorph to the \( \mathbb{R}^m\) (typically, this type is a scalar, a vector ot some matrix). Thus, the Import can be described by </p><p class="formulaDsp">
\begin{align*} \mathcal{I}: \mathbb{R}^d \times \mathbb{R} \times \mathbb{R}^{N_1} \times \dots \times \mathbb{R}^{N_{n_{sys}}} &amp;\mapsto \mathcal{D} \\ \vec{x}, t, \vec{u}^1, \dots, \vec{u}^{n_{sys}} &amp;\mapsto \mathcal{I}(\vec{x}, t, \vec{u}^1, \dots, \vec{u}^{n_{sys}}) \end{align*}
</p>
<p> Note, that we assume that the import can and may depend on all subsolution. The strong assumption on the explicit dependency of the defect on its own solution can now be expressed as </p><p class="formulaDsp">
\[ \vec{d}^s \equiv \vec{d}^s(\vec{u}^s, \mathcal{I}^s_1, \dots, \mathcal{I}^s_{n_{\mathcal{I}^s}}), \]
</p>
<p> if we assume that system \(s\) has \(n_{\mathcal{I}^s}\) imports.</p>
<hr  />
 <h1><a class="anchor" id="secComputationJacobian"></a>
Computation of Jacobian</h1>
<hr  />
<p>A second main task of the import facility is the computation of the jacobian. By use of the splitting of the defect and the solution into the systems, one can compute the jacobian parts as follows: </p><p class="formulaDsp">
\begin{align*} J^{ss}(\vec{u}) &amp;= \left. \frac{\partial \vec{d}^s}{\partial \vec{u}^s} \right|_{\vec{u}} + \sum_{k=1}^{n_{\mathcal{I}^s}} \left. \frac{\partial \vec{d}^s}{\partial \mathcal{I}^s_k} \right|_{\vec{u}} \cdot \left. \frac{\partial \mathcal{I}^s_k} {\partial \vec{u}^s} \right|_{\vec{u}}\\ J^{st}(\vec{u}) &amp;= \sum_{k=1}^{n_{\mathcal{I}^s}} \left. \frac{\partial \vec{d}^s}{\partial \mathcal{I}^s_k} \right|_{\vec{u}} \cdot \left. \frac{\partial \mathcal{I}^s_k} {\partial \vec{u}^t} \right|_{\vec{u}} \end{align*}
</p>
<p>The expression </p><p class="formulaDsp">
\begin{align*} \left. \frac{\partial \vec{d}^s}{\partial \vec{u}^s} \right|_{\vec{u}} := \left. \frac{\partial \vec{d}^s(\vec{v}^s, \mathcal{I}^s_1(\vec{u}), \dots, \mathcal{I}^s_{n_{\mathcal{I}^s}}(\vec{u})))} {\partial \vec{v}^s} \right|_{\vec{v}^s = \vec{u}^s} \end{align*}
</p>
<p>is the derivative of the system defect w.r.t. to its own unknowns and can thus be computed by the system \(s\) itself, once all values of the data imports have been computed. Thus, a general strategy must be to first compute the values of the imports and then use this values to compute the system-local defect and the system-local jacobian.</p>
<p>Second, we find the expression </p><p class="formulaDsp">
\begin{align*} \left. \frac{\partial \vec{d}^s}{\partial \mathcal{I}^s_k} \right|_{\vec{u}} := \left. \frac{\partial \vec{d}^s(\vec{u}^s, \mathcal{I}^s_1(\vec{u}), \dots, \tilde{\mathcal{I}}^s_k, \dots, \mathcal{I}^s_{n_{\mathcal{I}^s}}(\vec{u}))} {\partial \tilde{\mathcal{I}}^s_k} \right|_{\tilde{\mathcal{I}}^s_k = \mathcal{I}^s_k(\vec{u})} \end{align*}
</p>
<p> which is the linearization of the defect w.r.t. the \(k\)-th import of the system \(s\). Please note, that all informations to compute these linearization is known by system \(s\) and thus this system can compute the values without any knowledge to the other systems, once the values of the imports are given. Thus, a general strategy must be to first compute the values of all imports and then to compute the linearizations of the defect w.r.t. the imports. Also it is important to note, that the data type of </p><p class="formulaDsp">
\begin{align*} \frac{\partial \vec{d}^s_i}{\partial \mathcal{I}^s_k} \end{align*}
</p>
<p> can also be represented by the c++-type \(\mathcal{D}\) of the import.</p>
<p>Finally, we find the expression </p><p class="formulaDsp">
\begin{align*} \left. \frac{\partial \mathcal{I}^s_k} {\partial \vec{u}^t} \right|_{\vec{u}} := \left. \frac{\partial \mathcal{I}^s_k(\vec{u}^1, \dots, \vec{v}^t, \dots, \vec{u}^{n_{sys}})} {\partial \vec{v}^t} \right|_{\vec{v}^t = \vec{u}^t} \end{align*}
</p>
<p> which is the derivative of the import data w.r.t. to the unknown solution. Here, we can have a non-zero derivative to any subsolution. Please note, that again the expression </p><p class="formulaDsp">
\begin{align*} \frac{\partial \mathcal{I}^s_k}{\partial \vec{u}^t_j} \end{align*}
</p>
<p> can be represented by the c++-type \(\mathcal{D}\) of the import. This derivative is not known to the system \(s\) at all. We will see in the following, where these data can be computed.</p>
<p>However, note that once the needed components are given we can compute the contribution to the jacobian by </p><p class="formulaDsp">
\begin{align*} J^{st}(\vec{u})_{ij} = \sum_{k=1}^{n_{\mathcal{I}^s}} \left. \frac{\partial \vec{d}^s_i}{\partial \mathcal{I}^s_k} \right|_{\vec{u}} \cdot \left. \frac{\partial \mathcal{I}^s_k} {\partial \vec{u}^t_j} \right|_{\vec{u}} \end{align*}
</p>
<p> as long as the data type \(\mathcal{D}\) of the each import implements a scalar product.</p>
<hr  />
 <h1><a class="anchor" id="secUserData"></a>
UserData</h1>
<hr  />
<p>The base class for the computation of the values and derivatives needed by the imports is called UserData, and we will denote them by \(\mathcal{E}\) since they "export" data. A data export is plugged into a data import in order to indicate, that the data produced by the export should be used as the import. One may think that in the forementioned formulas each import must be replaced by an export.</p>
<p>We distinguish different kinds of UserData:</p>
<ul>
<li>
constant data: \( \mathcal{E} \equiv \mathcal{E}()\). </li>
<li>
position dependent data: \( \mathcal{E} \equiv \mathcal{E}(\vec{x},t)\) </li>
<li>
system exports: \( \mathcal{E} \equiv \mathcal{E}(\vec{x}, t, \vec{u}^s)\) </li>
<li>
linker: \( \mathcal{E} \equiv \mathcal{E}(\vec{x}, t, \vec{u}^1, \dots, \vec{u}^{n_{sys}})\) </li>
</ul>
<p>The first two have a zero-derivative. Thus, in a general strategy their derivatives should not be computed and the loop over these exports are skipped in the computation of the jacobian. The last two kinds are now discussed in more detail.</p>
<hr  />
 <h1><a class="anchor" id="secExport"></a>
Export</h1>
<hr  />
<p>The system exports compute data at requested points based on their own subsolution. For example, a data export may be the subsolution itself or its derivative, but also more complicated expressions involving the solution are possible. In general these exports can be thought to be evaluation like </p><p class="formulaDsp">
\begin{align*} \mathcal{E}: \mathbb{R}^d \times \mathbb{R} \times \mathbb{R}^{N_s} &amp;\mapsto \mathcal{D}, \\ \vec{x}, t, \vec{u}^s &amp;\mapsto \mathcal{E}(\vec{x}, t, \vec{u}^s). \end{align*}
</p>
<p> Note, that the system \(s\) does also know the derivative of the data w.r.t. to the unknows. However, an export may need data from other imports in order to compute the data. Thus a general strategy would be to first compute the data the export depends on and then compute the data and the derivative of the data in case of a jacobian. Of course, circle dependencies of the exports are not allowed.</p>
<hr  />
 <h1><a class="anchor" id="secLinker"></a>
Linker</h1>
<hr  />
<p>A linker is user data, that is computed by combining other user datas. Thus, it does not create any data, but connects (links) the data. A linker is an user data; just to emphasize the difference between the other user data and a linker we will use the denotation \(\mathcal{L}\) for the linker.</p>
<p class="formulaDsp">
\begin{align*} \mathcal{L}: \mathcal{D}_1 \times \dots \times \mathcal{D}_{n_{\mathcal{L}}} &amp;\mapsto \mathcal{D}, \\ \mathcal{E}_1, \dots, \mathcal{E}_{n_{\mathcal{L}}} &amp;\mapsto \mathcal{L}(\mathcal{E}_1, \dots, \mathcal{E}_{n_{\mathcal{L}}} ). \end{align*}
</p>
<p> Note, that a linker must therefore be able to combine different c++-types to form a new one.</p>
<p>The linker must also compute the derivative of the data w.r.t. the unknowns. This can be done using </p><p class="formulaDsp">
\begin{align*} \left. \frac{\partial \mathcal{L}}{\partial \vec{u}^t} \right|_{\vec{u}} = \sum\limits_{k=1}^{n_{\mathcal{L}}} \left. \frac{\partial \mathcal{L}}{\partial \mathcal{I}_k} \right|_{\vec{u}} \cdot \left. \frac{\partial \mathcal{I}_k}{\partial \vec{u}^t} \right|_{\vec{u}} \end{align*}
</p>
 </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">ug4 - Documentation</a></li><li class="navelem"><a class="el" href="page_u_g4_development.html">Development</a></li><li class="navelem"><a class="el" href="page_l_d_introduction.html">libDiscretization</a></li><li class="navelem"><a class="el" href="page_l_d_user_data.html">UserData</a></li>
    <li class="footer">Generated on Mon Sep 11 2023 00:53:51 for ug4 by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
