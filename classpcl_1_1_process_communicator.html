<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ug4: pcl::ProcessCommunicator Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ug4
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classpcl_1_1_process_communicator.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classpcl_1_1_process_communicator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pcl::ProcessCommunicator Class Reference<div class="ingroups"><a class="el" href="group__ugbase.html">ugbase</a> &raquo; <a class="el" href="group__pcl.html">PCL</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="pcl__process__communicator_8h_source.html">pcl_process_communicator.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_process_communicator_1_1_comm_wrapper.html">CommWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">holds an mpi-communicator.  <a href="structpcl_1_1_process_communicator_1_1_comm_wrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae6d7c776f504bd965d55ccb029c2d806"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_process_communicator.html#ae6d7c776f504bd965d55ccb029c2d806">allgather</a> (const void *sendBuf, int sendCount, <a class="el" href="group__pcl.html#ga0a4745c93f155cc512175ca74c049c6c">DataType</a> sendType, void *recBuf, int recCount, <a class="el" href="group__pcl.html#ga0a4745c93f155cc512175ca74c049c6c">DataType</a> recType) const</td></tr>
<tr class="memdesc:ae6d7c776f504bd965d55ccb029c2d806"><td class="mdescLeft">&#160;</td><td class="mdescRight">performs MPI_Allgather on the processes of the communicator.  <a href="classpcl_1_1_process_communicator.html#ae6d7c776f504bd965d55ccb029c2d806">More...</a><br /></td></tr>
<tr class="separator:ae6d7c776f504bd965d55ccb029c2d806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9baaf8a77c83c3e17c33f8c2fd5a17b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_process_communicator.html#ab9baaf8a77c83c3e17c33f8c2fd5a17b">allgather</a> (<a class="el" href="classug_1_1_binary_buffer.html">ug::BinaryBuffer</a> &amp;buf) const</td></tr>
<tr class="separator:ab9baaf8a77c83c3e17c33f8c2fd5a17b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa38044c228d1e78069a704877e9e48e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_process_communicator.html#aa38044c228d1e78069a704877e9e48e2">allgatherv</a> (const void *sendBuf, int sendCount, <a class="el" href="group__pcl.html#ga0a4745c93f155cc512175ca74c049c6c">DataType</a> sendType, void *recBuf, int *recCounts, int *displs, <a class="el" href="group__pcl.html#ga0a4745c93f155cc512175ca74c049c6c">DataType</a> recType) const</td></tr>
<tr class="memdesc:aa38044c228d1e78069a704877e9e48e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">performs MPI_Allgatherv on the processes of the communicator.  <a href="classpcl_1_1_process_communicator.html#aa38044c228d1e78069a704877e9e48e2">More...</a><br /></td></tr>
<tr class="separator:aa38044c228d1e78069a704877e9e48e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bee065c42d30fb67fed65e70e5c534b"><td class="memTemplParams" colspan="2">template&lt;class TValue &gt; </td></tr>
<tr class="memitem:a3bee065c42d30fb67fed65e70e5c534b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpcl_1_1_process_communicator.html#a3bee065c42d30fb67fed65e70e5c534b">allgatherv</a> (std::vector&lt; TValue &gt; &amp;recBufOut, std::vector&lt; TValue &gt; &amp;sendBuf, std::vector&lt; int &gt; *pSizesOut=NULL, std::vector&lt; int &gt; *pOffsetsOut=NULL) const</td></tr>
<tr class="memdesc:a3bee065c42d30fb67fed65e70e5c534b"><td class="mdescLeft">&#160;</td><td class="mdescRight">gathers variable arrays on all processes.  <a href="classpcl_1_1_process_communicator.html#a3bee065c42d30fb67fed65e70e5c534b">More...</a><br /></td></tr>
<tr class="separator:a3bee065c42d30fb67fed65e70e5c534b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e3264c8d8f00d75bd899a8ea39b0e01"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_process_communicator.html#a1e3264c8d8f00d75bd899a8ea39b0e01">allreduce</a> (const size_t &amp;t, <a class="el" href="group__pcl.html#ga774ab56d0811cccca811df2e62bc0939">pcl::ReduceOperation</a> op) const</td></tr>
<tr class="memdesc:a1e3264c8d8f00d75bd899a8ea39b0e01"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload for size_t  <a href="classpcl_1_1_process_communicator.html#a1e3264c8d8f00d75bd899a8ea39b0e01">More...</a><br /></td></tr>
<tr class="separator:a1e3264c8d8f00d75bd899a8ea39b0e01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac4b53c26605c7fe9683bfe6c9fe4e1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9ac4b53c26605c7fe9683bfe6c9fe4e1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpcl_1_1_process_communicator.html#a9ac4b53c26605c7fe9683bfe6c9fe4e1">allreduce</a> (const std::vector&lt; T &gt; &amp;send, std::vector&lt; T &gt; &amp;receive, <a class="el" href="group__pcl.html#ga774ab56d0811cccca811df2e62bc0939">pcl::ReduceOperation</a> op) const</td></tr>
<tr class="separator:a9ac4b53c26605c7fe9683bfe6c9fe4e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0f8d02f2ab0c2795d2174f158f21da6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac0f8d02f2ab0c2795d2174f158f21da6"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpcl_1_1_process_communicator.html#ac0f8d02f2ab0c2795d2174f158f21da6">allreduce</a> (const T &amp;t, <a class="el" href="group__pcl.html#ga774ab56d0811cccca811df2e62bc0939">pcl::ReduceOperation</a> op) const</td></tr>
<tr class="separator:ac0f8d02f2ab0c2795d2174f158f21da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3522849924039e28fecaa8ad0f074c7f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3522849924039e28fecaa8ad0f074c7f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpcl_1_1_process_communicator.html#a3522849924039e28fecaa8ad0f074c7f">allreduce</a> (const T *pSendBuff, T *pReceiveBuff, size_t count, <a class="el" href="group__pcl.html#ga774ab56d0811cccca811df2e62bc0939">pcl::ReduceOperation</a> op) const</td></tr>
<tr class="separator:a3522849924039e28fecaa8ad0f074c7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a708b02efa2d765daae9fee02b7b60000"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_process_communicator.html#a708b02efa2d765daae9fee02b7b60000">allreduce</a> (const void *sendBuf, void *recBuf, int count, <a class="el" href="group__pcl.html#ga0a4745c93f155cc512175ca74c049c6c">DataType</a> type, <a class="el" href="group__pcl.html#ga774ab56d0811cccca811df2e62bc0939">ReduceOperation</a> op) const</td></tr>
<tr class="memdesc:a708b02efa2d765daae9fee02b7b60000"><td class="mdescLeft">&#160;</td><td class="mdescRight">performs MPI_Allreduce on the processes of the communicator.  <a href="classpcl_1_1_process_communicator.html#a708b02efa2d765daae9fee02b7b60000">More...</a><br /></td></tr>
<tr class="separator:a708b02efa2d765daae9fee02b7b60000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e0460aac9629b04410f3fd3eba66400"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_process_communicator.html#a3e0460aac9629b04410f3fd3eba66400">alltoall</a> (const void *sendBuf, int sendCount, <a class="el" href="group__pcl.html#ga0a4745c93f155cc512175ca74c049c6c">DataType</a> sendType, void *recBuf, int recCount, <a class="el" href="group__pcl.html#ga0a4745c93f155cc512175ca74c049c6c">DataType</a> recType)</td></tr>
<tr class="memdesc:a3e0460aac9629b04410f3fd3eba66400"><td class="mdescLeft">&#160;</td><td class="mdescRight">performs MPI_Alltoall on the processes of the communicator.  <a href="classpcl_1_1_process_communicator.html#a3e0460aac9629b04410f3fd3eba66400">More...</a><br /></td></tr>
<tr class="separator:a3e0460aac9629b04410f3fd3eba66400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38a24e38e98554501ecffaa578af58ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_process_communicator.html#a38a24e38e98554501ecffaa578af58ee">barrier</a> () const</td></tr>
<tr class="memdesc:a38a24e38e98554501ecffaa578af58ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">this method will not return until all processes in the communicator have called it.  <a href="classpcl_1_1_process_communicator.html#a38a24e38e98554501ecffaa578af58ee">More...</a><br /></td></tr>
<tr class="separator:a38a24e38e98554501ecffaa578af58ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bccccdb8419d780bfe8535a526c9da8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_process_communicator.html#a7bccccdb8419d780bfe8535a526c9da8">broadcast</a> (size_t &amp;<a class="elRef" href="../plugins/_biogas_8lua.html#a9dda901d5ee6289370201a700f88e789">s</a>, int root=0) const</td></tr>
<tr class="memdesc:a7bccccdb8419d780bfe8535a526c9da8"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload for size_t  <a href="classpcl_1_1_process_communicator.html#a7bccccdb8419d780bfe8535a526c9da8">More...</a><br /></td></tr>
<tr class="separator:a7bccccdb8419d780bfe8535a526c9da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a1859052f80964617f7de2312b31feb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8a1859052f80964617f7de2312b31feb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpcl_1_1_process_communicator.html#a8a1859052f80964617f7de2312b31feb">broadcast</a> (T &amp;t, int root, <a class="el" href="classpcl_1_1_data_type_directly_supported.html">DataTypeDirectlySupported</a> d) const</td></tr>
<tr class="memdesc:a8a1859052f80964617f7de2312b31feb"><td class="mdescLeft">&#160;</td><td class="mdescRight">broadcast function for directly supported types  <a href="classpcl_1_1_process_communicator.html#a8a1859052f80964617f7de2312b31feb">More...</a><br /></td></tr>
<tr class="separator:a8a1859052f80964617f7de2312b31feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19b0968b431a6dab69c6f2ec95c8d366"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a19b0968b431a6dab69c6f2ec95c8d366"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpcl_1_1_process_communicator.html#a19b0968b431a6dab69c6f2ec95c8d366">broadcast</a> (T &amp;t, int root, <a class="el" href="classpcl_1_1_data_type_indirectly_supported.html">DataTypeIndirectlySupported</a> d) const</td></tr>
<tr class="memdesc:a19b0968b431a6dab69c6f2ec95c8d366"><td class="mdescLeft">&#160;</td><td class="mdescRight">broadcast function for indirectly supported types (using Serialize/Deserialize)  <a href="classpcl_1_1_process_communicator.html#a19b0968b431a6dab69c6f2ec95c8d366">More...</a><br /></td></tr>
<tr class="separator:a19b0968b431a6dab69c6f2ec95c8d366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac885420ebe9d64678e84d597b953f7d3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac885420ebe9d64678e84d597b953f7d3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpcl_1_1_process_communicator.html#ac885420ebe9d64678e84d597b953f7d3">broadcast</a> (T &amp;t, int root=0) const</td></tr>
<tr class="separator:ac885420ebe9d64678e84d597b953f7d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5155ae618f8fe76850b33760a7c80505"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5155ae618f8fe76850b33760a7c80505"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpcl_1_1_process_communicator.html#a5155ae618f8fe76850b33760a7c80505">broadcast</a> (T *<a class="elRef" href="../plugins/_biogas_8lua.html#a57f1028d958bb73c4e3c64e2077342fc">p</a>, size_t <a class="el" href="classpcl_1_1_process_communicator.html#a71686860dd00b51ca298088864f76417">size</a>=1, int root=0) const</td></tr>
<tr class="separator:a5155ae618f8fe76850b33760a7c80505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58fc01ab1c2361e18b0692972dc5bc8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_process_communicator.html#a58fc01ab1c2361e18b0692972dc5bc8a">broadcast</a> (<a class="el" href="classug_1_1_binary_buffer.html">ug::BinaryBuffer</a> &amp;buf, int root=0) const</td></tr>
<tr class="separator:a58fc01ab1c2361e18b0692972dc5bc8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa219e509eaef84ff08865ccd5ca409c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_process_communicator.html#aa219e509eaef84ff08865ccd5ca409c5">broadcast</a> (void *v, size_t <a class="el" href="classpcl_1_1_process_communicator.html#a71686860dd00b51ca298088864f76417">size</a>, <a class="el" href="group__pcl.html#ga0a4745c93f155cc512175ca74c049c6c">DataType</a> type, int root=0) const</td></tr>
<tr class="separator:aa219e509eaef84ff08865ccd5ca409c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9280593c63193e1a3f5a7b85419c31a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_process_communicator.html">ProcessCommunicator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_process_communicator.html#ab9280593c63193e1a3f5a7b85419c31a">create_sub_communicator</a> (bool participate) const</td></tr>
<tr class="memdesc:ab9280593c63193e1a3f5a7b85419c31a"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a new communicator containing a subset of the current communicator  <a href="classpcl_1_1_process_communicator.html#ab9280593c63193e1a3f5a7b85419c31a">More...</a><br /></td></tr>
<tr class="separator:ab9280593c63193e1a3f5a7b85419c31a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af93712470b06d42fd4e5222415701927"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_process_communicator.html">ProcessCommunicator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_process_communicator.html#af93712470b06d42fd4e5222415701927">create_sub_communicator</a> (std::vector&lt; int &gt; &amp;newProcs) const</td></tr>
<tr class="separator:af93712470b06d42fd4e5222415701927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cea9e6a3075ff027571cef208d61f42"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_process_communicator.html#a8cea9e6a3075ff027571cef208d61f42">distribute_data</a> (<a class="el" href="classug_1_1_binary_buffer.html">ug::BinaryBuffer</a> &amp;recvBufOut, int *segSizesOut, int *recvFromRanks, int numRecvFroms, void *sendBuf, int *sendSegSizes, int *sendToRanks, int numSendTos, int tag=1) const</td></tr>
<tr class="memdesc:a8cea9e6a3075ff027571cef208d61f42"><td class="mdescLeft">&#160;</td><td class="mdescRight">sends and receives data to/from multiple processes  <a href="classpcl_1_1_process_communicator.html#a8cea9e6a3075ff027571cef208d61f42">More...</a><br /></td></tr>
<tr class="separator:a8cea9e6a3075ff027571cef208d61f42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3031101bb147f6d875549f897c7996f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_process_communicator.html#a3031101bb147f6d875549f897c7996f7">distribute_data</a> (<a class="el" href="classug_1_1_binary_buffer.html">ug::BinaryBuffer</a> *recvBufs, int *recvFromRanks, int numRecvs, <a class="el" href="classug_1_1_binary_buffer.html">ug::BinaryBuffer</a> *sendBufs, int *sendToRanks, int numSendTos, int tag=1) const</td></tr>
<tr class="memdesc:a3031101bb147f6d875549f897c7996f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">sends and receives data to/from multiple processes  <a href="classpcl_1_1_process_communicator.html#a3031101bb147f6d875549f897c7996f7">More...</a><br /></td></tr>
<tr class="separator:a3031101bb147f6d875549f897c7996f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8eec965d9be3c758db248c3ab063c92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_process_communicator.html#ad8eec965d9be3c758db248c3ab063c92">distribute_data</a> (void *pBufferOut, int *pBufferOutSegSizes, int *pSenderProcMap, int numSenderProcs, void *pBuffer, int *pBufferSegSizes, int *pRecvProcMap, int numRecvProcs, int tag=1) const</td></tr>
<tr class="memdesc:ad8eec965d9be3c758db248c3ab063c92"><td class="mdescLeft">&#160;</td><td class="mdescRight">sends and receives data to / from multiple processes.  <a href="classpcl_1_1_process_communicator.html#ad8eec965d9be3c758db248c3ab063c92">More...</a><br /></td></tr>
<tr class="separator:ad8eec965d9be3c758db248c3ab063c92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3884294afa70a363fc8529a1f08c3053"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_process_communicator.html#a3884294afa70a363fc8529a1f08c3053">empty</a> () const</td></tr>
<tr class="memdesc:a3884294afa70a363fc8529a1f08c3053"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if the communicator is empty, false if not.  <a href="classpcl_1_1_process_communicator.html#a3884294afa70a363fc8529a1f08c3053">More...</a><br /></td></tr>
<tr class="separator:a3884294afa70a363fc8529a1f08c3053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fcfbf45df86823b52fa0286a27539c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_process_communicator.html#a4fcfbf45df86823b52fa0286a27539c4">gather</a> (const void *sendBuf, int sendCount, <a class="el" href="group__pcl.html#ga0a4745c93f155cc512175ca74c049c6c">DataType</a> sendType, void *recBuf, int recCount, <a class="el" href="group__pcl.html#ga0a4745c93f155cc512175ca74c049c6c">DataType</a> recType, int root) const</td></tr>
<tr class="memdesc:a4fcfbf45df86823b52fa0286a27539c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">performs MPI_Gather on the processes of the communicator.  <a href="classpcl_1_1_process_communicator.html#a4fcfbf45df86823b52fa0286a27539c4">More...</a><br /></td></tr>
<tr class="separator:a4fcfbf45df86823b52fa0286a27539c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16f54e4a5dbc9be37f8add19295a5abe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_process_communicator.html#a16f54e4a5dbc9be37f8add19295a5abe">gather</a> (<a class="el" href="classug_1_1_binary_buffer.html">ug::BinaryBuffer</a> &amp;buf, int root=0) const</td></tr>
<tr class="separator:a16f54e4a5dbc9be37f8add19295a5abe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b8ffa08f3915dbae9f099d55ef4533d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_process_communicator.html#a5b8ffa08f3915dbae9f099d55ef4533d">gatherv</a> (const void *sendBuf, int sendCount, <a class="el" href="group__pcl.html#ga0a4745c93f155cc512175ca74c049c6c">DataType</a> sendType, void *recBuf, int *recCounts, int *displs, <a class="el" href="group__pcl.html#ga0a4745c93f155cc512175ca74c049c6c">DataType</a> recType, int root) const</td></tr>
<tr class="memdesc:a5b8ffa08f3915dbae9f099d55ef4533d"><td class="mdescLeft">&#160;</td><td class="mdescRight">performs MPI_Gatherv on the processes of the communicator.  <a href="classpcl_1_1_process_communicator.html#a5b8ffa08f3915dbae9f099d55ef4533d">More...</a><br /></td></tr>
<tr class="separator:a5b8ffa08f3915dbae9f099d55ef4533d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52bb8ff22163e2734f3420c0a57e8c77"><td class="memTemplParams" colspan="2">template&lt;class TValue &gt; </td></tr>
<tr class="memitem:a52bb8ff22163e2734f3420c0a57e8c77"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpcl_1_1_process_communicator.html#a52bb8ff22163e2734f3420c0a57e8c77">gatherv</a> (std::vector&lt; TValue &gt; &amp;recBufOut, std::vector&lt; TValue &gt; &amp;sendBuf, int root, std::vector&lt; int &gt; *pSizesOut=NULL, std::vector&lt; int &gt; *pOffsetsOut=NULL) const</td></tr>
<tr class="memdesc:a52bb8ff22163e2734f3420c0a57e8c77"><td class="mdescLeft">&#160;</td><td class="mdescRight">gathers variable arrays on one process.  <a href="classpcl_1_1_process_communicator.html#a52bb8ff22163e2734f3420c0a57e8c77">More...</a><br /></td></tr>
<tr class="separator:a52bb8ff22163e2734f3420c0a57e8c77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4d016ec21680cf611dbb0fc00269306"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_process_communicator.html#ae4d016ec21680cf611dbb0fc00269306">get_local_proc_id</a> (int globalProcID=<a class="el" href="group__pcl.html#ga319e84518e2b596fc9f9b40b4383ec36">pcl::ProcRank</a>()) const</td></tr>
<tr class="memdesc:ae4d016ec21680cf611dbb0fc00269306"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the proc-id relative to this communicator  <a href="classpcl_1_1_process_communicator.html#ae4d016ec21680cf611dbb0fc00269306">More...</a><br /></td></tr>
<tr class="separator:ae4d016ec21680cf611dbb0fc00269306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17e4ed6988d07c2682c713e79806ac66"><td class="memItemLeft" align="right" valign="top">MPI_Comm&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_process_communicator.html#a17e4ed6988d07c2682c713e79806ac66">get_mpi_communicator</a> () const</td></tr>
<tr class="memdesc:a17e4ed6988d07c2682c713e79806ac66"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the mpi-communicator, in case someone needs it  <a href="classpcl_1_1_process_communicator.html#a17e4ed6988d07c2682c713e79806ac66">More...</a><br /></td></tr>
<tr class="separator:a17e4ed6988d07c2682c713e79806ac66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee57f2d14bc6905066c814ce3030ed3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_process_communicator.html#a1ee57f2d14bc6905066c814ce3030ed3">get_proc_id</a> (size_t index) const</td></tr>
<tr class="memdesc:a1ee57f2d14bc6905066c814ce3030ed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the i-th process in the communicator  <a href="classpcl_1_1_process_communicator.html#a1ee57f2d14bc6905066c814ce3030ed3">More...</a><br /></td></tr>
<tr class="separator:a1ee57f2d14bc6905066c814ce3030ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3be8df02f7591a7fd79d2a16a27b85ff"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_process_communicator.html#a3be8df02f7591a7fd79d2a16a27b85ff">is_local</a> () const</td></tr>
<tr class="memdesc:a3be8df02f7591a7fd79d2a16a27b85ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">return true if the communicator is local, simulating current proc is the only proc  <a href="classpcl_1_1_process_communicator.html#a3be8df02f7591a7fd79d2a16a27b85ff">More...</a><br /></td></tr>
<tr class="separator:a3be8df02f7591a7fd79d2a16a27b85ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0598776412b0d684abc5505c9755bbfe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_process_communicator.html#a0598776412b0d684abc5505c9755bbfe">is_proc_id</a> (size_t index) const</td></tr>
<tr class="memdesc:a0598776412b0d684abc5505c9755bbfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if we are the i-th process in the communicator  <a href="classpcl_1_1_process_communicator.html#a0598776412b0d684abc5505c9755bbfe">More...</a><br /></td></tr>
<tr class="separator:a0598776412b0d684abc5505c9755bbfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50707e6de72a8865546e71249c87f256"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_process_communicator.html#a50707e6de72a8865546e71249c87f256">is_world</a> () const</td></tr>
<tr class="memdesc:a50707e6de72a8865546e71249c87f256"><td class="mdescLeft">&#160;</td><td class="mdescRight">return true if the communicator is PCD_WORLD  <a href="classpcl_1_1_process_communicator.html#a50707e6de72a8865546e71249c87f256">More...</a><br /></td></tr>
<tr class="separator:a50707e6de72a8865546e71249c87f256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdc3fd8c82aea49f94a94c06f0b66555"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_process_communicator.html#afdc3fd8c82aea49f94a94c06f0b66555">ProcessCommunicator</a> (<a class="el" href="group__pcl.html#gaea36d0e20ff31324ba10643d4e939e29">ProcessCommunicatorDefaults</a> pcd=<a class="el" href="group__pcl.html#ggaea36d0e20ff31324ba10643d4e939e29aa5c08b5ef97c6bd825508c3901b24c9f">PCD_WORLD</a>)</td></tr>
<tr class="memdesc:afdc3fd8c82aea49f94a94c06f0b66555"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a communicator.  <a href="classpcl_1_1_process_communicator.html#afdc3fd8c82aea49f94a94c06f0b66555">More...</a><br /></td></tr>
<tr class="separator:afdc3fd8c82aea49f94a94c06f0b66555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05092910cd2be254b90517b826f161dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_process_communicator.html#a05092910cd2be254b90517b826f161dc">receive_data</a> (void *pBuffOut, int bufferSize, int srcProc, int tag) const</td></tr>
<tr class="memdesc:a05092910cd2be254b90517b826f161dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">receives data from srcPrc with the specified tag.  <a href="classpcl_1_1_process_communicator.html#a05092910cd2be254b90517b826f161dc">More...</a><br /></td></tr>
<tr class="separator:a05092910cd2be254b90517b826f161dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc1278b823fde31e98bb40bb762c1d68"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_process_communicator.html#afc1278b823fde31e98bb40bb762c1d68">reduce</a> (const size_t &amp;t, <a class="el" href="group__pcl.html#ga774ab56d0811cccca811df2e62bc0939">pcl::ReduceOperation</a> op, int rootProc) const</td></tr>
<tr class="memdesc:afc1278b823fde31e98bb40bb762c1d68"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload for size_t  <a href="classpcl_1_1_process_communicator.html#afc1278b823fde31e98bb40bb762c1d68">More...</a><br /></td></tr>
<tr class="separator:afc1278b823fde31e98bb40bb762c1d68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76ef6e0acca1ed086c6637fd2a5038f0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a76ef6e0acca1ed086c6637fd2a5038f0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpcl_1_1_process_communicator.html#a76ef6e0acca1ed086c6637fd2a5038f0">reduce</a> (const std::vector&lt; T &gt; &amp;send, std::vector&lt; T &gt; &amp;receive, <a class="el" href="group__pcl.html#ga774ab56d0811cccca811df2e62bc0939">pcl::ReduceOperation</a> op, int rootProc) const</td></tr>
<tr class="separator:a76ef6e0acca1ed086c6637fd2a5038f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64dc03b878f29fadd43841940c6c5d2b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a64dc03b878f29fadd43841940c6c5d2b"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpcl_1_1_process_communicator.html#a64dc03b878f29fadd43841940c6c5d2b">reduce</a> (const T &amp;t, <a class="el" href="group__pcl.html#ga774ab56d0811cccca811df2e62bc0939">pcl::ReduceOperation</a> op, int rootProc) const</td></tr>
<tr class="separator:a64dc03b878f29fadd43841940c6c5d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc4017d78ba768577776b939bd6ca5e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8bc4017d78ba768577776b939bd6ca5e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpcl_1_1_process_communicator.html#a8bc4017d78ba768577776b939bd6ca5e">reduce</a> (const T *pSendBuff, T *pReceiveBuff, size_t count, <a class="el" href="group__pcl.html#ga774ab56d0811cccca811df2e62bc0939">pcl::ReduceOperation</a> op, int rootProc) const</td></tr>
<tr class="separator:a8bc4017d78ba768577776b939bd6ca5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c801054145d47043b1b43469374f53f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_process_communicator.html#a4c801054145d47043b1b43469374f53f">reduce</a> (const void *sendBuf, void *recBuf, int count, <a class="el" href="group__pcl.html#ga0a4745c93f155cc512175ca74c049c6c">DataType</a> type, <a class="el" href="group__pcl.html#ga774ab56d0811cccca811df2e62bc0939">ReduceOperation</a> op, int rootProc) const</td></tr>
<tr class="memdesc:a4c801054145d47043b1b43469374f53f"><td class="mdescLeft">&#160;</td><td class="mdescRight">performs MPI_Reduce on the processes of the communicator.  <a href="classpcl_1_1_process_communicator.html#a4c801054145d47043b1b43469374f53f">More...</a><br /></td></tr>
<tr class="separator:a4c801054145d47043b1b43469374f53f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a871a5c6031d12beeab7a2eb28c347609"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_process_communicator.html#a871a5c6031d12beeab7a2eb28c347609">scatter</a> (const void *sendBuf, int sendCount, <a class="el" href="group__pcl.html#ga0a4745c93f155cc512175ca74c049c6c">DataType</a> sendType, void *recBuf, int recCount, <a class="el" href="group__pcl.html#ga0a4745c93f155cc512175ca74c049c6c">DataType</a> recType, int root) const</td></tr>
<tr class="memdesc:a871a5c6031d12beeab7a2eb28c347609"><td class="mdescLeft">&#160;</td><td class="mdescRight">performs MPI_Scatter on the processes of the communicator  <a href="classpcl_1_1_process_communicator.html#a871a5c6031d12beeab7a2eb28c347609">More...</a><br /></td></tr>
<tr class="separator:a871a5c6031d12beeab7a2eb28c347609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add034ef451a1099e427a05c64650b928"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_process_communicator.html#add034ef451a1099e427a05c64650b928">send_data</a> (void *pBuffer, int *pBufferSegSizes, int *pRecProcMap, int numRecProcs, int tag) const</td></tr>
<tr class="memdesc:add034ef451a1099e427a05c64650b928"><td class="mdescLeft">&#160;</td><td class="mdescRight">sends data in different blocks of pBuffer to the processes in pRecProcMap.  <a href="classpcl_1_1_process_communicator.html#add034ef451a1099e427a05c64650b928">More...</a><br /></td></tr>
<tr class="separator:add034ef451a1099e427a05c64650b928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38c3135b38428345ff55c2f77636dc6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_process_communicator.html#a38c3135b38428345ff55c2f77636dc6c">send_data</a> (void *pBuffer, int bufferSize, int destProc, int tag) const</td></tr>
<tr class="memdesc:a38c3135b38428345ff55c2f77636dc6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">sends data with the given tag to the specified process.  <a href="classpcl_1_1_process_communicator.html#a38c3135b38428345ff55c2f77636dc6c">More...</a><br /></td></tr>
<tr class="separator:a38c3135b38428345ff55c2f77636dc6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71686860dd00b51ca298088864f76417"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_process_communicator.html#a71686860dd00b51ca298088864f76417">size</a> () const</td></tr>
<tr class="memdesc:a71686860dd00b51ca298088864f76417"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the size of the communicator  <a href="classpcl_1_1_process_communicator.html#a71686860dd00b51ca298088864f76417">More...</a><br /></td></tr>
<tr class="separator:a71686860dd00b51ca298088864f76417"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a1ab7c861d3d2ba66df6f993538730335"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classpcl_1_1_process_communicator.html">ProcessCommunicator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_process_communicator.html#a1ab7c861d3d2ba66df6f993538730335">create_communicator</a> (std::vector&lt; int &gt; &amp;newGlobalProcs)</td></tr>
<tr class="separator:a1ab7c861d3d2ba66df6f993538730335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a487b3598828bda6cad9295d09c9b6c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classpcl_1_1_process_communicator.html">ProcessCommunicator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_process_communicator.html#a1a487b3598828bda6cad9295d09c9b6c">create_communicator</a> (size_t first, size_t num)</td></tr>
<tr class="separator:a1a487b3598828bda6cad9295d09c9b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:ae690206ce86e0af9c5739008aa5bd096"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="structpcl_1_1_process_communicator_1_1_comm_wrapper.html">CommWrapper</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_process_communicator.html#ae690206ce86e0af9c5739008aa5bd096">SPCommWrapper</a></td></tr>
<tr class="memdesc:ae690206ce86e0af9c5739008aa5bd096"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart-pointer that encapsulates a <a class="el" href="structpcl_1_1_process_communicator_1_1_comm_wrapper.html" title="holds an mpi-communicator.">CommWrapper</a>.  <a href="classpcl_1_1_process_communicator.html#ae690206ce86e0af9c5739008aa5bd096">More...</a><br /></td></tr>
<tr class="separator:ae690206ce86e0af9c5739008aa5bd096"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a02a2e0dc57c2fedbba3fff6e455948f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_process_communicator.html#ae690206ce86e0af9c5739008aa5bd096">SPCommWrapper</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_process_communicator.html#a02a2e0dc57c2fedbba3fff6e455948f1">m_comm</a></td></tr>
<tr class="memdesc:a02a2e0dc57c2fedbba3fff6e455948f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">smart-pointer to an instance of a <a class="el" href="structpcl_1_1_process_communicator_1_1_comm_wrapper.html" title="holds an mpi-communicator.">CommWrapper</a>.  <a href="classpcl_1_1_process_communicator.html#a02a2e0dc57c2fedbba3fff6e455948f1">More...</a><br /></td></tr>
<tr class="separator:a02a2e0dc57c2fedbba3fff6e455948f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A <a class="el" href="classpcl_1_1_process_communicator.html">ProcessCommunicator</a> is a very lightweight object that can be passed by value. Creation using the constructor is a lightweight operation too. Creating a new communicator using create_sub_communicator however requires communication and thus shouldn't be unnecessarily called.</p>
<p>Please note that ProcessCommunicators created on different processes via create_sub_communicator(...) should be deleted at the same time - even if the creating processes are not part of the communicator. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ae690206ce86e0af9c5739008aa5bd096"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae690206ce86e0af9c5739008aa5bd096">&#9670;&nbsp;</a></span>SPCommWrapper</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt;<a class="el" href="structpcl_1_1_process_communicator_1_1_comm_wrapper.html">CommWrapper</a>&gt; <a class="el" href="classpcl_1_1_process_communicator.html#ae690206ce86e0af9c5739008aa5bd096">pcl::ProcessCommunicator::SPCommWrapper</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Smart-pointer that encapsulates a <a class="el" href="structpcl_1_1_process_communicator_1_1_comm_wrapper.html" title="holds an mpi-communicator.">CommWrapper</a>. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="afdc3fd8c82aea49f94a94c06f0b66555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdc3fd8c82aea49f94a94c06f0b66555">&#9670;&nbsp;</a></span>ProcessCommunicator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pcl::ProcessCommunicator::ProcessCommunicator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__pcl.html#gaea36d0e20ff31324ba10643d4e939e29">ProcessCommunicatorDefaults</a>&#160;</td>
          <td class="paramname"><em>pcd</em> = <code><a class="el" href="group__pcl.html#ggaea36d0e20ff31324ba10643d4e939e29aa5c08b5ef97c6bd825508c3901b24c9f">PCD_WORLD</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a communicator. </p>
<p>By default a communicator for all processes is generated. </p>

<p class="reference">References <a class="el" href="group__pcl.html#ggaea36d0e20ff31324ba10643d4e939e29a34bdbd48527517907a38b13063226c81">pcl::PCD_EMPTY</a>, <a class="el" href="group__pcl.html#ggaea36d0e20ff31324ba10643d4e939e29a69ccc8a119b0921f40f5b809d87b30d6">pcl::PCD_LOCAL</a>, <a class="el" href="group__pcl.html#ggaea36d0e20ff31324ba10643d4e939e29aa5c08b5ef97c6bd825508c3901b24c9f">pcl::PCD_WORLD</a>, and <a class="el" href="pcl__comm__world_8cpp.html#aeea8035bdcb7db449f8b4dcc738a8969">PCL_COMM_WORLD</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae6d7c776f504bd965d55ccb029c2d806"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6d7c776f504bd965d55ccb029c2d806">&#9670;&nbsp;</a></span>allgather() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::ProcessCommunicator::allgather </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>sendBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sendCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__pcl.html#ga0a4745c93f155cc512175ca74c049c6c">DataType</a>&#160;</td>
          <td class="paramname"><em>sendType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>recBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>recCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__pcl.html#ga0a4745c93f155cc512175ca74c049c6c">DataType</a>&#160;</td>
          <td class="paramname"><em>recType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>performs MPI_Allgather on the processes of the communicator. </p>
<p>This method synchronises involved processes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sendBuf</td><td>starting address of send buffer (choice) </td></tr>
    <tr><td class="paramname">sendCount</td><td>number of elements in send buffer (integer) </td></tr>
    <tr><td class="paramname">sendType</td><td>data type of send buffer elements (handle) </td></tr>
    <tr><td class="paramname">recBuf</td><td>starting address of receive buffer (choice) </td></tr>
    <tr><td class="paramname">recCount</td><td>number of elements received from any process (integer) </td></tr>
    <tr><td class="paramname">recType</td><td>data type of receive buffer elements (handle) </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="namespaceug.html#ae49e2879be5e2ce34a8a9db509c497ee">ug::GetSize()</a>, <a class="el" href="pcl__profiling_8h.html#a2ed0c268a471877fea32f207d9ad4908">PCL_PROFILE</a>, and <a class="el" href="group__ugbase__common.html#gaf0ce958f12c62aa44c231a700b830374">UG_COND_THROW</a>.</p>

<p class="reference">Referenced by <a class="el" href="namespaceug.html#ade184baefd6bcf45fee96ba55b5aba4e">ug::AllGatherGrid()</a>, <a class="el" href="classpcl_1_1_process_communicator.html#a3bee065c42d30fb67fed65e70e5c534b">allgatherv()</a>, <a class="el" href="group__pcl.html#gae69fa8589b1ee5449187b583e4f0e72e">pcl::CommunicateInvolvedProcesses()</a>, and <a class="el" href="namespaceug.html#a6ed058cbee1614968febd7e711d7dcc9">ug::ConstructParallelDualGraphMGLevel()</a>.</p>

</div>
</div>
<a id="ab9baaf8a77c83c3e17c33f8c2fd5a17b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9baaf8a77c83c3e17c33f8c2fd5a17b">&#9670;&nbsp;</a></span>allgather() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::ProcessCommunicator::allgather </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_binary_buffer.html">ug::BinaryBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>allgather of BinaryBuffers </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Binary buffer in/out </td></tr>
    <tr><td class="paramname">root</td><td>root processor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa38044c228d1e78069a704877e9e48e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa38044c228d1e78069a704877e9e48e2">&#9670;&nbsp;</a></span>allgatherv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::ProcessCommunicator::allgatherv </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>sendBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sendCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__pcl.html#ga0a4745c93f155cc512175ca74c049c6c">DataType</a>&#160;</td>
          <td class="paramname"><em>sendType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>recBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>recCounts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>displs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__pcl.html#ga0a4745c93f155cc512175ca74c049c6c">DataType</a>&#160;</td>
          <td class="paramname"><em>recType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>performs MPI_Allgatherv on the processes of the communicator. </p>
<p>This method synchronises involved processes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sendBuf</td><td>starting address of send buffer (choice) </td></tr>
    <tr><td class="paramname">sendCount</td><td>number of elements in send buffer (integer) </td></tr>
    <tr><td class="paramname">sendType</td><td>data type of send buffer elements (handle) </td></tr>
    <tr><td class="paramname">recCounts</td><td>integer array (of length group size) containing the number of elements that are received from each process </td></tr>
    <tr><td class="paramname">recBuf</td><td>starting address of receive buffer (choice) </td></tr>
    <tr><td class="paramname">displs</td><td>integer array (of length group size). Entry i specifies the displacement (relative to recvbuf ) at which to place the incoming data from process i </td></tr>
    <tr><td class="paramname">recType</td><td>data type of receive buffer elements (handle) </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="namespaceug.html#ae49e2879be5e2ce34a8a9db509c497ee">ug::GetSize()</a>, <a class="el" href="pcl__profiling_8h.html#a2ed0c268a471877fea32f207d9ad4908">PCL_PROFILE</a>, and <a class="el" href="group__ugbase__common.html#gaf0ce958f12c62aa44c231a700b830374">UG_COND_THROW</a>.</p>

<p class="reference">Referenced by <a class="el" href="classpcl_1_1_process_communicator.html#a3bee065c42d30fb67fed65e70e5c534b">allgatherv()</a>, <a class="el" href="group__pcl.html#gae69fa8589b1ee5449187b583e4f0e72e">pcl::CommunicateInvolvedProcesses()</a>, <a class="el" href="classug_1_1_primal_subassembled_matrix_inverse.html#a86c371a48729bd72c6b983f24883f549">ug::PrimalSubassembledMatrixInverse&lt; TAlgebra &gt;::init()</a>, and <a class="el" href="classpcl_1_1_multi_group_communicator.html#abbeca81eb4f4a161ea44d8d8a42b11bc">pcl::MultiGroupCommunicator::reinit()</a>.</p>

</div>
</div>
<a id="a3bee065c42d30fb67fed65e70e5c534b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bee065c42d30fb67fed65e70e5c534b">&#9670;&nbsp;</a></span>allgatherv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TValue &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::ProcessCommunicator::allgatherv </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; TValue &gt; &amp;&#160;</td>
          <td class="paramname"><em>recBufOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; TValue &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>pSizesOut</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>pOffsetsOut</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gathers variable arrays on all processes. </p>
<p>The arrays specified in sendBuf will be copied to all processes in the <a class="el" href="classpcl_1_1_process_communicator.html">ProcessCommunicator</a>. The order of the arrays in recBufOut is the same as the order of the sending processes in this ProcessCommnicator. You can optionally specify an array pSizesOut, which will be filled with the size of the array that was received from each process and an array in which the offsets of each array are stored - that means the first index of each array - again in the order of processes in this <a class="el" href="classpcl_1_1_process_communicator.html">ProcessCommunicator</a>.</p>
<p>Note that recBufOut, pSizesOut and pOffsetsOut will be resized as required.</p>
<p>Please note that this method communicates twice. </p>

<p class="reference">References <a class="el" href="classpcl_1_1_process_communicator.html#ae6d7c776f504bd965d55ccb029c2d806">allgather()</a>, <a class="el" href="classpcl_1_1_process_communicator.html#aa38044c228d1e78069a704877e9e48e2">allgatherv()</a>, <a class="el" href="group__ugbase__common__util.html#ga0c629a903fff8db003dafaf36aca4db7">ug::GetDataPtr()</a>, <a class="el" href="classpcl_1_1_process_communicator.html#a3be8df02f7591a7fd79d2a16a27b85ff">is_local()</a>, <a class="el" href="group__pcl.html#ga7a54f12d845f53f9da3bef2474c1fc8c">PCL_DT_BYTE</a>, <a class="el" href="group__pcl.html#gafb0837e727561ea889dde9a8e3163e93">PCL_DT_INT</a>, and <a class="el" href="classpcl_1_1_process_communicator.html#a71686860dd00b51ca298088864f76417">size()</a>.</p>

</div>
</div>
<a id="a1e3264c8d8f00d75bd899a8ea39b0e01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e3264c8d8f00d75bd899a8ea39b0e01">&#9670;&nbsp;</a></span>allreduce() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t pcl::ProcessCommunicator::allreduce </td>
          <td>(</td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__pcl.html#ga774ab56d0811cccca811df2e62bc0939">pcl::ReduceOperation</a>&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>overload for size_t </p>

<p class="reference">References <a class="el" href="group__pcl.html#ga2f305bfd28aca5a7ca28a665e09cab70">PCL_DT_UNSIGNED_LONG_LONG</a>.</p>

</div>
</div>
<a id="a9ac4b53c26605c7fe9683bfe6c9fe4e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ac4b53c26605c7fe9683bfe6c9fe4e1">&#9670;&nbsp;</a></span>allreduce() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::ProcessCommunicator::allreduce </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>send</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>receive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__pcl.html#ga774ab56d0811cccca811df2e62bc0939">pcl::ReduceOperation</a>&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>simplified allreduce for std::vector. The receive-buffer is automatically resized as required. </p>

<p class="reference">References <a class="el" href="classpcl_1_1_process_communicator.html#a708b02efa2d765daae9fee02b7b60000">allreduce()</a>.</p>

</div>
</div>
<a id="ac0f8d02f2ab0c2795d2174f158f21da6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0f8d02f2ab0c2795d2174f158f21da6">&#9670;&nbsp;</a></span>allreduce() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T pcl::ProcessCommunicator::allreduce </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__pcl.html#ga774ab56d0811cccca811df2e62bc0939">pcl::ReduceOperation</a>&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>simplified allreduce for size=1. calls allreduce for parameter t, and then returns the result. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the input parameter </td></tr>
    <tr><td class="paramname">op</td><td>the Reduce Operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the reduced result </dd></dl>

<p class="reference">References <a class="el" href="classpcl_1_1_process_communicator.html#a708b02efa2d765daae9fee02b7b60000">allreduce()</a>.</p>

</div>
</div>
<a id="a3522849924039e28fecaa8ad0f074c7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3522849924039e28fecaa8ad0f074c7f">&#9670;&nbsp;</a></span>allreduce() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::ProcessCommunicator::allreduce </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>pSendBuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>pReceiveBuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__pcl.html#ga774ab56d0811cccca811df2e62bc0939">pcl::ReduceOperation</a>&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>simplified allreduce for buffers. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pSendBuff</td><td>the input buffer </td></tr>
    <tr><td class="paramname">pReceiveBuff</td><td>the output buffer </td></tr>
    <tr><td class="paramname">count</td><td>number of elements in the input/output buffers </td></tr>
    <tr><td class="paramname">op</td><td>the Reduce Operation </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classpcl_1_1_process_communicator.html#a708b02efa2d765daae9fee02b7b60000">allreduce()</a>.</p>

</div>
</div>
<a id="a708b02efa2d765daae9fee02b7b60000"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a708b02efa2d765daae9fee02b7b60000">&#9670;&nbsp;</a></span>allreduce() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::ProcessCommunicator::allreduce </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>sendBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>recBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__pcl.html#ga0a4745c93f155cc512175ca74c049c6c">DataType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__pcl.html#ga774ab56d0811cccca811df2e62bc0939">ReduceOperation</a>&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>performs MPI_Allreduce on the processes of the communicator. </p>
<p>This method synchronises involved processes. </p>

<p class="reference">References <a class="el" href="namespaceug.html#ae49e2879be5e2ce34a8a9db509c497ee">ug::GetSize()</a>, <a class="el" href="pcl__profiling_8h.html#a2ed0c268a471877fea32f207d9ad4908">PCL_PROFILE</a>, and <a class="el" href="group__ugbase__common.html#gaf0ce958f12c62aa44c231a700b830374">UG_COND_THROW</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__pcl.html#ga944eeb7a85cdf4e14beba56bf4729e3e">pcl::AllProcsTrue()</a>, <a class="el" href="classpcl_1_1_process_communicator.html#ac0f8d02f2ab0c2795d2174f158f21da6">allreduce()</a>, <a class="el" href="namespaceug.html#af2e53b962feba0e26502b06d7770eb81">ug::ApplySmoothManifoldPosToTopLevelButterflyScheme()</a>, <a class="el" href="namespaceug.html#a0c467abe9522c00d1bc3b8d5ca33a127">ug::ApplySmoothManifoldPosToTopLevelLoopScheme()</a>, <a class="el" href="namespaceug.html#a696b1b847542a69133a532a414f91582">ug::ApplySmoothSubdivisionSurfacesToTopLevel()</a>, <a class="el" href="namespaceug.html#a04e558eb330f06eed22a5e5672745c44">ug::ApplySmoothSubdivisionVolumesToTopLevel()</a>, <a class="el" href="classug_1_1_partitioner___dynamic_bisection.html#a77d484e7450fe2f340380e0f42aaca6d">ug::Partitioner_DynamicBisection&lt; TElem, dim &gt;::bisect_elements()</a>, <a class="el" href="classug_1_1_partitioner___dynamic_bisection.html#a67a50ad90c2d2df29b68406792267abc">ug::Partitioner_DynamicBisection&lt; TElem, dim &gt;::calculate_global_dimensions()</a>, <a class="el" href="namespaceug.html#a1f25691c0a4c39dcdf56e43bfc6a5b12">ug::CalculateNumManifoldEdgesVertexAttachmentInParentLevel()</a>, <a class="el" href="namespaceug.html#ade3f4f396966d0400b214282e9fa77a8">ug::CalculateSmoothCreaseManifoldPosInParentLevelLoopScheme()</a>, <a class="el" href="namespaceug.html#a670fd9a1468187d3d1f34b1c711d0ac9">ug::CalculateSmoothManifoldPosInParentLevelButterflyScheme()</a>, <a class="el" href="namespaceug.html#a6aa7a66ccdf4c13b829dc2f2cfa8bd62">ug::CalculateSmoothManifoldPosInParentLevelLoopScheme()</a>, <a class="el" href="namespaceug.html#ac3adc4eb5debea8a7c5fd8c978217e58">ug::CheckGFValuesWithinBounds()</a>, <a class="el" href="classug_1_1_mem_info.html#a052e164c3faf5a95079f8882c8ac7c4f">ug::MemInfo::communicate_process_values()</a>, <a class="el" href="namespaceug.html#a8208a1320f8aee0797b5dc9c349bd581">ug::ComputeAvg()</a>, <a class="el" href="namespaceug.html#a280f7126eacb309f634e068064636e96">ug::ComputeMinMax()</a>, <a class="el" href="classug_1_1_parallel_hanging_node_refiner___multi_grid.html#aebd3c360f114dbe73e3ba46a4f84a228">ug::ParallelHangingNodeRefiner_MultiGrid::contains_edges()</a>, <a class="el" href="classug_1_1_parallel_hanging_node_refiner___multi_grid.html#ad496f9b6c53247fbd4eb63886cb5b16f">ug::ParallelHangingNodeRefiner_MultiGrid::contains_faces()</a>, <a class="el" href="classug_1_1_parallel_hanging_node_refiner___multi_grid.html#aeb28ab662da5bf1ef2c8787586bc2820">ug::ParallelHangingNodeRefiner_MultiGrid::contains_volumes()</a>, <a class="el" href="classug_1_1_grid_function_component_space.html#a0b3fa58ea86f825541fb6994bd995f10">ug::GridFunctionComponentSpace&lt; TGridFunction &gt;::distance2()</a>, <a class="el" href="classug_1_1_load_balancer.html#a6c1108199d719c1c76ebda01c8598a85">ug::LoadBalancer::estimate_distribution_quality()</a>, <a class="el" href="classug_1_1_load_balancer.html#a57b4a64c857aa4514e3691d88cc0b711">ug::LoadBalancer::estimate_distribution_quality_impl()</a>, <a class="el" href="classug_1_1bridge_1_1_evaluate_1_1_number_valued_user_data_evaluator.html#aa6ae75e069d881c51d43ead45aabdc30">ug::bridge::Evaluate::NumberValuedUserDataEvaluator&lt; TDomain, TAlgebra &gt;::evaluate()</a>, <a class="el" href="classug_1_1bridge_1_1_evaluate_1_1_vector_valued_user_data_evaluator.html#a504a217c44e2dd2169c6a5c9cf91220d">ug::bridge::Evaluate::VectorValuedUserDataEvaluator&lt; TDomain, TAlgebra &gt;::evaluate()</a>, <a class="el" href="classug_1_1_global_grid_function_number_data.html#abfa84d42781ae57b63a2468bb6ae9538">ug::GlobalGridFunctionNumberData&lt; TGridFunction, elemDim &gt;::evaluate_global()</a>, <a class="el" href="group__domain__bridge.html#gaffaaec5db9baa32b6ec12b0fbc8c6493">ug::GetMaxEdgeLength()</a>, <a class="el" href="classug_1_1_partitioner___dynamic_bisection.html#a5b89fe551cd6d11f0ea3dd5f68596f77">ug::Partitioner_DynamicBisection&lt; TElem, dim &gt;::improve_split_values()</a>, <a class="el" href="namespaceug.html#aac0d910e83c86dd74828d8cc3185dae2">ug::Integral()</a>, <a class="el" href="namespaceug.html#a87c2b113caf6106e569a2dbc7715bfa9">ug::IntegralNormalComponentOnManifoldSubsets()</a>, <a class="el" href="namespaceug.html#a56982bd435f3756931ead333f92b20d9">ug::IntegrateDiscFlux()</a>, <a class="el" href="namespaceug.html#a29b9a57287c28745ff5cff3f558cbb22">ug::IntegrateNormalComponentOnManifold()</a>, <a class="el" href="namespaceug.html#a04caafec8eae8e4be174c4cc2675f71c">ug::IntegrateNormalGradientOnManifold()</a>, <a class="el" href="namespaceug.html#a36b581ab972bc024e974d601c07ac241">ug::IntegrateSubsets()</a>, <a class="el" href="classug_1_1_expected_error_marking_strategy.html#a9e673dcf4eea5e5c1eb197ddba7ee392">ug::ExpectedErrorMarkingStrategy&lt; TDomain &gt;::mark()</a>, <a class="el" href="classug_1_1_mean_value_marking.html#a1b9dd1edc3b18126cbe4153e1bb38ccd">ug::MeanValueMarking&lt; TDomain &gt;::mark()</a>, <a class="el" href="classug_1_1_absolute_marking.html#a8a19b6830a7678e24da224e8f22e78d4">ug::AbsoluteMarking&lt; TDomain &gt;::mark()</a>, <a class="el" href="classug_1_1_variance_marking.html#a77297bb32ea1dfdc9279362c82842f4a">ug::VarianceMarking&lt; TDomain &gt;::mark()</a>, <a class="el" href="classug_1_1_variance_marking_eta.html#abe0cde66e4f3b515efa3e0ad9c20ff96">ug::VarianceMarkingEta&lt; TDomain &gt;::mark()</a>, <a class="el" href="classug_1_1_maximum_marking.html#acd763304fa619e1de08cea8075cca7a2">ug::MaximumMarking&lt; TDomain &gt;::mark()</a>, <a class="el" href="classug_1_1_a_posteriori_coarsening.html#a46f92bcd5c293e3c947ad57b4004e231">ug::APosterioriCoarsening&lt; TDomain &gt;::mark()</a>, <a class="el" href="namespaceug.html#a2eda8e37b64ea6e53ba39e5570c1093b">ug::MarkElements()</a>, <a class="el" href="namespaceug.html#a42eb3cd1483805f402483228e1fb69c8">ug::MarkElementsAbsolute()</a>, <a class="el" href="namespaceug.html#a700b26fc089f31cf9ee349f17054c42c">ug::MarkElementsForCoarsening()</a>, <a class="el" href="namespaceug.html#aff30f2eff13d0da6da635aecfedeffe5">ug::MarkElementsForRefinement()</a>, <a class="el" href="namespaceug.html#a15d12b1d241b74a8af3f5f9e4c0989f6">ug::MarkForAdaption_GradientAverage()</a>, <a class="el" href="namespaceug.html#a3c100adeb72b6849f558078360b376f6">ug::MarkForAdaption_GradientJump()</a>, <a class="el" href="namespaceug.html#ae9459956041a012d4ef5bdd7d9979fe8">ug::MarkForAdaption_L2ErrorExact()</a>, <a class="el" href="namespaceug.html#ad49a40cf0d6f047e2e7f7e05e2af8b2e">ug::MarkForAdaption_ResidualErrorP1Absolute()</a>, <a class="el" href="namespaceug.html#a5bb8462fdfdf4813194f1159225163b5">ug::MarkForAdaption_ResidualErrorP1Relative()</a>, <a class="el" href="namespaceug.html#a2c1372af1f8a0153e84bf8ce957fd0a2">ug::MarkOutOfRangeElems()</a>, <a class="el" href="group__lib__grid__algorithms__geom__obj__misc.html#gacbbcf6c6549ff4932d940fc31fee1d92">ug::MaxElementDiameter()</a>, <a class="el" href="group__lib__grid__algorithms__geom__obj__misc.html#gab0c1c7818848aa20baa8a135313764ac">ug::MinElementDiameter()</a>, <a class="el" href="classug_1_1_composite_conv_check.html#ab7ef0f0fd4108eb55663427f79370c88">ug::CompositeConvCheck&lt; TVector, TDomain &gt;::norm()</a>, <a class="el" href="classug_1_1_grid_function_component_space.html#a6a61a206adadbca17fd4035d6328fe87">ug::GridFunctionComponentSpace&lt; TGridFunction &gt;::norm2()</a>, <a class="el" href="classug_1_1_i_refiner.html#a3668bf0ad22ddb0b22ad2c98d31e6290">ug::IRefiner::num_marked_edges()</a>, <a class="el" href="classug_1_1_i_refiner.html#a5571c244d5798011be695636e7b89c2d">ug::IRefiner::num_marked_elements()</a>, <a class="el" href="classug_1_1_i_refiner.html#a46610afaa509bc72ec432ab6c4afb73c">ug::IRefiner::num_marked_faces()</a>, <a class="el" href="classug_1_1_i_refiner.html#a6d4ae30e890ab15c69be1e0789aad107">ug::IRefiner::num_marked_volumes()</a>, <a class="el" href="group__pcl.html#ga61412e843ef0b406b64d2d9841bf0c39">pcl::OneProcTrue()</a>, <a class="el" href="group__pcl__bridge.html#ga387662740bc9cb9c0ff198fab9bc4161">ug::bridge::ParallelMax()</a>, <a class="el" href="group__pcl__bridge.html#gae893513e3f4ec2e9e134d79caa707dc5">ug::bridge::ParallelMin()</a>, <a class="el" href="group__pcl__bridge.html#gab2fc8850cd7aeea1414fcbb8e2556e93">ug::bridge::ParallelSum()</a>, <a class="el" href="group__pcl__bridge.html#gae084feb2855be0c3e9ffcbb3e557f3fe">ug::bridge::ParallelVecMax()</a>, <a class="el" href="group__pcl__bridge.html#ga30d989b0a7424c4121c01ddef90d1ee3">ug::bridge::ParallelVecMin()</a>, <a class="el" href="group__pcl__bridge.html#ga2031cf4af32f7fcfb5143065711a04bc">ug::bridge::ParallelVecSum()</a>, <a class="el" href="classug_1_1_partitioner___dynamic_bisection.html#a1fde835b22111e0d59b3630a13dd2893">ug::Partitioner_DynamicBisection&lt; TElem, dim &gt;::partition()</a>, <a class="el" href="classug_1_1_partitioner___dynamic_bisection.html#a0ec79b301fa36b5f7968e7905cf8f5bb">ug::Partitioner_DynamicBisection&lt; TElem, dim &gt;::perform_bisection()</a>, <a class="el" href="classug_1_1_local_schur_complement.html#a61f76c9a2b2bc254fbc54eadd60f70fe">ug::LocalSchurComplement&lt; TAlgebra &gt;::print_statistic_of_inner_solver()</a>, <a class="el" href="classug_1_1_primal_subassembled_matrix_inverse.html#a439cdf5f74411fb7822f4c29d44538da">ug::PrimalSubassembledMatrixInverse&lt; TAlgebra &gt;::print_statistic_of_inner_solver()</a>, <a class="el" href="namespaceug.html#af5c32ece8ebe92182c0150208f16cb5a">ug::PrintElementEdgeRatios()</a>, <a class="el" href="namespaceug.html#a89527e1bbc6cc71eeafe0f1ca66f26c3">ug::ProjectHierarchyToSubdivisionLimit()</a>, <a class="el" href="classug_1_1_surface_view.html#a7af622b232d844b35c1075e4f00c8300">ug::SurfaceView::refresh_surface_states()</a>, <a class="el" href="classug_1_1_do_f_count.html#a379cf8d03a0c7c4b2d94debac4d08d24">ug::DoFCount::sum_values_over_procs()</a>, <a class="el" href="namespaceug.html#a197fb499589b813100637a8ca6a93673">ug::SumGFValuesAt()</a>, <a class="el" href="namespaceug.html#ac0444fff5f9a29eda3d7655a8121c35b">ug::SynchronizeAttachedGlobalAttachments()</a>, <a class="el" href="classug_1_1_global_attachments.html#a0b72f7fa204bc9ef8f7dcf0fb4eae597">ug::GlobalAttachments::SynchronizeDeclaredGlobalAttachments()</a>, and <a class="el" href="namespaceug.html#a11a287d661f4ba5bc7e340efc79867d4">ug::TestGridLayoutMap()</a>.</p>

</div>
</div>
<a id="a3e0460aac9629b04410f3fd3eba66400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e0460aac9629b04410f3fd3eba66400">&#9670;&nbsp;</a></span>alltoall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::ProcessCommunicator::alltoall </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>sendBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sendCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__pcl.html#ga0a4745c93f155cc512175ca74c049c6c">DataType</a>&#160;</td>
          <td class="paramname"><em>sendType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>recBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>recCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__pcl.html#ga0a4745c93f155cc512175ca74c049c6c">DataType</a>&#160;</td>
          <td class="paramname"><em>recType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>performs MPI_Alltoall on the processes of the communicator. </p>
<p>All processes send (the same amount of) data to all processes. The receive buffer needs to have the appropriate size. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sendBuf</td><td>starting address of send buffer (choice) </td></tr>
    <tr><td class="paramname">sendCount</td><td>number of elements to send to each process (integer) </td></tr>
    <tr><td class="paramname">sendType</td><td>data type of send buffer elements (handle) </td></tr>
    <tr><td class="paramname">recBuf</td><td>starting address of receive buffer (choice) </td></tr>
    <tr><td class="paramname">recCount</td><td>number of elements to receive from each process (integer) </td></tr>
    <tr><td class="paramname">recType</td><td>data type of receive buffer elements (handle) </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="namespaceug.html#ae49e2879be5e2ce34a8a9db509c497ee">ug::GetSize()</a>, <a class="el" href="pcl__profiling_8h.html#a2ed0c268a471877fea32f207d9ad4908">PCL_PROFILE</a>, and <a class="el" href="group__ugbase__common.html#gaf0ce958f12c62aa44c231a700b830374">UG_COND_THROW</a>.</p>

</div>
</div>
<a id="a38a24e38e98554501ecffaa578af58ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38a24e38e98554501ecffaa578af58ee">&#9670;&nbsp;</a></span>barrier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::ProcessCommunicator::barrier </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this method will not return until all processes in the communicator have called it. </p>

<p class="reference">References <a class="el" href="pcl__profiling_8h.html#a2ed0c268a471877fea32f207d9ad4908">PCL_PROFILE</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__pcl.html#ga17bfa7a217567699e0646832a8505776">pcl::SynchronizeProcesses()</a>.</p>

</div>
</div>
<a id="a7bccccdb8419d780bfe8535a526c9da8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bccccdb8419d780bfe8535a526c9da8">&#9670;&nbsp;</a></span>broadcast() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::ProcessCommunicator::broadcast </td>
          <td>(</td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>overload for size_t </p>

<p class="reference">References <a class="elRef" href="../plugins/_biogas_8lua.html#a9dda901d5ee6289370201a700f88e789">s</a>.</p>

</div>
</div>
<a id="a8a1859052f80964617f7de2312b31feb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a1859052f80964617f7de2312b31feb">&#9670;&nbsp;</a></span>broadcast() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::ProcessCommunicator::broadcast </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_data_type_directly_supported.html">DataTypeDirectlySupported</a>&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>broadcast function for directly supported types </p>

<p class="reference">References <a class="el" href="classpcl_1_1_process_communicator.html#aa219e509eaef84ff08865ccd5ca409c5">broadcast()</a>.</p>

</div>
</div>
<a id="a19b0968b431a6dab69c6f2ec95c8d366"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19b0968b431a6dab69c6f2ec95c8d366">&#9670;&nbsp;</a></span>broadcast() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::ProcessCommunicator::broadcast </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_data_type_indirectly_supported.html">DataTypeIndirectlySupported</a>&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>broadcast function for indirectly supported types (using Serialize/Deserialize) </p>

<p class="reference">References <a class="el" href="classpcl_1_1_process_communicator.html#aa219e509eaef84ff08865ccd5ca409c5">broadcast()</a>, <a class="el" href="namespaceug.html#a7b02f2134ee87750f975d6139828d69d">ug::Deserialize()</a>, <a class="el" href="group__pcl.html#ga319e84518e2b596fc9f9b40b4383ec36">pcl::ProcRank()</a>, and <a class="el" href="namespaceug.html#ab254d4e3f5be2b03179816c20e4d3464">ug::Serialize()</a>.</p>

</div>
</div>
<a id="ac885420ebe9d64678e84d597b953f7d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac885420ebe9d64678e84d597b953f7d3">&#9670;&nbsp;</a></span>broadcast() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::ProcessCommunicator::broadcast </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Bcast for objects </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>object to be broadcasted (uses Serialize/Deserialize) </td></tr>
    <tr><td class="paramname">root</td><td>process that distributes data (default 0) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>Serialize, Deserialize </dd></dl>

<p class="reference">References <a class="el" href="classpcl_1_1_process_communicator.html#aa219e509eaef84ff08865ccd5ca409c5">broadcast()</a>.</p>

</div>
</div>
<a id="a5155ae618f8fe76850b33760a7c80505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5155ae618f8fe76850b33760a7c80505">&#9670;&nbsp;</a></span>broadcast() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::ProcessCommunicator::broadcast </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>simplified broadcast for supported datatypes compiler error for unsupported datatypes you can cast to unsigned char to broadcast arbitrary fixed data </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>pointer to data </td></tr>
    <tr><td class="paramname">size</td><td>number of T elements the pointer p is pointing to. default 1 </td></tr>
    <tr><td class="paramname">root</td><td>process that distributes data (default 0) </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classpcl_1_1_process_communicator.html#aa219e509eaef84ff08865ccd5ca409c5">broadcast()</a>, <a class="elRef" href="../plugins/_biogas_8lua.html#a57f1028d958bb73c4e3c64e2077342fc">p</a>, and <a class="el" href="classpcl_1_1_process_communicator.html#a71686860dd00b51ca298088864f76417">size()</a>.</p>

</div>
</div>
<a id="a58fc01ab1c2361e18b0692972dc5bc8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58fc01ab1c2361e18b0692972dc5bc8a">&#9670;&nbsp;</a></span>broadcast() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::ProcessCommunicator::broadcast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_binary_buffer.html">ug::BinaryBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>broadcast of BinaryBuffers </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Binary buffer in/out </td></tr>
    <tr><td class="paramname">root</td><td>root processor </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classug_1_1_binary_buffer.html#a1ff86563b8133d53b9293d4ec45484d6">ug::BinaryBuffer::buffer()</a>, <a class="el" href="group__pcl.html#ga9bb316e25297f10531ad5e41b0513f63">PCL_DT_CHAR</a>, <a class="el" href="group__pcl.html#ga4a4344095d0ff4e217287b28ba11f6a1">PCL_DT_LONG</a>, <a class="el" href="group__pcl.html#ga319e84518e2b596fc9f9b40b4383ec36">pcl::ProcRank()</a>, <a class="el" href="classug_1_1_binary_buffer.html#a4cbcf7f6b48ec299252eabb0c2910434">ug::BinaryBuffer::reserve()</a>, <a class="el" href="classug_1_1_binary_buffer.html#a39f333c178a905687b80654132f7e8ba">ug::BinaryBuffer::set_write_pos()</a>, and <a class="el" href="classug_1_1_binary_buffer.html#acb333d1a7093992faa6b2c2a6dc6f046">ug::BinaryBuffer::write_pos()</a>.</p>

</div>
</div>
<a id="aa219e509eaef84ff08865ccd5ca409c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa219e509eaef84ff08865ccd5ca409c5">&#9670;&nbsp;</a></span>broadcast() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::ProcessCommunicator::broadcast </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__pcl.html#ga0a4745c93f155cc512175ca74c049c6c">DataType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>performs a MPI_Bcast </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>pointer to data </td></tr>
    <tr><td class="paramname">size</td><td>size of data </td></tr>
    <tr><td class="paramname">type</td><td>type of data </td></tr>
    <tr><td class="paramname">root</td><td>root process, that distributes data </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="pcl__profiling_8h.html#a2ed0c268a471877fea32f207d9ad4908">PCL_PROFILE</a>.</p>

<p class="reference">Referenced by <a class="el" href="classpcl_1_1_process_communicator.html#ac885420ebe9d64678e84d597b953f7d3">broadcast()</a>, <a class="el" href="group__lib__disc__domain.html#gaca109ca8a59b65508b4eee40d8957f64">ug::IDomain&lt; TGrid, TSubsetHandler &gt;::broadcast_refinement_projector()</a>, <a class="el" href="namespaceug.html#aa1d4324ccc4ad84a9d68bdfa77ba043f">ug::BroadcastGrid()</a>, <a class="el" href="classug_1_1_expected_error_marking_strategy.html#a9e673dcf4eea5e5c1eb197ddba7ee392">ug::ExpectedErrorMarkingStrategy&lt; TDomain &gt;::mark()</a>, <a class="el" href="group__pcl.html#ga25fcc02d60112f3e50adaffdba369d2e">pcl::MinimalKeyValuePairAcrossAllProcs()</a>, <a class="el" href="namespacepcl.html#a97c0165d61cd066e4bcaa670824624fb">pcl::ParallelReadFile()</a>, <a class="el" href="classug_1_1_global_attachments.html#a0b72f7fa204bc9ef8f7dcf0fb4eae597">ug::GlobalAttachments::SynchronizeDeclaredGlobalAttachments()</a>, and <a class="el" href="group__lib__disc__domain.html#ga49cbff5c0ca57031b167d0b2e93851ca">ug::IDomain&lt; TGrid, TSubsetHandler &gt;::update_subset_infos()</a>.</p>

</div>
</div>
<a id="a1a487b3598828bda6cad9295d09c9b6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a487b3598828bda6cad9295d09c9b6c">&#9670;&nbsp;</a></span>create_communicator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcl_1_1_process_communicator.html">ProcessCommunicator</a> pcl::ProcessCommunicator::create_communicator </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make sure that all processes call this method with the same parameters! </p>

<p class="reference">References <a class="el" href="classpcl_1_1_process_communicator.html#a02a2e0dc57c2fedbba3fff6e455948f1">m_comm</a>, <a class="el" href="group__pcl.html#ggaea36d0e20ff31324ba10643d4e939e29a34bdbd48527517907a38b13063226c81">pcl::PCD_EMPTY</a>, <a class="el" href="group__pcl.html#ggaea36d0e20ff31324ba10643d4e939e29aa5c08b5ef97c6bd825508c3901b24c9f">pcl::PCD_WORLD</a>, and <a class="el" href="pcl__comm__world_8cpp.html#aeea8035bdcb7db449f8b4dcc738a8969">PCL_COMM_WORLD</a>.</p>

</div>
</div>
<a id="a1ab7c861d3d2ba66df6f993538730335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ab7c861d3d2ba66df6f993538730335">&#9670;&nbsp;</a></span>create_communicator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcl_1_1_process_communicator.html">ProcessCommunicator</a> pcl::ProcessCommunicator::create_communicator </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>newGlobalProcs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make sure that all processes call this method with the same parameters! </p>

<p class="reference">References <a class="el" href="classpcl_1_1_process_communicator.html#a02a2e0dc57c2fedbba3fff6e455948f1">m_comm</a>, <a class="el" href="group__pcl.html#ggaea36d0e20ff31324ba10643d4e939e29a34bdbd48527517907a38b13063226c81">pcl::PCD_EMPTY</a>, <a class="el" href="group__pcl.html#ggaea36d0e20ff31324ba10643d4e939e29aa5c08b5ef97c6bd825508c3901b24c9f">pcl::PCD_WORLD</a>, and <a class="el" href="pcl__comm__world_8cpp.html#aeea8035bdcb7db449f8b4dcc738a8969">PCL_COMM_WORLD</a>.</p>

<p class="reference">Referenced by <a class="el" href="classug_1_1_process_hierarchy.html#a3bb576f14a239629adae1d0a0a271e68">ug::ProcessHierarchy::add_hierarchy_level()</a>, and <a class="el" href="namespaceug.html#a592e71fc3a4e567b81a8d81cad64554c">ug::Deserialize()</a>.</p>

</div>
</div>
<a id="ab9280593c63193e1a3f5a7b85419c31a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9280593c63193e1a3f5a7b85419c31a">&#9670;&nbsp;</a></span>create_sub_communicator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcl_1_1_process_communicator.html">ProcessCommunicator</a> pcl::ProcessCommunicator::create_sub_communicator </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>participate</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a new communicator containing a subset of the current communicator </p>
<p>Note that this method has to be called by all processes in the current communicator - even if they don't want to participate in the new one. </p>

<p class="reference">References <a class="el" href="group__pcl.html#ggaea36d0e20ff31324ba10643d4e939e29a34bdbd48527517907a38b13063226c81">pcl::PCD_EMPTY</a>, <a class="el" href="pcl__util_8h.html#ac63e4d26eb0869180835d6b9a41e271e">PCL_DEBUG_BARRIER</a>, <a class="el" href="group__pcl.html#gafb0837e727561ea889dde9a8e3163e93">PCL_DT_INT</a>, <a class="el" href="pcl__profiling_8h.html#a2ed0c268a471877fea32f207d9ad4908">PCL_PROFILE</a>, <a class="el" href="group__pcl.html#ga6d762a24a3efa664b0937ed25b00049e">PCL_RO_MAX</a>, and <a class="el" href="group__ugbase__common.html#gaf0ce958f12c62aa44c231a700b830374">UG_COND_THROW</a>.</p>

<p class="reference">Referenced by <a class="el" href="classug_1_1_feti_layouts.html#a708d5c7657428f1fe3f6ce232f4ae8ba">ug::FetiLayouts&lt; TAlgebra &gt;::create_layouts()</a>, <a class="el" href="classug_1_1_parallel_dual_graph.html#af3649ee9fabbfe0bd5106e418521b430">ug::ParallelDualGraph&lt; TGeomBaseObj, TIndexType, TConnectingObj &gt;::generate_graph()</a>, <a class="el" href="namespaceug.html#a1e2f0b6aac231e9a09bd4bde94e27096">ug::PartitionMultiGridLevel_ParmetisKway()</a>, and <a class="el" href="classug_1_1_do_f_distribution.html#a9098093a6d988f252ec64ab4d0ff897c">ug::DoFDistribution::reinit_layouts_and_communicator()</a>.</p>

</div>
</div>
<a id="af93712470b06d42fd4e5222415701927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af93712470b06d42fd4e5222415701927">&#9670;&nbsp;</a></span>create_sub_communicator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcl_1_1_process_communicator.html">ProcessCommunicator</a> pcl::ProcessCommunicator::create_sub_communicator </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>newProcs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make sure that all processes which participate in the current communicator call this method with the same parameters! Process indices are to be specified relative to the current communicator.</p>
<p>note: ranks in newProcs are ranks in the (group!) communicator m_comm-&gt;m_mpiComm </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classpcl_1_1_process_communicator.html#a1ab7c861d3d2ba66df6f993538730335">create_communicator</a> </dd></dl>

<p class="reference">References <a class="el" href="classpcl_1_1_process_communicator.html#a02a2e0dc57c2fedbba3fff6e455948f1">m_comm</a>, <a class="el" href="group__pcl.html#ga7a09a2eab069305ca735847eed023d2f">pcl::NumProcs()</a>, <a class="el" href="group__pcl.html#ggaea36d0e20ff31324ba10643d4e939e29a34bdbd48527517907a38b13063226c81">pcl::PCD_EMPTY</a>, <a class="el" href="group__pcl.html#ggaea36d0e20ff31324ba10643d4e939e29aa5c08b5ef97c6bd825508c3901b24c9f">pcl::PCD_WORLD</a>, <a class="el" href="pcl__comm__world_8cpp.html#aeea8035bdcb7db449f8b4dcc738a8969">PCL_COMM_WORLD</a>, <a class="el" href="pcl__profiling_8h.html#a2ed0c268a471877fea32f207d9ad4908">PCL_PROFILE</a>, <a class="el" href="pcl__profiling_8h.html#a4f9ee601b343e56343ab77ea32db1a8a">PCL_PROFILE_END</a>, and <a class="el" href="group__ugbase__common.html#gaf0ce958f12c62aa44c231a700b830374">UG_COND_THROW</a>.</p>

</div>
</div>
<a id="a8cea9e6a3075ff027571cef208d61f42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cea9e6a3075ff027571cef208d61f42">&#9670;&nbsp;</a></span>distribute_data() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::ProcessCommunicator::distribute_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_binary_buffer.html">ug::BinaryBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>recvBufOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>segSizesOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>recvFromRanks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numRecvFroms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>sendBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>sendSegSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>sendToRanks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numSendTos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tag</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sends and receives data to/from multiple processes </p>
<p>This method automatically determines the size of the distributed data and writes it to a binary stream. Note that it has to communicate twice, since the buffer-sizes also have to be communicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recvBufOut</td><td>Received data will be written to this buffer. </td></tr>
    <tr><td class="paramname">segSizesOut</td><td>Array to which the block-sizes received from each process will be written. Has to have size numRecvFroms. </td></tr>
    <tr><td class="paramname">recvFromRanks</td><td>Array containing the ranks which send data to this process. Has to have size numRecvFroms. </td></tr>
    <tr><td class="paramname">numRecvFroms</td><td>Specifies from how many processes this process will receive data. </td></tr>
    <tr><td class="paramname">sendBuf</td><td>Contains the data which will be send to other processes. Make sure that it is big enough (sum of all sendSegSizes). </td></tr>
    <tr><td class="paramname">sendSegSizes</td><td>The i-th entry corresponds to the block-size which will be send to the i-th process in sendToRanks. Has to have size numSendTos. </td></tr>
    <tr><td class="paramname">sendToRanks</td><td>An array of process ids, which defines to where data shall be sent. Has to have size numSendTos. </td></tr>
    <tr><td class="paramname">numSendTos</td><td>Specifies to how many processes data will be sent. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classug_1_1_binary_buffer.html#a1ff86563b8133d53b9293d4ec45484d6">ug::BinaryBuffer::buffer()</a>, <a class="el" href="group__ugbase__common__util.html#ga0c629a903fff8db003dafaf36aca4db7">ug::GetDataPtr()</a>, <a class="el" href="pcl__profiling_8h.html#a2ed0c268a471877fea32f207d9ad4908">PCL_PROFILE</a>, <a class="el" href="classug_1_1_binary_buffer.html#a4cbcf7f6b48ec299252eabb0c2910434">ug::BinaryBuffer::reserve()</a>, and <a class="el" href="classug_1_1_binary_buffer.html#a39f333c178a905687b80654132f7e8ba">ug::BinaryBuffer::set_write_pos()</a>.</p>

</div>
</div>
<a id="a3031101bb147f6d875549f897c7996f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3031101bb147f6d875549f897c7996f7">&#9670;&nbsp;</a></span>distribute_data() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::ProcessCommunicator::distribute_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_binary_buffer.html">ug::BinaryBuffer</a> *&#160;</td>
          <td class="paramname"><em>recvBufs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>recvFromRanks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numRecvs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_binary_buffer.html">ug::BinaryBuffer</a> *&#160;</td>
          <td class="paramname"><em>sendBufs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>sendToRanks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numSendTos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tag</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sends and receives data to/from multiple processes </p>
<p>Note that it has to communicate twice, since the buffer-sizes also have to be communicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recvBufs</td><td>Received data will be written to this buffers. This array has to be of the size numRecvs </td></tr>
    <tr><td class="paramname">recvFromRanks</td><td>Array containing the ranks from which data shall be received. Has to have size numRecvs. </td></tr>
    <tr><td class="paramname">numRecvs</td><td>Specifies from how many processes this process will receive data. </td></tr>
    <tr><td class="paramname">sendBufs</td><td>Array of buffers whose data will be send to other processes. Has to be of size numSends </td></tr>
    <tr><td class="paramname">sendToRanks</td><td>An array of process ids, which defines to where data shall be sent. Has to have size numSends. </td></tr>
    <tr><td class="paramname">numSendTos</td><td>Specifies to how many processes data will be sent. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classug_1_1_binary_buffer.html#ac696123c44faa5d08b4ee340311c25f0">ug::BinaryBuffer::clear()</a>, <a class="el" href="group__ugbase__common__util.html#ga0c629a903fff8db003dafaf36aca4db7">ug::GetDataPtr()</a>, <a class="el" href="pcl__profiling_8h.html#a2ed0c268a471877fea32f207d9ad4908">PCL_PROFILE</a>, <a class="el" href="classug_1_1_binary_buffer.html#a4cbcf7f6b48ec299252eabb0c2910434">ug::BinaryBuffer::reserve()</a>, and <a class="el" href="group__pcl.html#ga65ebca4d784f8d31cbd34ee084257c85">pcl::Waitall()</a>.</p>

</div>
</div>
<a id="ad8eec965d9be3c758db248c3ab063c92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8eec965d9be3c758db248c3ab063c92">&#9670;&nbsp;</a></span>distribute_data() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::ProcessCommunicator::distribute_data </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pBufferOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pBufferOutSegSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pSenderProcMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numSenderProcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pBufferSegSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pRecvProcMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numRecvProcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tag</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sends and receives data to / from multiple processes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBufferOut</td><td>Received data is written to this buffer. Make sure that this buffer is big enough (sum of all seg-sizes). </td></tr>
    <tr><td class="paramname">pBufferOutSegSizes</td><td>i-th entry corresponds to the size of the i-th segment of pBufferOut. </td></tr>
    <tr><td class="paramname">pSenderProcMap</td><td>The processes from which data is received. </td></tr>
    <tr><td class="paramname">numSenderProcs</td><td>The number of processes from which data is received. Has to be the same as the size of pBufferOutSegSizes and pSenderProcMap.</td></tr>
    <tr><td class="paramname">pBuffer</td><td>Holds the data that is to be send to other processes. </td></tr>
    <tr><td class="paramname">pBufferSegSizes</td><td>i-th entry corresponds to the size of the i-th segment in pBuffer. </td></tr>
    <tr><td class="paramname">pRecvProcMap</td><td>ranks of processes to which data will be send. </td></tr>
    <tr><td class="paramname">numRecvProcs</td><td>Number of processes in pRecvProcMap. Also corresponds to the size of pBufferSegSizes and to the number of segments in pBuffer. </td></tr>
    <tr><td class="paramname">tag</td><td>This tag will be used to identify send and received messages. Default: 1 </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="pcl__profiling_8h.html#a2ed0c268a471877fea32f207d9ad4908">PCL_PROFILE</a>, <a class="el" href="group__ugbase__common.html#gaf0ce958f12c62aa44c231a700b830374">UG_COND_THROW</a>, and <a class="el" href="group__pcl.html#ga65ebca4d784f8d31cbd34ee084257c85">pcl::Waitall()</a>.</p>

<p class="reference">Referenced by <a class="el" href="namespaceug.html#a2f0d6a6a6c86e392285e3463ab2ea9a5">ug::DistributeGrid()</a>.</p>

</div>
</div>
<a id="a3884294afa70a363fc8529a1f08c3053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3884294afa70a363fc8529a1f08c3053">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcl::ProcessCommunicator::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns true if the communicator is empty, false if not. </p>

<p class="reference">References <a class="el" href="classpcl_1_1_process_communicator.html#a3be8df02f7591a7fd79d2a16a27b85ff">is_local()</a>, <a class="el" href="classpcl_1_1_process_communicator.html#a02a2e0dc57c2fedbba3fff6e455948f1">m_comm</a>, and <a class="el" href="structpcl_1_1_process_communicator_1_1_comm_wrapper.html#a526045ba8f8655ccdc9e99bec84dd5b1">pcl::ProcessCommunicator::CommWrapper::m_mpiComm</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__pcl.html#ga944eeb7a85cdf4e14beba56bf4729e3e">pcl::AllProcsTrue()</a>, <a class="el" href="namespaceug.html#a592e71fc3a4e567b81a8d81cad64554c">ug::Deserialize()</a>, <a class="el" href="group__pcl.html#ga61412e843ef0b406b64d2d9841bf0c39">pcl::OneProcTrue()</a>, <a class="el" href="group__pcl.html#ga7b76c71ad0878b83af96a3fa9ed48d38">pcl::operator&lt;&lt;()</a>, <a class="el" href="namespaceug.html#a1e2f0b6aac231e9a09bd4bde94e27096">ug::PartitionMultiGridLevel_ParmetisKway()</a>, <a class="el" href="classug_1_1_partitioner___dynamic_bisection.html#a0ec79b301fa36b5f7968e7905cf8f5bb">ug::Partitioner_DynamicBisection&lt; TElem, dim &gt;::perform_bisection()</a>, <a class="el" href="classug_1_1_do_f_distribution.html#a9098093a6d988f252ec64ab4d0ff897c">ug::DoFDistribution::reinit_layouts_and_communicator()</a>, and <a class="el" href="group__pcl.html#ga8fca5b8a742b0713a303fa64e2e8cd4f">pcl::ToString()</a>.</p>

</div>
</div>
<a id="a4fcfbf45df86823b52fa0286a27539c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fcfbf45df86823b52fa0286a27539c4">&#9670;&nbsp;</a></span>gather() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::ProcessCommunicator::gather </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>sendBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sendCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__pcl.html#ga0a4745c93f155cc512175ca74c049c6c">DataType</a>&#160;</td>
          <td class="paramname"><em>sendType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>recBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>recCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__pcl.html#ga0a4745c93f155cc512175ca74c049c6c">DataType</a>&#160;</td>
          <td class="paramname"><em>recType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>performs MPI_Gather on the processes of the communicator. </p>
<p>This method synchronises involved processes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sendBuf</td><td>starting address of send buffer (choice) </td></tr>
    <tr><td class="paramname">sendCount</td><td>number of elements in send buffer (integer) </td></tr>
    <tr><td class="paramname">sendType</td><td>data type of send buffer elements (handle) </td></tr>
    <tr><td class="paramname">recBuf</td><td>only significant for root process. All gathered data is written here. </td></tr>
    <tr><td class="paramname">recCount</td><td>number of elements received from each process (integer) </td></tr>
    <tr><td class="paramname">recType</td><td>data type of receive buffer elements (handle) </td></tr>
    <tr><td class="paramname">root</td><td>The rank of the process that receives all the data. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="namespaceug.html#ae49e2879be5e2ce34a8a9db509c497ee">ug::GetSize()</a>, <a class="el" href="pcl__profiling_8h.html#a2ed0c268a471877fea32f207d9ad4908">PCL_PROFILE</a>, and <a class="el" href="group__ugbase__common.html#gaf0ce958f12c62aa44c231a700b830374">UG_COND_THROW</a>.</p>

<p class="reference">Referenced by <a class="el" href="namespaceug.html#a207b43e7431f56746521de393a8f3fda">ug::BuildOneToManyLayout()</a>, <a class="el" href="namespaceug.html#acf03e74faf12710e6b5735d05a5b25b1">ug::GatherGrid()</a>, <a class="el" href="classpcl_1_1_process_communicator.html#a52bb8ff22163e2734f3420c0a57e8c77">gatherv()</a>, <a class="el" href="namespaceug.html#a18b06f5618d879be669451b63ecedcbb">ug::GenerateGlobalConsecutiveIndices()</a>, <a class="el" href="group__pcl.html#ga25fcc02d60112f3e50adaffdba369d2e">pcl::MinimalKeyValuePairAcrossAllProcs()</a>, <a class="el" href="group__pcl.html#gabab6c185c6357a55c2c8ca70abed4d91">pcl::SendRecvBuffersMatch()</a>, and <a class="el" href="group__pcl.html#ga5a0a84167219d54a9147374c16f5b128">pcl::SendRecvListsMatch()</a>.</p>

</div>
</div>
<a id="a16f54e4a5dbc9be37f8add19295a5abe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16f54e4a5dbc9be37f8add19295a5abe">&#9670;&nbsp;</a></span>gather() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::ProcessCommunicator::gather </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_binary_buffer.html">ug::BinaryBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>gather of BinaryBuffers </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Binary buffer in/out </td></tr>
    <tr><td class="paramname">root</td><td>root processor </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classug_1_1_binary_buffer.html#a1ff86563b8133d53b9293d4ec45484d6">ug::BinaryBuffer::buffer()</a>, <a class="el" href="group__pcl.html#ga9bb316e25297f10531ad5e41b0513f63">PCL_DT_CHAR</a>, <a class="el" href="group__pcl.html#gafb0837e727561ea889dde9a8e3163e93">PCL_DT_INT</a>, <a class="el" href="group__pcl.html#ga319e84518e2b596fc9f9b40b4383ec36">pcl::ProcRank()</a>, <a class="el" href="classug_1_1_binary_buffer.html#a4cbcf7f6b48ec299252eabb0c2910434">ug::BinaryBuffer::reserve()</a>, <a class="el" href="classug_1_1_binary_buffer.html#a39f333c178a905687b80654132f7e8ba">ug::BinaryBuffer::set_write_pos()</a>, and <a class="el" href="classug_1_1_binary_buffer.html#acb333d1a7093992faa6b2c2a6dc6f046">ug::BinaryBuffer::write_pos()</a>.</p>

</div>
</div>
<a id="a5b8ffa08f3915dbae9f099d55ef4533d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b8ffa08f3915dbae9f099d55ef4533d">&#9670;&nbsp;</a></span>gatherv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::ProcessCommunicator::gatherv </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>sendBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sendCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__pcl.html#ga0a4745c93f155cc512175ca74c049c6c">DataType</a>&#160;</td>
          <td class="paramname"><em>sendType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>recBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>recCounts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>displs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__pcl.html#ga0a4745c93f155cc512175ca74c049c6c">DataType</a>&#160;</td>
          <td class="paramname"><em>recType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>performs MPI_Gatherv on the processes of the communicator. </p>
<p>This method synchronises involved processes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sendBuf</td><td>starting address of send buffer (choice) </td></tr>
    <tr><td class="paramname">sendCount</td><td>number of elements in send buffer (integer) </td></tr>
    <tr><td class="paramname">sendType</td><td>data type of send buffer elements (handle) </td></tr>
    <tr><td class="paramname">recCounts</td><td>integer array (of length group size) containing the number of elements that are received from each process. (Only significant at root) </td></tr>
    <tr><td class="paramname">recBuf</td><td>starting address of receive buffer (choice) (Only significant at root) </td></tr>
    <tr><td class="paramname">displs</td><td>integer array (of length group size). Entry i specifies the displacement (relative to recvbuf ) at which to place the incoming data from process i. (Only significant at root) </td></tr>
    <tr><td class="paramname">recType</td><td>data type of receive buffer elements (handle). (Only significant at root) </td></tr>
    <tr><td class="paramname">root</td><td>The rank of the process that receives all the data. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="namespaceug.html#ae49e2879be5e2ce34a8a9db509c497ee">ug::GetSize()</a>, <a class="el" href="pcl__profiling_8h.html#a2ed0c268a471877fea32f207d9ad4908">PCL_PROFILE</a>, and <a class="el" href="group__ugbase__common.html#gaf0ce958f12c62aa44c231a700b830374">UG_COND_THROW</a>.</p>

<p class="reference">Referenced by <a class="el" href="namespaceug.html#a207b43e7431f56746521de393a8f3fda">ug::BuildOneToManyLayout()</a>, <a class="el" href="classpcl_1_1_process_communicator.html#a52bb8ff22163e2734f3420c0a57e8c77">gatherv()</a>, and <a class="el" href="classug_1_1_expected_error_marking_strategy.html#a9e673dcf4eea5e5c1eb197ddba7ee392">ug::ExpectedErrorMarkingStrategy&lt; TDomain &gt;::mark()</a>.</p>

</div>
</div>
<a id="a52bb8ff22163e2734f3420c0a57e8c77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52bb8ff22163e2734f3420c0a57e8c77">&#9670;&nbsp;</a></span>gatherv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TValue &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::ProcessCommunicator::gatherv </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; TValue &gt; &amp;&#160;</td>
          <td class="paramname"><em>recBufOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; TValue &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>pSizesOut</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>pOffsetsOut</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gathers variable arrays on one process. </p>
<p>The arrays specified in sendBuf will be copied to recBufOut on root. recBufOut is thus only important on root. The order of the arrays is the same as the order of the sending processes in this ProcessCommnicator. You can optionally specify an array pSizesOut, which will be filled with the size of the array that was received from each process (only relevant on root) and an array in which the offsets of each array are stored - that means the first index of each array - again in the order of processes in this <a class="el" href="classpcl_1_1_process_communicator.html">ProcessCommunicator</a> (only relevant on root, too).</p>
<p>Note that recBufOut, pSizesOut and pOffsetsOut will be resized as required.</p>
<p>Please note that this method communicates twice. </p>

<p class="reference">References <a class="el" href="classpcl_1_1_process_communicator.html#a4fcfbf45df86823b52fa0286a27539c4">gather()</a>, <a class="el" href="classpcl_1_1_process_communicator.html#a5b8ffa08f3915dbae9f099d55ef4533d">gatherv()</a>, <a class="el" href="group__ugbase__common__util.html#ga0c629a903fff8db003dafaf36aca4db7">ug::GetDataPtr()</a>, <a class="el" href="classpcl_1_1_process_communicator.html#a3be8df02f7591a7fd79d2a16a27b85ff">is_local()</a>, <a class="el" href="group__pcl.html#ga7a54f12d845f53f9da3bef2474c1fc8c">PCL_DT_BYTE</a>, <a class="el" href="group__pcl.html#gafb0837e727561ea889dde9a8e3163e93">PCL_DT_INT</a>, and <a class="el" href="classpcl_1_1_process_communicator.html#a71686860dd00b51ca298088864f76417">size()</a>.</p>

</div>
</div>
<a id="ae4d016ec21680cf611dbb0fc00269306"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4d016ec21680cf611dbb0fc00269306">&#9670;&nbsp;</a></span>get_local_proc_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcl::ProcessCommunicator::get_local_proc_id </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>globalProcID</em> = <code><a class="el" href="group__pcl.html#ga319e84518e2b596fc9f9b40b4383ec36">pcl::ProcRank</a>()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the proc-id relative to this communicator </p>
<p>This method has a worst time complexity of O(n) </p>

<p class="reference">References <a class="el" href="pcl__comm__world_8cpp.html#aeea8035bdcb7db449f8b4dcc738a8969">PCL_COMM_WORLD</a>, <a class="el" href="group__pcl.html#ga319e84518e2b596fc9f9b40b4383ec36">pcl::ProcRank()</a>, <a class="el" href="group__ugbase__common.html#ga0b928ef153b78f1b5e025638cf28f841">UG_ASSERT</a>, and <a class="el" href="group__ugbase__common.html#ga849480b16e1d7c49266a92cd5db63942">UG_LOG</a>.</p>

<p class="reference">Referenced by <a class="el" href="classpcl_1_1_multi_group_communicator.html#ab6a91548babd4edfcf5302b39380f45e">pcl::MultiGroupCommunicator::allreduce()</a>, <a class="el" href="namespaceug.html#a6ed058cbee1614968febd7e711d7dcc9">ug::ConstructParallelDualGraphMGLevel()</a>, <a class="el" href="namespaceug.html#acf03e74faf12710e6b5735d05a5b25b1">ug::GatherGrid()</a>, <a class="el" href="namespaceug.html#a18b06f5618d879be669451b63ecedcbb">ug::GenerateGlobalConsecutiveIndices()</a>, <a class="el" href="group__pcl.html#ga08d85b285b592ad668f6446928aee4bc">pcl::TestLayoutIsDoubleEnded()</a>, and <a class="el" href="namespacepcl.html#ab349ffe9238050c07229493cace38f1c">pcl::WriteParallelArchive()</a>.</p>

</div>
</div>
<a id="a17e4ed6988d07c2682c713e79806ac66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17e4ed6988d07c2682c713e79806ac66">&#9670;&nbsp;</a></span>get_mpi_communicator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MPI_Comm pcl::ProcessCommunicator::get_mpi_communicator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the mpi-communicator, in case someone needs it </p>

<p class="reference">References <a class="el" href="classpcl_1_1_process_communicator.html#a02a2e0dc57c2fedbba3fff6e455948f1">m_comm</a>, and <a class="el" href="structpcl_1_1_process_communicator_1_1_comm_wrapper.html#a526045ba8f8655ccdc9e99bec84dd5b1">pcl::ProcessCommunicator::CommWrapper::m_mpiComm</a>.</p>

<p class="reference">Referenced by <a class="el" href="classpcl_1_1_multi_group_communicator.html#ab6a91548babd4edfcf5302b39380f45e">pcl::MultiGroupCommunicator::allreduce()</a>, <a class="el" href="namespaceug.html#a1e2f0b6aac231e9a09bd4bde94e27096">ug::PartitionMultiGridLevel_ParmetisKway()</a>, <a class="el" href="namespacepcl.html#a9ae389bbda3f230eac0fa54dded2c48f">pcl::ReadCombinedParallelFile()</a>, <a class="el" href="namespacepcl.html#ab9bb13746730d31690291901fa01133c">pcl::WriteCombinedParallelFile()</a>, and <a class="el" href="namespacepcl.html#ab349ffe9238050c07229493cace38f1c">pcl::WriteParallelArchive()</a>.</p>

</div>
</div>
<a id="a1ee57f2d14bc6905066c814ce3030ed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ee57f2d14bc6905066c814ce3030ed3">&#9670;&nbsp;</a></span>get_proc_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcl::ProcessCommunicator::get_proc_id </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the i-th process in the communicator </p>

<p class="reference">References <a class="el" href="pcl__comm__world_8cpp.html#aeea8035bdcb7db449f8b4dcc738a8969">PCL_COMM_WORLD</a>, and <a class="el" href="group__pcl.html#ga319e84518e2b596fc9f9b40b4383ec36">pcl::ProcRank()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classpcl_1_1_multi_group_communicator.html#ab6a91548babd4edfcf5302b39380f45e">pcl::MultiGroupCommunicator::allreduce()</a>, <a class="el" href="namespaceug.html#a207b43e7431f56746521de393a8f3fda">ug::BuildOneToManyLayout()</a>, <a class="el" href="namespaceug.html#a6a792f5a70b2d8897199b5e05eca36cc">ug::CollectMatrixOnOneProc()</a>, <a class="el" href="group__pcl.html#gae69fa8589b1ee5449187b583e4f0e72e">pcl::CommunicateInvolvedProcesses()</a>, <a class="el" href="namespaceug_1_1_connection_viewer.html#af81102dba0ce8d102a584ebdb0c65cf4">ug::ConnectionViewer::GetParallelName()</a>, <a class="el" href="classug_1_1_primal_subassembled_matrix_inverse.html#a86c371a48729bd72c6b983f24883f549">ug::PrimalSubassembledMatrixInverse&lt; TAlgebra &gt;::init()</a>, <a class="el" href="classpcl_1_1_process_communicator.html#a0598776412b0d684abc5505c9755bbfe">is_proc_id()</a>, <a class="el" href="group__pcl.html#ga7b76c71ad0878b83af96a3fa9ed48d38">pcl::operator&lt;&lt;()</a>, <a class="el" href="namespacepcl.html#a97c0165d61cd066e4bcaa670824624fb">pcl::ParallelReadFile()</a>, <a class="el" href="group__pcl.html#gad2cec5ff0b372513d3d9f9e88d97ded8">pcl::PrintPC()</a>, <a class="el" href="namespacepcl.html#a9ae389bbda3f230eac0fa54dded2c48f">pcl::ReadCombinedParallelFile()</a>, <a class="el" href="group__pcl.html#gabab6c185c6357a55c2c8ca70abed4d91">pcl::SendRecvBuffersMatch()</a>, <a class="el" href="group__pcl.html#ga5a0a84167219d54a9147374c16f5b128">pcl::SendRecvListsMatch()</a>, <a class="el" href="namespaceug.html#aadeddb3eabbdf0bb8c35c3495623a077">ug::Serialize()</a>, <a class="el" href="group__pcl.html#ga08d85b285b592ad668f6446928aee4bc">pcl::TestLayoutIsDoubleEnded()</a>, <a class="el" href="group__pcl.html#ga8fca5b8a742b0713a303fa64e2e8cd4f">pcl::ToString()</a>, <a class="el" href="namespacepcl.html#ab9bb13746730d31690291901fa01133c">pcl::WriteCombinedParallelFile()</a>, <a class="el" href="namespaceug_1_1_connection_viewer.html#a9b4f71249c9f546d7d831751a080f8d9">ug::ConnectionViewer::WriteMatrixPar()</a>, and <a class="el" href="namespacepcl.html#ab349ffe9238050c07229493cace38f1c">pcl::WriteParallelArchive()</a>.</p>

</div>
</div>
<a id="a3be8df02f7591a7fd79d2a16a27b85ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3be8df02f7591a7fd79d2a16a27b85ff">&#9670;&nbsp;</a></span>is_local()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcl::ProcessCommunicator::is_local </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return true if the communicator is local, simulating current proc is the only proc </p>

<p class="reference">References <a class="el" href="classpcl_1_1_process_communicator.html#a02a2e0dc57c2fedbba3fff6e455948f1">m_comm</a>, and <a class="el" href="class_smart_ptr.html#ab31be10adb38f2b205f0531bb23e7a23">SmartPtr&lt; T, FreePolicy &gt;::valid()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classpcl_1_1_process_communicator.html#a3bee065c42d30fb67fed65e70e5c534b">allgatherv()</a>, <a class="el" href="group__pcl.html#ga944eeb7a85cdf4e14beba56bf4729e3e">pcl::AllProcsTrue()</a>, <a class="el" href="classpcl_1_1_process_communicator.html#a3884294afa70a363fc8529a1f08c3053">empty()</a>, <a class="el" href="classpcl_1_1_process_communicator.html#a52bb8ff22163e2734f3420c0a57e8c77">gatherv()</a>, <a class="el" href="classpcl_1_1_process_communicator.html#a50707e6de72a8865546e71249c87f256">is_world()</a>, <a class="el" href="group__pcl.html#ga61412e843ef0b406b64d2d9841bf0c39">pcl::OneProcTrue()</a>, and <a class="el" href="group__pcl.html#ga7b76c71ad0878b83af96a3fa9ed48d38">pcl::operator&lt;&lt;()</a>.</p>

</div>
</div>
<a id="a0598776412b0d684abc5505c9755bbfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0598776412b0d684abc5505c9755bbfe">&#9670;&nbsp;</a></span>is_proc_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcl::ProcessCommunicator::is_proc_id </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns true if we are the i-th process in the communicator </p>

<p class="reference">References <a class="el" href="classpcl_1_1_process_communicator.html#a1ee57f2d14bc6905066c814ce3030ed3">get_proc_id()</a>, and <a class="el" href="group__pcl.html#ga319e84518e2b596fc9f9b40b4383ec36">pcl::ProcRank()</a>.</p>

</div>
</div>
<a id="a50707e6de72a8865546e71249c87f256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50707e6de72a8865546e71249c87f256">&#9670;&nbsp;</a></span>is_world()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcl::ProcessCommunicator::is_world </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return true if the communicator is PCD_WORLD </p>

<p class="reference">References <a class="el" href="classpcl_1_1_process_communicator.html#a3be8df02f7591a7fd79d2a16a27b85ff">is_local()</a>, <a class="el" href="classpcl_1_1_process_communicator.html#a02a2e0dc57c2fedbba3fff6e455948f1">m_comm</a>, <a class="el" href="structpcl_1_1_process_communicator_1_1_comm_wrapper.html#a526045ba8f8655ccdc9e99bec84dd5b1">pcl::ProcessCommunicator::CommWrapper::m_mpiComm</a>, and <a class="el" href="pcl__comm__world_8cpp.html#aeea8035bdcb7db449f8b4dcc738a8969">PCL_COMM_WORLD</a>.</p>

<p class="reference">Referenced by <a class="el" href="namespaceug.html#a592e71fc3a4e567b81a8d81cad64554c">ug::Deserialize()</a>, <a class="el" href="group__pcl.html#ga7b76c71ad0878b83af96a3fa9ed48d38">pcl::operator&lt;&lt;()</a>, <a class="el" href="namespaceug.html#aadeddb3eabbdf0bb8c35c3495623a077">ug::Serialize()</a>, and <a class="el" href="group__pcl.html#ga8fca5b8a742b0713a303fa64e2e8cd4f">pcl::ToString()</a>.</p>

</div>
</div>
<a id="a05092910cd2be254b90517b826f161dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05092910cd2be254b90517b826f161dc">&#9670;&nbsp;</a></span>receive_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::ProcessCommunicator::receive_data </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pBuffOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcProc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>receives data from srcPrc with the specified tag. </p>
<p>This method waits until the data has been received </p>

<p class="reference">References <a class="el" href="group__pcl.html#ga0e1f92a7b690c37a0620ce7cfb3ca836">pcl::MPI_Wait()</a>, <a class="el" href="pcl__profiling_8h.html#a2ed0c268a471877fea32f207d9ad4908">PCL_PROFILE</a>, and <a class="el" href="group__ugbase__common.html#gaf0ce958f12c62aa44c231a700b830374">UG_COND_THROW</a>.</p>

<p class="reference">Referenced by <a class="el" href="classug_1_1_b_g_l_parallel_matrix.html#abc13d0bddab7193fceb897cb085eec51">ug::BGLParallelMatrix&lt; T &gt;::refresh()</a>.</p>

</div>
</div>
<a id="afc1278b823fde31e98bb40bb762c1d68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc1278b823fde31e98bb40bb762c1d68">&#9670;&nbsp;</a></span>reduce() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t pcl::ProcessCommunicator::reduce </td>
          <td>(</td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__pcl.html#ga774ab56d0811cccca811df2e62bc0939">pcl::ReduceOperation</a>&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rootProc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>overload for size_t </p>

<p class="reference">References <a class="el" href="group__pcl.html#ga2f305bfd28aca5a7ca28a665e09cab70">PCL_DT_UNSIGNED_LONG_LONG</a>.</p>

</div>
</div>
<a id="a76ef6e0acca1ed086c6637fd2a5038f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76ef6e0acca1ed086c6637fd2a5038f0">&#9670;&nbsp;</a></span>reduce() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::ProcessCommunicator::reduce </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>send</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>receive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__pcl.html#ga774ab56d0811cccca811df2e62bc0939">pcl::ReduceOperation</a>&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rootProc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>simplified reduce for std::vector. The receive-buffer is automatically resized as required. </p>

<p class="reference">References <a class="el" href="classpcl_1_1_process_communicator.html#a4c801054145d47043b1b43469374f53f">reduce()</a>.</p>

</div>
</div>
<a id="a64dc03b878f29fadd43841940c6c5d2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64dc03b878f29fadd43841940c6c5d2b">&#9670;&nbsp;</a></span>reduce() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T pcl::ProcessCommunicator::reduce </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__pcl.html#ga774ab56d0811cccca811df2e62bc0939">pcl::ReduceOperation</a>&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rootProc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>simplified reduce for size=1. calls reduce for parameter t, and then returns the result compiler error for unsupported datatypes </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the input parameter </td></tr>
    <tr><td class="paramname">op</td><td>the Reduce Operation </td></tr>
    <tr><td class="paramname">rootProc</td><td>the process onto which the result will be reduced. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the reduced result </dd></dl>

<p class="reference">References <a class="el" href="classpcl_1_1_process_communicator.html#a4c801054145d47043b1b43469374f53f">reduce()</a>.</p>

</div>
</div>
<a id="a8bc4017d78ba768577776b939bd6ca5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bc4017d78ba768577776b939bd6ca5e">&#9670;&nbsp;</a></span>reduce() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pcl::ProcessCommunicator::reduce </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>pSendBuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>pReceiveBuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__pcl.html#ga774ab56d0811cccca811df2e62bc0939">pcl::ReduceOperation</a>&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rootProc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>simplified reduce for buffers. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pSendBuff</td><td>the input buffer </td></tr>
    <tr><td class="paramname">pReceiveBuff</td><td>the output buffer </td></tr>
    <tr><td class="paramname">count</td><td>number of elements in the input/output buffers </td></tr>
    <tr><td class="paramname">op</td><td>the Reduce Operation </td></tr>
    <tr><td class="paramname">rootProc</td><td>the process onto which the result will be reduced. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classpcl_1_1_process_communicator.html#a4c801054145d47043b1b43469374f53f">reduce()</a>.</p>

</div>
</div>
<a id="a4c801054145d47043b1b43469374f53f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c801054145d47043b1b43469374f53f">&#9670;&nbsp;</a></span>reduce() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::ProcessCommunicator::reduce </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>sendBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>recBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__pcl.html#ga0a4745c93f155cc512175ca74c049c6c">DataType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__pcl.html#ga774ab56d0811cccca811df2e62bc0939">ReduceOperation</a>&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rootProc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>performs MPI_Reduce on the processes of the communicator. </p>
<p>This method synchronises involved processes. </p>

<p class="reference">References <a class="el" href="namespaceug.html#ae49e2879be5e2ce34a8a9db509c497ee">ug::GetSize()</a>, <a class="el" href="pcl__profiling_8h.html#a2ed0c268a471877fea32f207d9ad4908">PCL_PROFILE</a>, and <a class="el" href="group__ugbase__common.html#gaf0ce958f12c62aa44c231a700b830374">UG_COND_THROW</a>.</p>

<p class="reference">Referenced by <a class="el" href="classpcl_1_1_process_communicator.html#a64dc03b878f29fadd43841940c6c5d2b">reduce()</a>, and <a class="el" href="classug_1_1_do_f_count.html#a379cf8d03a0c7c4b2d94debac4d08d24">ug::DoFCount::sum_values_over_procs()</a>.</p>

</div>
</div>
<a id="a871a5c6031d12beeab7a2eb28c347609"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a871a5c6031d12beeab7a2eb28c347609">&#9670;&nbsp;</a></span>scatter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::ProcessCommunicator::scatter </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>sendBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sendCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__pcl.html#ga0a4745c93f155cc512175ca74c049c6c">DataType</a>&#160;</td>
          <td class="paramname"><em>sendType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>recBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>recCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__pcl.html#ga0a4745c93f155cc512175ca74c049c6c">DataType</a>&#160;</td>
          <td class="paramname"><em>recType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>performs MPI_Scatter on the processes of the communicator </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sendBuf</td><td>starting address of send buffer (choice) </td></tr>
    <tr><td class="paramname">sendCount</td><td>number of elements in send buffer (integer) </td></tr>
    <tr><td class="paramname">sendType</td><td>data type of send buffer elements (handle) </td></tr>
    <tr><td class="paramname">recBuf</td><td>only significant for root process. All gathered data is written here. </td></tr>
    <tr><td class="paramname">recCount</td><td>number of elements received from each process (integer) </td></tr>
    <tr><td class="paramname">recType</td><td>data type of receive buffer elements (handle) </td></tr>
    <tr><td class="paramname">root</td><td>The rank of the process that receives all the data. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="namespaceug.html#ae49e2879be5e2ce34a8a9db509c497ee">ug::GetSize()</a>, <a class="el" href="pcl__profiling_8h.html#a2ed0c268a471877fea32f207d9ad4908">PCL_PROFILE</a>, and <a class="el" href="group__ugbase__common.html#gaf0ce958f12c62aa44c231a700b830374">UG_COND_THROW</a>.</p>

<p class="reference">Referenced by <a class="el" href="namespaceug.html#a18b06f5618d879be669451b63ecedcbb">ug::GenerateGlobalConsecutiveIndices()</a>, and <a class="el" href="classug_1_1_expected_error_marking_strategy.html#a9e673dcf4eea5e5c1eb197ddba7ee392">ug::ExpectedErrorMarkingStrategy&lt; TDomain &gt;::mark()</a>.</p>

</div>
</div>
<a id="add034ef451a1099e427a05c64650b928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add034ef451a1099e427a05c64650b928">&#9670;&nbsp;</a></span>send_data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::ProcessCommunicator::send_data </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pBufferSegSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pRecProcMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numRecProcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sends data in different blocks of pBuffer to the processes in pRecProcMap. </p>
<p>This method synchronises involved processes. Call receive_data on the processes in pRecProcMap to receive the sent data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuffer</td><td>Blocks of data. The i-th block is send to the i-th process of pRecProcMap. </td></tr>
    <tr><td class="paramname">pBufferSegSizes</td><td>The i-th entry holds the size of the i-th block in pBuffer. </td></tr>
    <tr><td class="paramname">pRecProcMap</td><td>The i-th entry holds the process-rank to which the i-th block shall be send. </td></tr>
    <tr><td class="paramname">numRecProcs</td><td>The number of processes to which data shall be send. Note that pBufferSegSizes and pRecProcMap have to have numRecProcs entries. </td></tr>
    <tr><td class="paramname">tag</td><td>A tag that tags the message. Use the same tag in receive_data. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="pcl__profiling_8h.html#a2ed0c268a471877fea32f207d9ad4908">PCL_PROFILE</a>, <a class="el" href="group__ugbase__common.html#gaf0ce958f12c62aa44c231a700b830374">UG_COND_THROW</a>, and <a class="el" href="group__pcl.html#ga65ebca4d784f8d31cbd34ee084257c85">pcl::Waitall()</a>.</p>

</div>
</div>
<a id="a38c3135b38428345ff55c2f77636dc6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38c3135b38428345ff55c2f77636dc6c">&#9670;&nbsp;</a></span>send_data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcl::ProcessCommunicator::send_data </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destProc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sends data with the given tag to the specified process. </p>
<p>This method waits until the data has been sent. </p>

<p class="reference">References <a class="el" href="group__pcl.html#ga0e1f92a7b690c37a0620ce7cfb3ca836">pcl::MPI_Wait()</a>, <a class="el" href="pcl__profiling_8h.html#a2ed0c268a471877fea32f207d9ad4908">PCL_PROFILE</a>, and <a class="el" href="group__ugbase__common.html#gaf0ce958f12c62aa44c231a700b830374">UG_COND_THROW</a>.</p>

<p class="reference">Referenced by <a class="el" href="classug_1_1_b_g_l_parallel_matrix.html#abc13d0bddab7193fceb897cb085eec51">ug::BGLParallelMatrix&lt; T &gt;::refresh()</a>.</p>

</div>
</div>
<a id="a71686860dd00b51ca298088864f76417"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71686860dd00b51ca298088864f76417">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t pcl::ProcessCommunicator::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the size of the communicator </p>

<p class="reference">References <a class="el" href="group__ugbase__common.html#ga849480b16e1d7c49266a92cd5db63942">UG_LOG</a>.</p>

<p class="reference">Referenced by <a class="el" href="namespaceug.html#ade184baefd6bcf45fee96ba55b5aba4e">ug::AllGatherGrid()</a>, <a class="el" href="classpcl_1_1_process_communicator.html#a3bee065c42d30fb67fed65e70e5c534b">allgatherv()</a>, <a class="el" href="classpcl_1_1_process_communicator.html#a5155ae618f8fe76850b33760a7c80505">broadcast()</a>, <a class="el" href="namespaceug.html#a207b43e7431f56746521de393a8f3fda">ug::BuildOneToManyLayout()</a>, <a class="el" href="namespaceug.html#a6a792f5a70b2d8897199b5e05eca36cc">ug::CollectMatrixOnOneProc()</a>, <a class="el" href="group__pcl.html#gae69fa8589b1ee5449187b583e4f0e72e">pcl::CommunicateInvolvedProcesses()</a>, <a class="el" href="namespaceug.html#a6ed058cbee1614968febd7e711d7dcc9">ug::ConstructParallelDualGraphMGLevel()</a>, <a class="el" href="classug_1_1_load_balancer.html#a57b4a64c857aa4514e3691d88cc0b711">ug::LoadBalancer::estimate_distribution_quality_impl()</a>, <a class="el" href="namespaceug.html#acf03e74faf12710e6b5735d05a5b25b1">ug::GatherGrid()</a>, <a class="el" href="classpcl_1_1_process_communicator.html#a52bb8ff22163e2734f3420c0a57e8c77">gatherv()</a>, <a class="el" href="namespaceug.html#a18b06f5618d879be669451b63ecedcbb">ug::GenerateGlobalConsecutiveIndices()</a>, <a class="el" href="namespaceug_1_1_connection_viewer.html#af81102dba0ce8d102a584ebdb0c65cf4">ug::ConnectionViewer::GetParallelName()</a>, <a class="el" href="classug_1_1_primal_subassembled_matrix_inverse.html#a86c371a48729bd72c6b983f24883f549">ug::PrimalSubassembledMatrixInverse&lt; TAlgebra &gt;::init()</a>, <a class="el" href="group__pcl.html#ga7b76c71ad0878b83af96a3fa9ed48d38">pcl::operator&lt;&lt;()</a>, <a class="el" href="namespaceug.html#a1e2f0b6aac231e9a09bd4bde94e27096">ug::PartitionMultiGridLevel_ParmetisKway()</a>, <a class="el" href="group__pcl.html#gad2cec5ff0b372513d3d9f9e88d97ded8">pcl::PrintPC()</a>, <a class="el" href="namespacepcl.html#a9ae389bbda3f230eac0fa54dded2c48f">pcl::ReadCombinedParallelFile()</a>, <a class="el" href="classpcl_1_1_multi_group_communicator.html#abbeca81eb4f4a161ea44d8d8a42b11bc">pcl::MultiGroupCommunicator::reinit()</a>, <a class="el" href="group__pcl.html#gabab6c185c6357a55c2c8ca70abed4d91">pcl::SendRecvBuffersMatch()</a>, <a class="el" href="group__pcl.html#ga5a0a84167219d54a9147374c16f5b128">pcl::SendRecvListsMatch()</a>, <a class="el" href="namespaceug.html#aadeddb3eabbdf0bb8c35c3495623a077">ug::Serialize()</a>, <a class="el" href="group__pcl.html#ga08d85b285b592ad668f6446928aee4bc">pcl::TestLayoutIsDoubleEnded()</a>, <a class="el" href="group__pcl.html#ga8fca5b8a742b0713a303fa64e2e8cd4f">pcl::ToString()</a>, <a class="el" href="namespacepcl.html#ab9bb13746730d31690291901fa01133c">pcl::WriteCombinedParallelFile()</a>, <a class="el" href="namespaceug_1_1_connection_viewer.html#a9b4f71249c9f546d7d831751a080f8d9">ug::ConnectionViewer::WriteMatrixPar()</a>, and <a class="el" href="namespacepcl.html#ab349ffe9238050c07229493cace38f1c">pcl::WriteParallelArchive()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a02a2e0dc57c2fedbba3fff6e455948f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02a2e0dc57c2fedbba3fff6e455948f1">&#9670;&nbsp;</a></span>m_comm</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcl_1_1_process_communicator.html#ae690206ce86e0af9c5739008aa5bd096">SPCommWrapper</a> pcl::ProcessCommunicator::m_comm</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>smart-pointer to an instance of a <a class="el" href="structpcl_1_1_process_communicator_1_1_comm_wrapper.html" title="holds an mpi-communicator.">CommWrapper</a>. </p>

<p class="reference">Referenced by <a class="el" href="classpcl_1_1_process_communicator.html#a1ab7c861d3d2ba66df6f993538730335">create_communicator()</a>, <a class="el" href="classpcl_1_1_process_communicator.html#af93712470b06d42fd4e5222415701927">create_sub_communicator()</a>, <a class="el" href="classpcl_1_1_process_communicator.html#a3884294afa70a363fc8529a1f08c3053">empty()</a>, <a class="el" href="classpcl_1_1_process_communicator.html#a17e4ed6988d07c2682c713e79806ac66">get_mpi_communicator()</a>, <a class="el" href="classpcl_1_1_process_communicator.html#a3be8df02f7591a7fd79d2a16a27b85ff">is_local()</a>, and <a class="el" href="classpcl_1_1_process_communicator.html#a50707e6de72a8865546e71249c87f256">is_world()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>ugbase/pcl/<a class="el" href="pcl__process__communicator_8h_source.html">pcl_process_communicator.h</a></li>
<li>ugbase/pcl/<a class="el" href="pcl__process__communicator_8cpp.html">pcl_process_communicator.cpp</a></li>
<li>ugbase/pcl/<a class="el" href="pcl__process__communicator__impl_8hpp_source.html">pcl_process_communicator_impl.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacepcl.html">pcl</a></li><li class="navelem"><a class="el" href="classpcl_1_1_process_communicator.html">ProcessCommunicator</a></li>
    <li class="footer">Generated on Mon Mar 18 2024 00:54:52 for ug4 by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
