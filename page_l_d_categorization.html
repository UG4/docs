<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ug4: Categorization of Problems</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ug4
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('page_l_d_categorization.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Categorization of Problems </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In order to discretize a problem as presented in <a class="el" href="page_l_d_assembling_concept.html#secGeneralProblemDescribtion">General Problem Description</a> the different problems can be categorized into several classes. All classes of problems can be implemented in a general framework.</p>
<ul>
<li><a class="el" href="page_l_d_categorization.html#secDomainDiscretization">Domain Discretizaion</a></li>
<li><a class="el" href="page_l_d_categorization.html#secStationaryLinearDiscretization">Linear Stationary Problems</a></li>
<li><a class="el" href="page_l_d_categorization.html#secStationaryNonLinearDiscretization">Non-Linear Stationary Problems</a></li>
<li><a class="el" href="page_l_d_categorization.html#secTimeDiscretization">Time Discretization</a></li>
<li><a class="el" href="page_l_d_categorization.html#secTimeDependentLinearDiscretization">Time-Dependent Linear Problems</a></li>
<li><a class="el" href="page_l_d_categorization.html#secTimeDependentNonLinearDiscretization">Time-Dependent Non-Linear Problems</a></li>
</ul>
<p><br  />
</p>
<hr  />
 <h1><a class="anchor" id="secDomainDiscretization"></a>
Domain Discretization</h1>
<hr  />
<p>Let the Domain \(\Omega\) be covered by a grid \(\Omega_h\). By choosing an appropriate trial space, each unknown continuous function \(u_i(\vec{x},t)\) is now approximated by an finite-dimensional numerical function \(u_{h,i}(\vec{x},t)\). For each function \(u_{h,i}\) a certain number of degrees of freedoms (DoF) has to distributed on the grid, being associated with the geometric objects. For example, one can think of piecewise linear functions on each grid elements, requiring one DoF per vertex of the element and no DoFs on the other Geometric Objects like edges or faces. Let \(N_{h,i}\) be the number of DoFs needed to represent the unknowns of the i'th function and let \(N_h = \sum_{i=1}^n N_{h,i}\) be the number DoFs needed for the whole problem. Each discrete function \(u_{h,i}\) is isomorphic to a representation in \(\mathbb{R}^{N_{h,i}}\), thus it can be represented by an algebraic vector \(\vec{u}_{h,i} \in \mathbb{R}^{N_{h,i}}\) and the entries of the vector \((\vec{u}_{h,i})_j \in \mathbb{R}\) are the DoFs of the function. By the same construction a representation for the system solution can be found.</p>
<p>To facilitate notations for the remainder of this page, let \(\vec{u} = \vec{u}_1\), i.e. it is a scalar problem. For systems of unknowns the ideas are straight forward. <br  />
</p>
<p>For the discretization of the PDE there are several possibilities.</p>
<ul>
<li>
finite difference method (FD) </li>
<li>
finite element method (FE) </li>
<li>
finite volume method (FV) </li>
<li>
discontinuous galerkin method (DG) </li>
</ul>
<p>This gives rise to discretized operators \(\mathcal{M}_h(\cdot)\) and \(\mathcal{A}_h(\cdot)\) and a discrete right-hand side \(\vec{f_h}\), with \( \mathcal{M}_h, \mathcal{A}_h: \mathbb{R}^{N_h} \mapsto \mathbb{R}^{N_h} \) and \(\vec{f_h} \in \mathbb{R}^{N_h}\).</p>
<p>The discrete problem can be written as </p><p class="formulaDsp">
\begin{align*} \partial_t \mathcal{M}_h(\vec{u}_h) + \mathcal{A}_h(\vec{u}_h) = \vec{f_h} \end{align*}
</p>
<p> Note, that the boundary conditions are taken into account in the operators and the right-hand side.</p>
<hr  />
 <h1><a class="anchor" id="secStationaryLinearDiscretization"></a>
Linear Stationary Problems - the easiest case</h1>
<p>The easiest case are time-independent (stationary) and linear problems. This means </p><ul>
<li>
stationary: \( \mathcal{M}_h(\cdot) = 0 \) </li>
<li>
linear: \( \mathcal{A}_h(\vec{u}_h) \equiv A_h \cdot \vec{u}_h \), i.e. \(A_h \in \mathbb{R}^{N_h \times N_h}\) is a matrix </li>
</ul>
<p>In this case the "Stiffness-Matrix" \(A_h\) and the right-hand side vector \(\vec{f}_h \in \mathbb{R}^{N_h}\) has to be assembled. Then, it remains to use an adequate matrix solver to solve the linear system </p><p class="formulaDsp">
\begin{align*} A_h \vec{u}_h = \vec{f}_h. \end{align*}
</p>
<p>In order to specify a problem, the user has to supply: </p><ul>
<li>
the computation of the matrix \(A_h\) </li>
<li>
the computation of the rhs \(\vec{f}_h\) </li>
</ul>
<p>The solution of the algebraic problem (inverting \(A_h\)) can be implemented independently from the actual problem and/or discretization.</p>
<hr  />
 <h1><a class="anchor" id="secStationaryNonLinearDiscretization"></a>
Non-Linear Stationary Problems</h1>
<p>Stationary, non-linear problems are described by </p><ul>
<li>
stationary: \( \mathcal{M}_h(\cdot) = 0 \) </li>
<li>
non-linear: \( \mathcal{A}_h(\vec{u}_h): \mathbb{R}^{N_h} \mapsto \mathbb{R}^{N_h}\) can not be represented as matrix </li>
</ul>
<p>Thus, in order to solve this problem typically a newton-method is used. This means to reformulate the problem using the "defect": </p><p class="formulaDsp">
\begin{align*} d_h: \mathbb{R}^{N_h} &amp;\mapsto \mathbb{R}^{N_h}\\ \vec{u}_h &amp;\mapsto \vec{d}_h(\vec{u}_h) := \mathcal{A}_h(\vec{u}_h)-\vec{f}_h. \end{align*}
</p>
<p> The aim is to find a root \(\vec{d}_h(u_h) = 0\) of the defect. This is usually solved by the Newton method or some kind of fixed-point iteration. Starting with an initial guess \(u_h^0\) the following interation is performed </p><p class="formulaDsp">
\begin{align*} \vec{c}_{h,k} &amp;:= (J_h(\vec{u}_{h_k}))^{-1} d_h(\vec{u}_{h,k}),\\ \vec{u}_{h,k+1} &amp;:= \vec{u}_{h,k} - \alpha_k \vec{c}_{h,k} \end{align*}
</p>
<p> with </p><ul>
<li>
\(\vec{u}_{h,k}\) is the k'th iterate of the solution </li>
<li>
\(\vec{c}_{h,k}\) is the k'th correction </li>
<li>
\(J_h(\vec{u}_{h_k})\) is a preconditioner matrix for the linearization of the defect w.r.t. the DoFs, evaluated at the solution of the current iterate </li>
<li>
\( \alpha_k\) is a damping factor </li>
</ul>
<p>There are several choises of \(J_h(\vec{u}_{h_k})\): </p><ul>
<li>
<p class="startli">Jacobian </p><p class="formulaDsp">
\begin{align*} J_h(\vec{u}_{h_k}) = \frac{\partial \vec{d}_h(u_h)}{\partial \vec{u}_h} = \frac{\partial \mathcal{A}_h(u_h)}{\partial \vec{u}_h} \end{align*}
</p>
<p> The Jacobian is the linearization of the defect with respect to the unknown DoFs, i.e. </p><p class="formulaDsp">
\begin{align*} (J_h(\vec{u}_{h_k}))_{ij} = \frac{\partial (\vec{d}_h(u_h))_i}{\partial (\vec{u}_h)_j} \end{align*}
</p>
<p class="endli"></p>
</li>
<li>
Identity <p class="formulaDsp">
\begin{align*} J_h(\vec{u}_{h_k}) = \mathbb{I} \end{align*}
</p>
 This gives rise to a very simple fixed-point iteration. </li>
</ul>
<p>Between these two methods, a lot of different approaches by neglecting terms of the exact jacobian. Choosing the Jacobian as a preconditioner will result in a quadratic convergence rate of the iteration. The other schemes give only a linear convergence rate.</p>
<p>One major part of the non-linear iteration is the solution of the linear problem </p><p class="formulaDsp">
\begin{align*} J_h(\vec{u}_{h_k}) \vec{c}_{h,k} = \vec{d}_h(\vec{u}_{h_k}). \end{align*}
</p>
<p> This problem has exactly the same structure as the linear, stationary problem and therefore all linear matrix solvers can also be used here. It is worthwhile to notice the analogy between solution and correction on the one hand and between right-hand side and defect on the other hand. The preconditioner has usually a similar sparse pattern as the matrix of the linear problem. Note, that every linear problem can be viewed as a linear one. In this case, the preconditioner is just the linear matrix itself \(J_h \equiv A_h\) and the newton scheme must and will converge in one single step.</p>
<p>In order to specify a problem, the user has to specify: </p><ul>
<li>
the computation of the preconditioner \(J_h(\vec{u}_h)\) for any \(\vec{u}_h\) </li>
<li>
the computation of the defect \(\vec{d}_h(\vec{u}_h)\) for any \(\vec{u}_h\) </li>
</ul>
<p>All the other steps can be implemented independently from the actual problem and/or discretization.</p>
<hr  />
 <h1><a class="anchor" id="secTimeDiscretization"></a>
Time Discretization</h1>
<hr  />
<p>The discretization of time-dependent part of a PDE is closely related to the solution of ordinary differential equations (ODE). Those have the form </p><p class="formulaDsp">
\begin{align*} \partial_t u(t) &amp;= - f(t, u(t)) \\ u(t_{start}) &amp;= u_0 \end{align*}
</p>
<p> where the unknown function is \(u: \mathbb{R} \mapsto \mathbb{R}^N\) and the right-hand side is \(: \mathbb{R} \times \mathbb{R}^N \mapsto \mathbb{R}^N\).</p>
<p>In order to discretize such an ODE introduce a time grid \(\{t_0 = t_{start}, t_1, t_2, \ldots \}\) and define the time step size \(\Delta t^k := t_{k} - t_{k-1}\). Let \(u^{(k)} \approx u(t_k)\) be the approximation of \(u\) at time step k. A general L-step discretization scheme for ODEs takes the form </p><p class="formulaDsp">
\begin{align*} \sum_{l=0}^{L-1} \left[ s_{m,l} u^{(k-l)} + s_{a,l} f(t^{k-l}, u^{(k-l)}) \right] = 0. \end{align*}
</p>
<p> where </p><ul>
<li>
\(L \geq 2\) is the number of previous time steps needed </li>
<li>
\(s_{m,l}, s_{a,l} \in \mathbb{R}\) are scheme specific scaling factors </li>
<li>
\(u^{(k)}\) is the unknown solution at timestep \(t_k\) </li>
<li>
\(u^{(k-l)} (l \geq 1)\) are the known solutions at previous timesteps </li>
</ul>
<p>Denote by \(\vec{s} := (s_0, s_1, \ldots, s_{L-1})\) the specific scaling factors.</p>
<p>Some common schemes are </p><ul>
<li>
implicit Euler: \( u^{k} - u^{k-1} + \Delta t^k f(t^k, u^k) = 0 \) This gives \(L = 2\) and <p class="formulaDsp">
\begin{align*} \vec{s}_a &amp;= (\Delta t^k, 0)\\ \vec{s}_m &amp;= (1, -1) \end{align*}
</p>
 </li>
<li>
explicit Euler: \( u^{k} - u^{k-1} + \Delta t^k f(t^{k-1}, u^{k-1}) = 0 \) This gives \(L = 2\) and <p class="formulaDsp">
\begin{align*} \vec{s}_a &amp;= (0, \Delta t^k)\\ \vec{s}_m &amp;= (1, -1) \end{align*}
</p>
 </li>
<li>
Crank-Nicolson: \( u^{k} - u^{k-1} + \frac{1}{2} \Delta t^k f(t^{k}, u^{k}) + \frac{1}{2} \Delta t^k f(t^{k-1}, u^{k-1}) = 0\)<br  />
 This gives \(L = 2\) and <p class="formulaDsp">
\begin{align*} \vec{s}_a &amp;= (\frac{1}{2} \Delta t^k, \frac{1}{2} \Delta t^k)\\ \vec{s}_m &amp;= (1, -1) \end{align*}
</p>
 </li>
<li>
\(\theta\)-scheme: \( u^{k} - u^{k-1} + \theta \Delta t^k f(t^{k}, u^{k}) + (1- \theta) \Delta t^k f(t^{k-1}, u^{k-1}) = 0\)<br  />
 This gives \(L = 2\) and <p class="formulaDsp">
\begin{align*} \vec{s}_a &amp;= (\theta \Delta t^k, (1- \theta)\Delta t^k)\\ \vec{s}_m &amp;= (1, -1) \end{align*}
</p>
 with implements the three forementioned schemes by specifing \( \theta\). </li>
<li>
BDF(2): \( u^{k} - \frac{4}{3}u^{k-1} + \frac{1}{3}u^{k-2} + \frac{2}{3} \Delta t^k f(t^{k}, u^{k}) = 0\) This gives \(L = 3\) and <p class="formulaDsp">
\begin{align*} \vec{s}_a &amp;= (\frac{2}{3} \Delta t^k, 0, 0)\\ \vec{s}_m &amp;= (1, -\frac{4}{3}, \frac{1}{3}) \end{align*}
</p>
 </li>
<li>
Runge-Kutta schemes (e.g. DIRK(2)) </li>
<li>
Linear multi-step schemes like Adams-Bashforth or Adams-Moulton </li>
</ul>
<p><br  />
</p>
<p>Now assume \(\mathcal{M}(u)\) to have the form \(\frac{\partial}{\partial t} u\). One can rearrange the problem to </p><p class="formulaDsp">
\begin{align*} \mathcal{M}(u) = \frac{\partial}{\partial t} u = - \mathcal{A}(u, t) + f(t) \end{align*}
</p>
<p> and finds the setup for an ODE problem in time.</p>
<p>Discretize the time-dependent PDE problem first in space. This gives </p><p class="formulaDsp">
\begin{align*} \frac{\partial}{\partial t} M_h \vec{u}_h(t) = - \mathcal{A}_h(\vec{u}_h(t), t) + f_h(t). \end{align*}
</p>
<p> Supposing that the Mass-matrix is independent of time one can apply the ODE time stepping scheme and gets the next time step by solving</p>
<p class="formulaDsp">
\begin{align*} \vec{d}_h(\vec{u}_h^{(k)}) := \sum_{l=0}^{L-1} \left[ s_{m,l} M_h \vec{u}_h^{(k-l)} + s_{a,l} \left( \mathcal{A}_h(\vec{u}^{(k-l)}, t^{(k-l)}) - \vec{f}_h(t^{(k-l)}) \right) \right] = 0. \end{align*}
</p>
<p>The defect \(\vec{d}(u_h^{(k)})\) can be split up into </p><p class="formulaDsp">
\begin{align*} \vec{d}_h(\vec{u}_h^{(k)}) := \sum_{l=0}^{L-1} \hat{\vec{d}}_h(\vec{u}_h^{(k-l)}, t^{(k-l)}, s_{m,l}, s_{a,l}) \end{align*}
</p>
<p> where </p><p class="formulaDsp">
\begin{align*} \hat{\vec{d}}_h(\vec{u}_h, t, s_m, s_a) := s_m M_h \vec{u}_h + s_a \left( \mathcal{A}_h(\vec{u}, t) - \vec{f}_h(t) \right) \end{align*}
</p>
<p>For the Jacobian one finds </p><p class="formulaDsp">
\begin{align*} J_h(\vec{u}_h^{(k)}, t^k, s_{m,0}, s_{a,0}) = \frac{\partial \vec{d}_h(\vec{u}_h)}{\partial \vec{u}_h} \left( \vec{u}_h^{(k)} \right) = \frac{\partial \hat{\vec{d}}_h(\vec{u}_h, t^k, s_{m,0}, s_{a,0})} {\partial \vec{u}_h} \left( \vec{u}_h^{(k)} \right) = s_{m,0} M_h + s_{a,0} \frac{\partial \mathcal{A}_h(\vec{u}_h, t^k)}{\partial \vec{u}_h} \left( \vec{u}_h^{(k)} \right) \end{align*}
</p>
<p>Thus, in order to specify a problem, the user has to specify: </p><ul>
<li>
the computation of the preconditioner \(J_h(\vec{u}_h, t, s_m, s_a)\) for any \(\vec{u}_h, t, s_m, s_a\) </li>
<li>
the computation of the defect \(\hat{\vec{d}}_h(\vec{u}_h, t, s_m, s_a)\) for any \(\vec{u}_h, t, s_m, s_a\) </li>
</ul>
<p><br  />
</p>
<hr  />
 <h1><a class="anchor" id="secTimeDependentLinearDiscretization"></a>
Time-Dependent Linear Problems</h1>
<p>If the time-dependent problem is linear if \(\mathcal{M}(\cdot)\) and \(\mathcal{A}(\cdot)\) are linear. In this case one finds \(\mathcal{A}(\vec{u}_h) \equiv A_h \vec{u}_h\).</p>
<p>The defect equation can now be written in the form </p><p class="formulaDsp">
\begin{align*} s_{m,0} M_h \vec{u}_h^{(k)} + s_{a,0} A_h \vec{u}_h^{(k)} = s_{a,0} \vec{f}_h^{(k)} - \sum_{l=1}^{L-1} \left[ s_{m,l} M_h \vec{u}_h^{(k-l)} + s_{a,l} \left( A_h \vec{u}^{(k-l)} - \vec{f}_h^{(k-l)} \right) \right] \end{align*}
</p>
<p> This system of equations has the form </p><p class="formulaDsp">
\begin{align*} B_h \vec{u}_h^{(k)} = b_h \end{align*}
</p>
<p> where </p><ul>
<li>
\(B_h:=s_{m,0} M_h+ s_{a,0} A_h \) is a matrix </li>
<li>
\(b_h:= s_{a,0} \vec{f}_h^{(k)} - \sum_{l=1}^{L-1} \left[ s_{m,l} M_h \vec{u}_h^{(k-l)} + s_{a,l} \left( A_h \vec{u}^{(k-l)} - \vec{f}_h^{(k-l)} \right) \right]\) is a known vector right-hand side </li>
</ul>
<p>The problem can thus be solved using the same matrix solvers used for the stationary linear problems.</p>
<hr  />
 <h1><a class="anchor" id="secTimeDependentNonLinearDiscretization"></a>
Time-Dependent Non-Linear Problems</h1>
<p>In this case the defect equation </p><p class="formulaDsp">
\begin{align*} \vec{d}_h(\vec{u}_h^{(k)}) := \sum_{l=0}^{L-1} \left[ s_{m,l} M_h \vec{u}_h^{(k-l)} + s_{a,l} \left( \mathcal{A}_h(\vec{u}^{(k-l)}, t^{(k-l)}) - \vec{f}_h^{(k-l)} \right) \right] = 0 \end{align*}
</p>
<p> has to be solved using a newton scheme. Fixing the time step \(k\) this problem has the same structure as the stationary non-linear problems. Thus, the solver framework can be reused.</p>
<hr  />
 <h1><a class="anchor" id="secCategorizationAcknowledgment"></a>
Acknowledgment</h1>
<p>This splitting concept is strongly influenced by a short but very illuminative paper by Dmitriy Logashenko. Special thanks to him for sharing his insight. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">ug4 - Documentation</a></li><li class="navelem"><a class="el" href="page_u_g4_development.html">Development</a></li><li class="navelem"><a class="el" href="page_l_d_introduction.html">libDiscretization</a></li><li class="navelem"><a class="el" href="page_l_d_assembling_concept.html">Assembling Concept</a></li>
    <li class="footer">Generated on Mon Dec 4 2023 00:57:31 for ug4 by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
