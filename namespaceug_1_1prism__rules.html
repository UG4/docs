<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ug4: ug::prism_rules Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ug4
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespaceug_1_1prism__rules.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">ug::prism_rules Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4e402d1504601e8d1f92a9396fae4200"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceug_1_1prism__rules.html#a4e402d1504601e8d1f92a9396fae4200">CollapseEdge</a> (int *newIndsOut, int v0, int v1)</td></tr>
<tr class="memdesc:a4e402d1504601e8d1f92a9396fae4200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates new volume elements that result from collapsing the edge between v0 and v1 into v0.  <a href="namespaceug_1_1prism__rules.html#a4e402d1504601e8d1f92a9396fae4200">More...</a><br /></td></tr>
<tr class="separator:a4e402d1504601e8d1f92a9396fae4200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94eef012e6e9005719dca5e7567f0308"><td class="memTemplParams" colspan="2">template&lt;class TCmp &gt; </td></tr>
<tr class="memitem:a94eef012e6e9005719dca5e7567f0308"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceug_1_1prism__rules.html#a94eef012e6e9005719dca5e7567f0308">ConvertToTetrahedra</a> (int *newIndsOut, TCmp cmp)</td></tr>
<tr class="memdesc:a94eef012e6e9005719dca5e7567f0308"><td class="mdescLeft">&#160;</td><td class="mdescRight">fills an array of integers describing tetrahedra that shall replace the prism  <a href="namespaceug_1_1prism__rules.html#a94eef012e6e9005719dca5e7567f0308">More...</a><br /></td></tr>
<tr class="separator:a94eef012e6e9005719dca5e7567f0308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b14a4bd836de14eab611d5102fd22ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceug_1_1prism__rules.html#a9b14a4bd836de14eab611d5102fd22ba">FlipPrism</a> (int vrtsOut[<a class="el" href="namespaceug_1_1prism__rules.html#a013c9dfc63bb6a464e93c43d3a04e555">NUM_VERTICES</a>], const int vrts[<a class="el" href="namespaceug_1_1prism__rules.html#a013c9dfc63bb6a464e93c43d3a04e555">NUM_VERTICES</a>])</td></tr>
<tr class="separator:a9b14a4bd836de14eab611d5102fd22ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af172bb9eafa2d2de5fb084dd031c3acd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceug_1_1prism__rules.html#af172bb9eafa2d2de5fb084dd031c3acd">IsRegularRefRule</a> (const int edgeMarks)</td></tr>
<tr class="memdesc:af172bb9eafa2d2de5fb084dd031c3acd"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if the specified edgeMarks would lead to a regular refinement  <a href="namespaceug_1_1prism__rules.html#af172bb9eafa2d2de5fb084dd031c3acd">More...</a><br /></td></tr>
<tr class="separator:af172bb9eafa2d2de5fb084dd031c3acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57bc08be636f9025945a4e16bdc42ac9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceug_1_1prism__rules.html#a57bc08be636f9025945a4e16bdc42ac9">Refine</a> (int *newIndsOut, int *newEdgeVrts, bool &amp;newCenterOut, <a class="el" href="group__vectors.html#ga894cdb8af74f7a563a94fb49c220fdcd">vector3</a> *, bool *isSnapPoint)</td></tr>
<tr class="separator:a57bc08be636f9025945a4e16bdc42ac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69acce1fc6e705932edca4157f89477c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceug_1_1prism__rules.html#a69acce1fc6e705932edca4157f89477c">RotatePrism</a> (int vrtsOut[<a class="el" href="namespaceug_1_1prism__rules.html#a013c9dfc63bb6a464e93c43d3a04e555">NUM_VERTICES</a>], int steps)</td></tr>
<tr class="memdesc:a69acce1fc6e705932edca4157f89477c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output are the vertices of a prism rotated around its vertical axis.  <a href="namespaceug_1_1prism__rules.html#a69acce1fc6e705932edca4157f89477c">More...</a><br /></td></tr>
<tr class="separator:a69acce1fc6e705932edca4157f89477c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a01a219154616b8cf03be0fe114798de4"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceug_1_1prism__rules.html#a01a219154616b8cf03be0fe114798de4">BOTTOM_FACE</a> = 0</td></tr>
<tr class="separator:a01a219154616b8cf03be0fe114798de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4923532a30bda74b71b10d6e29d4ee3"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceug_1_1prism__rules.html#ac4923532a30bda74b71b10d6e29d4ee3">EDGE_FROM_VRTS</a> [6][6]</td></tr>
<tr class="memdesc:ac4923532a30bda74b71b10d6e29d4ee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associates the index of the connecting edge with each tuple of vertices.  <a href="namespaceug_1_1prism__rules.html#ac4923532a30bda74b71b10d6e29d4ee3">More...</a><br /></td></tr>
<tr class="separator:ac4923532a30bda74b71b10d6e29d4ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69ff49967aaefeb3f20d2c5f5dd0088b"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceug_1_1prism__rules.html#a69ff49967aaefeb3f20d2c5f5dd0088b">EDGE_VRT_INDS</a> [][2]</td></tr>
<tr class="memdesc:a69ff49967aaefeb3f20d2c5f5dd0088b"><td class="mdescLeft">&#160;</td><td class="mdescRight">the local vertex indices of the given edge  <a href="namespaceug_1_1prism__rules.html#a69ff49967aaefeb3f20d2c5f5dd0088b">More...</a><br /></td></tr>
<tr class="separator:a69ff49967aaefeb3f20d2c5f5dd0088b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f2f92138f5883bfc17c060e3a6dc943"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceug_1_1prism__rules.html#a0f2f92138f5883bfc17c060e3a6dc943">FACE_CONTAINS_EDGE</a> [][9]</td></tr>
<tr class="memdesc:a0f2f92138f5883bfc17c060e3a6dc943"><td class="mdescLeft">&#160;</td><td class="mdescRight">tells whether the i-th face contains the j-th edge  <a href="namespaceug_1_1prism__rules.html#a0f2f92138f5883bfc17c060e3a6dc943">More...</a><br /></td></tr>
<tr class="separator:a0f2f92138f5883bfc17c060e3a6dc943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7ecebc55acba7f3120142f345270440"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceug_1_1prism__rules.html#ab7ecebc55acba7f3120142f345270440">FACE_EDGE_INDS</a> [5][4]</td></tr>
<tr class="memdesc:ab7ecebc55acba7f3120142f345270440"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the j-th edge of the i-th face  <a href="namespaceug_1_1prism__rules.html#ab7ecebc55acba7f3120142f345270440">More...</a><br /></td></tr>
<tr class="separator:ab7ecebc55acba7f3120142f345270440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a831f0cf2cf8befcf63b307ca6de9d87b"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceug_1_1prism__rules.html#a831f0cf2cf8befcf63b307ca6de9d87b">FACE_FROM_EDGES</a> [][9]</td></tr>
<tr class="memdesc:a831f0cf2cf8befcf63b307ca6de9d87b"><td class="mdescLeft">&#160;</td><td class="mdescRight">given two edges, the table returns the face, which contains both (or -1)  <a href="namespaceug_1_1prism__rules.html#a831f0cf2cf8befcf63b307ca6de9d87b">More...</a><br /></td></tr>
<tr class="separator:a831f0cf2cf8befcf63b307ca6de9d87b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac23ba8b79981faff252d11472d4a048a"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceug_1_1prism__rules.html#ac23ba8b79981faff252d11472d4a048a">FACE_FROM_VRTS</a> [6][6][6]</td></tr>
<tr class="memdesc:ac23ba8b79981faff252d11472d4a048a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associates the index of the connecting face with each triple of vertices.  <a href="namespaceug_1_1prism__rules.html#ac23ba8b79981faff252d11472d4a048a">More...</a><br /></td></tr>
<tr class="separator:ac23ba8b79981faff252d11472d4a048a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adad5aca95ddba21cf94b9ec607f07b04"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceug_1_1prism__rules.html#adad5aca95ddba21cf94b9ec607f07b04">FACE_VRT_INDS</a> [][4]</td></tr>
<tr class="memdesc:adad5aca95ddba21cf94b9ec607f07b04"><td class="mdescLeft">&#160;</td><td class="mdescRight">the local vertex indices of the given face  <a href="namespaceug_1_1prism__rules.html#adad5aca95ddba21cf94b9ec607f07b04">More...</a><br /></td></tr>
<tr class="separator:adad5aca95ddba21cf94b9ec607f07b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b1b7f8a059b496c39b30b70403cd315"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceug_1_1prism__rules.html#a9b1b7f8a059b496c39b30b70403cd315">IS_BOTTOM_EDGE</a> [9] = {1, 1, 1, 0, 0, 0, 0, 0, 0}</td></tr>
<tr class="separator:a9b1b7f8a059b496c39b30b70403cd315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e7edc827ebe9c7000c5ebe2bd25ea9e"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceug_1_1prism__rules.html#a6e7edc827ebe9c7000c5ebe2bd25ea9e">IS_SIDE_EDGE</a> [9] = {0, 0, 0, 1, 1, 1, 0, 0, 0}</td></tr>
<tr class="separator:a6e7edc827ebe9c7000c5ebe2bd25ea9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf70fa3b34db73b0604373d28e9db852"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceug_1_1prism__rules.html#abf70fa3b34db73b0604373d28e9db852">IS_TOP_EDGE</a> [9] = {0, 0, 0, 0, 0, 0, 1, 1, 1}</td></tr>
<tr class="separator:abf70fa3b34db73b0604373d28e9db852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5621374db8a8c44ee8d209447c1d812a"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceug_1_1prism__rules.html#a5621374db8a8c44ee8d209447c1d812a">MAX_NUM_COLLAPSE_INDS_OUT</a> = 6</td></tr>
<tr class="separator:a5621374db8a8c44ee8d209447c1d812a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d0b0e6b362171ba34730f69fc2f6bb"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceug_1_1prism__rules.html#ad4d0b0e6b362171ba34730f69fc2f6bb">MAX_NUM_CONVERT_TO_TETS_INDS_OUT</a> = 15</td></tr>
<tr class="separator:ad4d0b0e6b362171ba34730f69fc2f6bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2a8f14ac3393e97f8ccce280de9deac"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceug_1_1prism__rules.html#ab2a8f14ac3393e97f8ccce280de9deac">MAX_NUM_INDS_OUT</a> = 128</td></tr>
<tr class="separator:ab2a8f14ac3393e97f8ccce280de9deac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a260ead43f4ed5ebc16c06af1aaad3d60"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceug_1_1prism__rules.html#a260ead43f4ed5ebc16c06af1aaad3d60">NUM_EDGES</a> = 9</td></tr>
<tr class="separator:a260ead43f4ed5ebc16c06af1aaad3d60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bcea38ea00d9b26cb36ed1b1dd72adb"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceug_1_1prism__rules.html#a7bcea38ea00d9b26cb36ed1b1dd72adb">NUM_FACES</a> = 5</td></tr>
<tr class="separator:a7bcea38ea00d9b26cb36ed1b1dd72adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09d8297c5255df8768658bb01586f472"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceug_1_1prism__rules.html#a09d8297c5255df8768658bb01586f472">NUM_QUADS</a> = 3</td></tr>
<tr class="separator:a09d8297c5255df8768658bb01586f472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44febba99968c2c1dccb35df8f6c7499"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceug_1_1prism__rules.html#a44febba99968c2c1dccb35df8f6c7499">NUM_TRIS</a> = 2</td></tr>
<tr class="separator:a44febba99968c2c1dccb35df8f6c7499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a013c9dfc63bb6a464e93c43d3a04e555"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceug_1_1prism__rules.html#a013c9dfc63bb6a464e93c43d3a04e555">NUM_VERTICES</a> = 6</td></tr>
<tr class="separator:a013c9dfc63bb6a464e93c43d3a04e555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd3160bd4e5b5f955c4d21c429b48076"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceug_1_1prism__rules.html#acd3160bd4e5b5f955c4d21c429b48076">OPPOSED_FACE</a> [<a class="el" href="namespaceug_1_1prism__rules.html#a7bcea38ea00d9b26cb36ed1b1dd72adb">NUM_FACES</a>] = {4, -1, -1, -1, 0}</td></tr>
<tr class="memdesc:acd3160bd4e5b5f955c4d21c429b48076"><td class="mdescLeft">&#160;</td><td class="mdescRight">the index of the face opposed to the given one. -1 if no face is opposed  <a href="namespaceug_1_1prism__rules.html#acd3160bd4e5b5f955c4d21c429b48076">More...</a><br /></td></tr>
<tr class="separator:acd3160bd4e5b5f955c4d21c429b48076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa368c2d9028fd5fda53f2da06669076a"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceug_1_1prism__rules.html#aa368c2d9028fd5fda53f2da06669076a">OPPOSED_OBJECT</a> [][<a class="el" href="namespaceug_1_1prism__rules.html#a013c9dfc63bb6a464e93c43d3a04e555">NUM_VERTICES</a>] = {{1, 7}, {1, 8}, {1, 6}, {1, 1}, {1, 2}, {1, 0}}</td></tr>
<tr class="separator:aa368c2d9028fd5fda53f2da06669076a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7654423497f37cf8308d4d5aadc85c62"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceug_1_1prism__rules.html#a7654423497f37cf8308d4d5aadc85c62">QUADS</a> [3] = {1, 2, 3}</td></tr>
<tr class="separator:a7654423497f37cf8308d4d5aadc85c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaee17e9f35d3a685a9a3bf0106498fe"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceug_1_1prism__rules.html#aeaee17e9f35d3a685a9a3bf0106498fe">TOP_FACE</a> = 4</td></tr>
<tr class="separator:aeaee17e9f35d3a685a9a3bf0106498fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a2540ed8a485dda4faa039b7041e972"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceug_1_1prism__rules.html#a6a2540ed8a485dda4faa039b7041e972">TRIS</a> [2] = {0, 4}</td></tr>
<tr class="separator:a6a2540ed8a485dda4faa039b7041e972"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a4e402d1504601e8d1f92a9396fae4200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e402d1504601e8d1f92a9396fae4200">&#9670;&nbsp;</a></span>CollapseEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ug::prism_rules::CollapseEdge </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>newIndsOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates new volume elements that result from collapsing the edge between v0 and v1 into v0. </p>
<p>Note that the returned array may be empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newIndsOut</td><td>Array which has to be of size MAX_NUM_COLLAPSE_INDS_OUT. When the algorithm is done, the array will contain sequences of integers: {{gridObjectID, ind1, ind2, ...}, ...}. gridObjectID is a constant enumerated in GridObjectID and describes the type of the grid-object that is built from the following set of corner indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size of the resulting element list 'newIndsOut'. </dd></dl>

<p class="reference">References <a class="el" href="namespaceug_1_1prism__rules.html#ac4923532a30bda74b71b10d6e29d4ee3">EDGE_FROM_VRTS</a>, <a class="el" href="namespaceug_1_1prism__rules.html#a831f0cf2cf8befcf63b307ca6de9d87b">FACE_FROM_EDGES</a>, <a class="el" href="namespaceug_1_1prism__rules.html#adad5aca95ddba21cf94b9ec607f07b04">FACE_VRT_INDS</a>, and <a class="el" href="namespaceug.html#a02785d5fd4cf2dd569d72cfac0197574a9c63711bcda15a049668e36a24b820fd">ug::GOID_PYRAMID</a>.</p>

</div>
</div>
<a id="a94eef012e6e9005719dca5e7567f0308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94eef012e6e9005719dca5e7567f0308">&#9670;&nbsp;</a></span>ConvertToTetrahedra()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TCmp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int ug::prism_rules::ConvertToTetrahedra </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>newIndsOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TCmp&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>fills an array of integers describing tetrahedra that shall replace the prism </p>
<p>The method requires a compare-operator that defines a strict (global) ordering on the vertices of the prism. Note that this operator should return consistent results for all vertices in a given grid. The ordering is used to decide along which diagonal each quadrilateral is split. Each new diagonal will start at the smallest vertex of the corresponding quadrilateral, regarding the given ordering.</p>
<p>The specified compare function (or compare operator) 'bool cmp (int i0, int i1)' will be called with two local corner indices and has to return true, if vertex at the first corner shall be considered smaller (globally) than the vertex at the second corner.</p>
<p>The idea and implementation follows: Dompierre et al., "How to Subdivide Pyramids, Prisms and Hexahedra into Tetrahedra"</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newIndsOut</td><td>Array which has to be of size MAX_NUM_CONVERT_TO_TETS_INDS_OUT. When the algorithm is done, the array will contain sequences of integers: {{gridObjectID, ind1, ind2, ...}, ...}. gridObjectID is a constant enumerated in GridObjectID and describes the type of the grid-object that is built from the following set of corner indices.</td></tr>
    <tr><td class="paramname">cmp</td><td>A function object that induces a strict ordering on the corners of the prism. The method shall return true if the vertex at the first corner-index shall be considered smaller than the vertex at the second corner index. If multiple prisms shall be converted to tetrahedra, it is important that the given ordering is global, i.e., if a pair of vertices is present in two connected prisms, the 'cmp' operator has to return the same value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of entries written to newIndsOut or 0, if the refinement could not be performed. </dd></dl>

<p class="reference">References <a class="el" href="namespaceug.html#a02785d5fd4cf2dd569d72cfac0197574a6bd5ada865770fc6a5ab730446242999">ug::GOID_TETRAHEDRON</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__lib__grid__algorithms__volume__util.html#ga091a48c6244029acd671f4e23309799a">ug::ConvertToTetrahedra()</a>.</p>

</div>
</div>
<a id="a9b14a4bd836de14eab611d5102fd22ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b14a4bd836de14eab611d5102fd22ba">&#9670;&nbsp;</a></span>FlipPrism()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ug::prism_rules::FlipPrism </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vrtsOut</em>[NUM_VERTICES], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>vrts</em>[NUM_VERTICES]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="namespaceug_1_1prism__rules.html#a57bc08be636f9025945a4e16bdc42ac9">Refine()</a>.</p>

</div>
</div>
<a id="af172bb9eafa2d2de5fb084dd031c3acd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af172bb9eafa2d2de5fb084dd031c3acd">&#9670;&nbsp;</a></span>IsRegularRefRule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ug::prism_rules::IsRegularRefRule </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>edgeMarks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns true if the specified edgeMarks would lead to a regular refinement </p>
<p>A regular refinement leads to new elements which are all similar to the original element. I.e. which are of the same type and which have similar angles.</p>
<dl class="section note"><dt>Note</dt><dd>this method does not perform refinement. Use 'Refine' with the specified edges instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edgeMarks</td><td>If the i-th edge shall be refined, the expression 'edgeMarks &amp; (1&lt;&lt;i) != 0' has to be true. You can specify multiple refine-edges using or-combinations. E.g., 'edgeMarks = (1&lt;&lt;i) | (1&lt;&lt;j)' would indicate that the i-th and the j-th edge shall be refined. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a57bc08be636f9025945a4e16bdc42ac9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57bc08be636f9025945a4e16bdc42ac9">&#9670;&nbsp;</a></span>Refine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ug::prism_rules::Refine </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>newIndsOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>newEdgeVrts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>newCenterOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__vectors.html#ga894cdb8af74f7a563a94fb49c220fdcd">vector3</a> *&#160;</td>
          <td class="paramname"><em>corners</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>isSnapPoint</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>returns an array of integers, which contains the indices of the objects resulting from the refinement of a pyramid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newIndsOut</td><td>Array which has to be of size MAX_NUM_INDS_OUT. When the algorithm is done, the array will contain sequences of integers: {{gridObjectID, ind1, ind2, ...}, ...}. gridObjectID is a constant enumerated in GridObjectID and describes the type of the grid-object that is built from the following set of corner indices. Old vertices are referenced by their local index. Vertices created on an edge are indexed by the index of the edge + NUM_VERTICES. Vertices created on a face are referenced by NUM_VERTICES + NUM_EDGES + index_of_face. If an inner vertex has to be created, it is referenced by NUM_VERTICES + NUM_EDGES + NUM_FACES (in this case newCenterOut is set to true).</td></tr>
    <tr><td class="paramname">newEdgeVrts</td><td>Array of size NUM_EDGES, which has to contain 1 for each edge, which shall be refined and 0 for each edge, which won't be refined.</td></tr>
    <tr><td class="paramname">newCenterOut</td><td>If the refinement-rule requires a center vertex, then this parameter will be set to true. If not, it is set to false.</td></tr>
    <tr><td class="paramname">corners</td><td>Ignored.</td></tr>
    <tr><td class="paramname">isSnapPoint</td><td>(optional) An array of size NUM_VERTICES. If all entries are set to 'false' the behaviour is the same as if the array wasn't specified. If a corner of a quadrilateral is a snap-point and if edges of that quadrilateral are refined, then only new edges connected to the snap-point are introduced. Note that only special snap-point constellations are supported.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of entries written to newIndsOut or 0, if the refinement could not be performed. </dd></dl>

<p class="reference">References <a class="el" href="namespaceug_1_1prism__rules.html#a01a219154616b8cf03be0fe114798de4">BOTTOM_FACE</a>, <a class="el" href="namespaceug_1_1prism__rules.html#ac4923532a30bda74b71b10d6e29d4ee3">EDGE_FROM_VRTS</a>, <a class="el" href="namespaceug_1_1prism__rules.html#a69ff49967aaefeb3f20d2c5f5dd0088b">EDGE_VRT_INDS</a>, <a class="el" href="namespaceug_1_1prism__rules.html#a0f2f92138f5883bfc17c060e3a6dc943">FACE_CONTAINS_EDGE</a>, <a class="el" href="namespaceug_1_1prism__rules.html#ab7ecebc55acba7f3120142f345270440">FACE_EDGE_INDS</a>, <a class="el" href="namespaceug_1_1prism__rules.html#a831f0cf2cf8befcf63b307ca6de9d87b">FACE_FROM_EDGES</a>, <a class="el" href="namespaceug_1_1prism__rules.html#adad5aca95ddba21cf94b9ec607f07b04">FACE_VRT_INDS</a>, <a class="el" href="namespaceug_1_1prism__rules.html#a9b14a4bd836de14eab611d5102fd22ba">FlipPrism()</a>, <a class="el" href="namespaceug.html#a02785d5fd4cf2dd569d72cfac0197574a7bfd67d9fba50002bd7991ce4d55b531">ug::GOID_HEXAHEDRON</a>, <a class="el" href="namespaceug.html#a02785d5fd4cf2dd569d72cfac0197574a295753ffcd68033bb34442d7855b46e3">ug::GOID_PRISM</a>, <a class="el" href="namespaceug.html#a02785d5fd4cf2dd569d72cfac0197574a9c63711bcda15a049668e36a24b820fd">ug::GOID_PYRAMID</a>, <a class="el" href="namespaceug.html#a02785d5fd4cf2dd569d72cfac0197574a6bd5ada865770fc6a5ab730446242999">ug::GOID_TETRAHEDRON</a>, <a class="el" href="namespaceug_1_1prism__rules.html#a9b1b7f8a059b496c39b30b70403cd315">IS_BOTTOM_EDGE</a>, <a class="el" href="namespaceug_1_1prism__rules.html#a6e7edc827ebe9c7000c5ebe2bd25ea9e">IS_SIDE_EDGE</a>, <a class="el" href="namespaceug_1_1prism__rules.html#abf70fa3b34db73b0604373d28e9db852">IS_TOP_EDGE</a>, <a class="el" href="namespaceug_1_1prism__rules.html#a260ead43f4ed5ebc16c06af1aaad3d60">NUM_EDGES</a>, <a class="el" href="namespaceug_1_1prism__rules.html#a7bcea38ea00d9b26cb36ed1b1dd72adb">NUM_FACES</a>, <a class="el" href="namespaceug_1_1prism__rules.html#a09d8297c5255df8768658bb01586f472">NUM_QUADS</a>, <a class="el" href="namespaceug_1_1prism__rules.html#a013c9dfc63bb6a464e93c43d3a04e555">NUM_VERTICES</a>, <a class="elRef" href="../plugins/_biogas_8lua.html#a57f1028d958bb73c4e3c64e2077342fc">p</a>, <a class="el" href="namespaceug_1_1prism__rules.html#a7654423497f37cf8308d4d5aadc85c62">QUADS</a>, <a class="el" href="namespaceug_1_1shared__rules.html#a7ac2b679a4bd43aa6e8509c82ace36ca">ug::shared_rules::RecursiveRefine()</a>, <a class="el" href="namespaceug_1_1prism__rules.html#a69acce1fc6e705932edca4157f89477c">RotatePrism()</a>, <a class="el" href="group__ugbase__common.html#ga0b928ef153b78f1b5e025638cf28f841">UG_ASSERT</a>, and <a class="el" href="group__ugbase__common.html#ga849480b16e1d7c49266a92cd5db63942">UG_LOG</a>.</p>

</div>
</div>
<a id="a69acce1fc6e705932edca4157f89477c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69acce1fc6e705932edca4157f89477c">&#9670;&nbsp;</a></span>RotatePrism()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ug::prism_rules::RotatePrism </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vrtsOut</em>[NUM_VERTICES], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>steps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output are the vertices of a prism rotated around its vertical axis. </p>

<p class="reference">Referenced by <a class="el" href="namespaceug_1_1prism__rules.html#a57bc08be636f9025945a4e16bdc42ac9">Refine()</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a01a219154616b8cf03be0fe114798de4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01a219154616b8cf03be0fe114798de4">&#9670;&nbsp;</a></span>BOTTOM_FACE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int ug::prism_rules::BOTTOM_FACE = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="namespaceug_1_1prism__rules.html#a57bc08be636f9025945a4e16bdc42ac9">Refine()</a>.</p>

</div>
</div>
<a id="ac4923532a30bda74b71b10d6e29d4ee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4923532a30bda74b71b10d6e29d4ee3">&#9670;&nbsp;</a></span>EDGE_FROM_VRTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int ug::prism_rules::EDGE_FROM_VRTS[6][6]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">        {{-1, 0, 2, 3, -1, -1}, {0, -1, 1, -1, 4, -1},</div>
<div class="line">         {2, 1, -1, -1, -1, 5}, {3, -1, -1, -1, 6, 8},</div>
<div class="line">         {-1, 4, -1, 6, -1, 7}, {-1, -1, 5, 8, 7, -1}}</div>
</div><!-- fragment -->
<p>Associates the index of the connecting edge with each tuple of vertices. </p>
<p>Use two vertex indices to index into this table to retrieve the index of their connecting edge. </p>

<p class="reference">Referenced by <a class="el" href="namespaceug_1_1prism__rules.html#a4e402d1504601e8d1f92a9396fae4200">CollapseEdge()</a>, and <a class="el" href="namespaceug_1_1prism__rules.html#a57bc08be636f9025945a4e16bdc42ac9">Refine()</a>.</p>

</div>
</div>
<a id="a69ff49967aaefeb3f20d2c5f5dd0088b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69ff49967aaefeb3f20d2c5f5dd0088b">&#9670;&nbsp;</a></span>EDGE_VRT_INDS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int ug::prism_rules::EDGE_VRT_INDS[][2]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= { {0, 1}, {1, 2}, {2, 0},</div>
<div class="line">                  {0, 3}, {1, 4}, {2, 5},</div>
<div class="line">                  {3, 4}, {4, 5}, {5, 3}}</div>
</div><!-- fragment -->
<p>the local vertex indices of the given edge </p>

<p class="reference">Referenced by <a class="el" href="namespaceug_1_1prism__rules.html#a57bc08be636f9025945a4e16bdc42ac9">Refine()</a>.</p>

</div>
</div>
<a id="a0f2f92138f5883bfc17c060e3a6dc943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f2f92138f5883bfc17c060e3a6dc943">&#9670;&nbsp;</a></span>FACE_CONTAINS_EDGE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int ug::prism_rules::FACE_CONTAINS_EDGE[][9]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">        {{1, 1, 1, 0, 0, 0, 0, 0, 0}, {1, 0, 0, 1, 1, 0, 1, 0, 0},</div>
<div class="line">         {0, 1, 0, 0, 1, 1, 0, 1, 0}, {0, 0, 1, 1, 0, 1, 0, 0, 1},</div>
<div class="line">         {0, 0, 0, 0, 0, 0, 1, 1, 1}}</div>
</div><!-- fragment -->
<p>tells whether the i-th face contains the j-th edge </p>

<p class="reference">Referenced by <a class="el" href="namespaceug_1_1prism__rules.html#a57bc08be636f9025945a4e16bdc42ac9">Refine()</a>.</p>

</div>
</div>
<a id="ab7ecebc55acba7f3120142f345270440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7ecebc55acba7f3120142f345270440">&#9670;&nbsp;</a></span>FACE_EDGE_INDS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int ug::prism_rules::FACE_EDGE_INDS[5][4]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {{0, 1, 2, -1}, {3, 6, 4, 0}, {4, 7, 5, 1},</div>
<div class="line">                   {5, 8, 3, 2}, {8, 7, 6, -1}}</div>
</div><!-- fragment -->
<p>returns the j-th edge of the i-th face </p>

<p class="reference">Referenced by <a class="el" href="namespaceug_1_1prism__rules.html#a57bc08be636f9025945a4e16bdc42ac9">Refine()</a>.</p>

</div>
</div>
<a id="a831f0cf2cf8befcf63b307ca6de9d87b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a831f0cf2cf8befcf63b307ca6de9d87b">&#9670;&nbsp;</a></span>FACE_FROM_EDGES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int ug::prism_rules::FACE_FROM_EDGES[][9]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">        {{0, 0, 0, 1, 1, -1, 1, -1, -1}, {0, 0, 0, -1, 2, 2, -1, 2, -1},</div>
<div class="line">         {0, 0, 0, 3, -1, 3, -1, -1, 3}, {1, -1, 3, 1, 1, 3, 1, -1, 3},</div>
<div class="line">         {1, 2, -1, 1, 1, 2, 1, 2, -1}, {-1, 2, 3, 3, 2, 2, -1, 2, 3},</div>
<div class="line">         {1, -1, -1, 1, 1, -1, 1, 4, 4}, {-1, 2, -1, -1, 2, 2, 4, 2, 4},</div>
<div class="line">         {-1, -1, 3, 3, -1, 3, 4, 4, 3}}</div>
</div><!-- fragment -->
<p>given two edges, the table returns the face, which contains both (or -1) </p>

<p class="reference">Referenced by <a class="el" href="namespaceug_1_1prism__rules.html#a4e402d1504601e8d1f92a9396fae4200">CollapseEdge()</a>, and <a class="el" href="namespaceug_1_1prism__rules.html#a57bc08be636f9025945a4e16bdc42ac9">Refine()</a>.</p>

</div>
</div>
<a id="ac23ba8b79981faff252d11472d4a048a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac23ba8b79981faff252d11472d4a048a">&#9670;&nbsp;</a></span>FACE_FROM_VRTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int ug::prism_rules::FACE_FROM_VRTS[6][6][6]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">              {{{-1, -1, -1, -1, -1, -1}, {-1, -1, 0, 1, 1, -1},</div>
<div class="line">                {-1, 0, -1, 3, -1, 3}, {-1, 1, 3, -1, 1, 3},</div>
<div class="line">                {-1, 1, -1, 1, -1, -1}, {-1, -1, 3, 3, -1, -1}},</div>
<div class="line">               {{-1, -1, 0, 1, 1, -1}, {-1, -1, -1, -1, -1, -1},</div>
<div class="line">                {0, -1, -1, -1, 2, 2}, {1, -1, -1, -1, 1, -1},</div>
<div class="line">                {1, -1, 2, 1, -1, 2}, {-1, -1, 2, -1, 2, -1}},</div>
<div class="line">               {{-1, 0, -1, 3, -1, 3}, {0, -1, -1, -1, 2, 2},</div>
<div class="line">                {-1, -1, -1, -1, -1, -1}, {3, -1, -1, -1, -1, 3},</div>
<div class="line">                {-1, 2, -1, -1, -1, 2}, {3, 2, -1, 3, 2, -1}},</div>
<div class="line">               {{-1, 1, 3, -1, 1, 3}, {1, -1, -1, -1, 1, -1},</div>
<div class="line">                {3, -1, -1, -1, -1, 3}, {-1, -1, -1, -1, -1, -1},</div>
<div class="line">                {1, 1, -1, -1, -1, 4}, {3, -1, 3, -1, 4, -1}},</div>
<div class="line">               {{-1, 1, -1, 1, -1, -1}, {1, -1, 2, 1, -1, 2},</div>
<div class="line">                {-1, 2, -1, -1, -1, 2}, {1, 1, -1, -1, -1, 4},</div>
<div class="line">                {-1, -1, -1, -1, -1, -1}, {-1, 2, 2, 4, -1, -1}},</div>
<div class="line">               {{-1, -1, 3, 3, -1, -1}, {-1, -1, 2, -1, 2, -1},</div>
<div class="line">                {3, 2, -1, 3, 2, -1}, {3, -1, 3, -1, 4, -1},</div>
<div class="line">                {-1, 2, 2, 4, -1, -1}, {-1, -1, -1, -1, -1, -1}}}</div>
</div><!-- fragment -->
<p>Associates the index of the connecting face with each triple of vertices. </p>
<p>Use three vertex indices to index into this table to retrieve the index of their connecting face. </p>

</div>
</div>
<a id="adad5aca95ddba21cf94b9ec607f07b04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adad5aca95ddba21cf94b9ec607f07b04">&#9670;&nbsp;</a></span>FACE_VRT_INDS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int ug::prism_rules::FACE_VRT_INDS[][4]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= { {0, 1, 2, -1},  {0, 3, 4, 1},</div>
<div class="line"> </div>
<div class="line">                  {1, 4, 5, 2}, {2, 5, 3, 0},</div>
<div class="line">                  {3, 5, 4, -1}}</div>
</div><!-- fragment -->
<p>the local vertex indices of the given face </p>

<p class="reference">Referenced by <a class="el" href="namespaceug_1_1prism__rules.html#a4e402d1504601e8d1f92a9396fae4200">CollapseEdge()</a>, <a class="el" href="namespaceug.html#aaa6dc6e820042160919759e9d5f80c18">ug::CreateHexahedronFromPrisms()</a>, and <a class="el" href="namespaceug_1_1prism__rules.html#a57bc08be636f9025945a4e16bdc42ac9">Refine()</a>.</p>

</div>
</div>
<a id="a9b1b7f8a059b496c39b30b70403cd315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b1b7f8a059b496c39b30b70403cd315">&#9670;&nbsp;</a></span>IS_BOTTOM_EDGE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int ug::prism_rules::IS_BOTTOM_EDGE[9] = {1, 1, 1, 0, 0, 0, 0, 0, 0}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="namespaceug_1_1prism__rules.html#a57bc08be636f9025945a4e16bdc42ac9">Refine()</a>.</p>

</div>
</div>
<a id="a6e7edc827ebe9c7000c5ebe2bd25ea9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e7edc827ebe9c7000c5ebe2bd25ea9e">&#9670;&nbsp;</a></span>IS_SIDE_EDGE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int ug::prism_rules::IS_SIDE_EDGE[9] = {0, 0, 0, 1, 1, 1, 0, 0, 0}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="namespaceug_1_1prism__rules.html#a57bc08be636f9025945a4e16bdc42ac9">Refine()</a>.</p>

</div>
</div>
<a id="abf70fa3b34db73b0604373d28e9db852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf70fa3b34db73b0604373d28e9db852">&#9670;&nbsp;</a></span>IS_TOP_EDGE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int ug::prism_rules::IS_TOP_EDGE[9] = {0, 0, 0, 0, 0, 0, 1, 1, 1}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="namespaceug_1_1prism__rules.html#a57bc08be636f9025945a4e16bdc42ac9">Refine()</a>.</p>

</div>
</div>
<a id="a5621374db8a8c44ee8d209447c1d812a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5621374db8a8c44ee8d209447c1d812a">&#9670;&nbsp;</a></span>MAX_NUM_COLLAPSE_INDS_OUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int ug::prism_rules::MAX_NUM_COLLAPSE_INDS_OUT = 6</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="classug_1_1_prism.html#a3e624f76f2ec8cf994ba2b55420b560a">ug::Prism::collapse_edge()</a>, and <a class="el" href="classug_1_1_pyramid.html#a6e526887a84e907cc743b26f97091406">ug::Pyramid::collapse_edge()</a>.</p>

</div>
</div>
<a id="ad4d0b0e6b362171ba34730f69fc2f6bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4d0b0e6b362171ba34730f69fc2f6bb">&#9670;&nbsp;</a></span>MAX_NUM_CONVERT_TO_TETS_INDS_OUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int ug::prism_rules::MAX_NUM_CONVERT_TO_TETS_INDS_OUT = 15</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="group__lib__grid__algorithms__volume__util.html#ga091a48c6244029acd671f4e23309799a">ug::ConvertToTetrahedra()</a>.</p>

</div>
</div>
<a id="ab2a8f14ac3393e97f8ccce280de9deac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2a8f14ac3393e97f8ccce280de9deac">&#9670;&nbsp;</a></span>MAX_NUM_INDS_OUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int ug::prism_rules::MAX_NUM_INDS_OUT = 128</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a260ead43f4ed5ebc16c06af1aaad3d60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a260ead43f4ed5ebc16c06af1aaad3d60">&#9670;&nbsp;</a></span>NUM_EDGES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int ug::prism_rules::NUM_EDGES = 9</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="namespaceug_1_1prism__rules.html#a57bc08be636f9025945a4e16bdc42ac9">Refine()</a>.</p>

</div>
</div>
<a id="a7bcea38ea00d9b26cb36ed1b1dd72adb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bcea38ea00d9b26cb36ed1b1dd72adb">&#9670;&nbsp;</a></span>NUM_FACES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int ug::prism_rules::NUM_FACES = 5</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="namespaceug_1_1prism__rules.html#a57bc08be636f9025945a4e16bdc42ac9">Refine()</a>.</p>

</div>
</div>
<a id="a09d8297c5255df8768658bb01586f472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09d8297c5255df8768658bb01586f472">&#9670;&nbsp;</a></span>NUM_QUADS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int ug::prism_rules::NUM_QUADS = 3</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="namespaceug_1_1prism__rules.html#a57bc08be636f9025945a4e16bdc42ac9">Refine()</a>.</p>

</div>
</div>
<a id="a44febba99968c2c1dccb35df8f6c7499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44febba99968c2c1dccb35df8f6c7499">&#9670;&nbsp;</a></span>NUM_TRIS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int ug::prism_rules::NUM_TRIS = 2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a013c9dfc63bb6a464e93c43d3a04e555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a013c9dfc63bb6a464e93c43d3a04e555">&#9670;&nbsp;</a></span>NUM_VERTICES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int ug::prism_rules::NUM_VERTICES = 6</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="namespaceug_1_1prism__rules.html#a57bc08be636f9025945a4e16bdc42ac9">Refine()</a>.</p>

</div>
</div>
<a id="acd3160bd4e5b5f955c4d21c429b48076"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd3160bd4e5b5f955c4d21c429b48076">&#9670;&nbsp;</a></span>OPPOSED_FACE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int ug::prism_rules::OPPOSED_FACE[<a class="el" href="namespaceug_1_1prism__rules.html#a7bcea38ea00d9b26cb36ed1b1dd72adb">NUM_FACES</a>] = {4, -1, -1, -1, 0}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the index of the face opposed to the given one. -1 if no face is opposed </p>

</div>
</div>
<a id="aa368c2d9028fd5fda53f2da06669076a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa368c2d9028fd5fda53f2da06669076a">&#9670;&nbsp;</a></span>OPPOSED_OBJECT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int ug::prism_rules::OPPOSED_OBJECT[][<a class="el" href="namespaceug_1_1prism__rules.html#a013c9dfc63bb6a464e93c43d3a04e555">NUM_VERTICES</a>] = {{1, 7}, {1, 8}, {1, 6}, {1, 1}, {1, 2}, {1, 0}}</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>for each vertex, a pair containing the object type (0: vrt, 1: edge, 2: face) and an index into the associated array, which describe the object which lies on the opposite side of the prism, to a given vertex. </p>

</div>
</div>
<a id="a7654423497f37cf8308d4d5aadc85c62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7654423497f37cf8308d4d5aadc85c62">&#9670;&nbsp;</a></span>QUADS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int ug::prism_rules::QUADS[3] = {1, 2, 3}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="namespaceug.html#aaa6dc6e820042160919759e9d5f80c18">ug::CreateHexahedronFromPrisms()</a>, and <a class="el" href="namespaceug_1_1prism__rules.html#a57bc08be636f9025945a4e16bdc42ac9">Refine()</a>.</p>

</div>
</div>
<a id="aeaee17e9f35d3a685a9a3bf0106498fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaee17e9f35d3a685a9a3bf0106498fe">&#9670;&nbsp;</a></span>TOP_FACE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int ug::prism_rules::TOP_FACE = 4</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6a2540ed8a485dda4faa039b7041e972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a2540ed8a485dda4faa039b7041e972">&#9670;&nbsp;</a></span>TRIS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int ug::prism_rules::TRIS[2] = {0, 4}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="namespaceug.html#aaa6dc6e820042160919759e9d5f80c18">ug::CreateHexahedronFromPrisms()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceug.html">ug</a></li><li class="navelem"><a class="el" href="namespaceug_1_1prism__rules.html">prism_rules</a></li>
    <li class="footer">Generated on Mon Nov 13 2023 00:56:25 for ug4 by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
