<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ug4: UserData</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ug4
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('page_l_d_user_data.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">UserData </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>An IElemDisc object can assemble the local stiffness/mass matrix and/or the local defect/rhs. In order to accomplish this task user defined data is often needed for several integration points on the element. On this page, we describe the idea of the UserData import, that is used in ug.</p>
<ul>
<li><a class="el" href="page_l_d_user_data.html#secDataImport">Data Import</a></li>
<li><a class="el" href="page_l_d_user_data.html#secUserData">UserData</a></li>
<li><a class="el" href="page_l_d_user_data.html#secDataExport">Data Export</a></li>
<li><a class="el" href="page_l_d_user_data.html#secEvaluationOrder">Evaluation Order</a></li>
</ul>
<p>While this page is concentrated on the technical usage, a more detailed and mathematical introduction to the import/export strategy can be found on <a class="el" href="page_l_d_import_export.html">Import/Export Concept</a>. <br  />
</p>
<hr  />
 <h1><a class="anchor" id="secDataImport"></a>
Data Import</h1>
<hr  />
<p> Each IElemDisc may have several DataImports, describing some user defined functions or data given from outside of the IElemDisc. To give an idea, this may be a Diffusion Tensor, a Velocity field, some reaction constants, but also data computed by other IElemDisc, such as their local solution values at those points or some computed velocity field etc. This data must be known at several points on each element. We call this points IntegrationPoints, as they are usually linked to some quadrature procedure. Please note, that the position of the integration points is uniquely and only determined by the requesting IElemDisc. Other (data exporting) IElemDiscs or the user defined Data must not need any information on how and why these integration points have been chosen. This is important to ensure, that IElemDiscs remain independent from each other.</p>
<p>The IElemDisc tells the DataImport, at which integration points it wants to evaluate the data. This is done in two fashions: </p><ul>
<li>
local integration points: A vector of all ips expressed in reference element coordinates. This is usually needed for data exported by other IElemDiscs </li>
<li>
global integration points: A vector if all ips expressed in global (i.e. physical world) coordinates. This is usually needed for user-defined data </li>
</ul>
<p>Please note, that only a pointer to the vector of coordinates together with the number of integration points is stored when requesting user data. Some reason for that:</p>
<ul>
<li>
Storing positions in a vector-like structure gives good cache hit rates </li>
<li>
Computing the data for all ips with only one virtual call </li>
<li>
The identity of two requested ip series is compared using the pointer to the integration points. Iff two pointers are equal, the computation of the second request is skipped, since not needed. This comparison and scheduling of evaluation is done before the loop over all elements starts. </li>
</ul>
<p>Lets show the usage with the example of a Diffusion Tensor Import. The Import is realized by class member </p><div class="fragment"><div class="line">  DataImport&lt;MathMatrix&lt;dim,dim&gt;, <a class="codeRef" href="../plugins/group__small__strain__mechanics.html#ga425548c7b0fe054612f37d1f3a4826b6">dim</a>, algebra_type&gt; m_Diff;</div>
<div class="ttc" id="agroup__small__strain__mechanics_html_ga425548c7b0fe054612f37d1f3a4826b6"><div class="ttname"><a href="../plugins/group__small__strain__mechanics.html#ga425548c7b0fe054612f37d1f3a4826b6">dim</a></div><div class="ttdeci">static const int dim</div></div>
</div><!-- fragment --><p> This indicates, that the computed/imported data has the C++-type <b>MathMatrix&lt;dim,dim&gt;</b>, the dimension of the global coordinates is <b>dim</b>. This Import must be registered, in order to include it to the evaluation process, by calling (e.g. in the constructor): </p><div class="fragment"><div class="line"><span class="comment">//  register imports</span></div>
<div class="line">  register_import(m_Diff);</div>
</div><!-- fragment --><p>The request of a local integration point series must be done in <b> prep_elem_loop(const ReferenceObjectID roid, const int si) </b>, like e.g.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">template</span> &lt;<span class="keyword">class</span> TElem, <span class="keywordtype">int</span> TWorldDim&gt; <span class="keyword">class </span>TFVGeom,</div>
<div class="line">      <span class="keyword">typename</span> TDomain,</div>
<div class="line">      <span class="keyword">typename</span> TAlgebra&gt;</div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TElem&gt;</div>
<div class="line"><span class="keywordtype">bool</span> FVConvectionDiffusion&lt;TFVGeom, TDomain, TAlgebra&gt;::</div>
<div class="line">prep_elem_loop(<span class="keyword">const</span> <a class="code" href="namespaceug.html#a1f0e19a0ec74b2ebb64238aeb498c51b">ReferenceObjectID</a> roid, <span class="keyword">const</span> <span class="keywordtype">int</span> si)</div>
<div class="line">{</div>
<div class="line"><span class="comment">//  get reference element type</span></div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> reference_element_traits&lt;TElem&gt;::reference_element_type</div>
<div class="line">                                ref_elem_type;</div>
<div class="line">                                </div>
<div class="line"><span class="comment">//  get Finite-Volume Geometry                              </span></div>
<div class="line">  TFVGeom&lt;TElem, dim&gt;&amp; geo = FVGeometryProvider::get_geom&lt;TFVGeom, TElem, dim&gt;();</div>
<div class="line"> </div>
<div class="line"><span class="comment">//  set local positions</span></div>
<div class="line">  m_Diff.template set_local_ips&lt;ref_elem_type::dim&gt;(geo.scvf_local_ips(),</div>
<div class="line">                                                   geo.num_scvf_ips());</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceug_html_a1f0e19a0ec74b2ebb64238aeb498c51b"><div class="ttname"><a href="namespaceug.html#a1f0e19a0ec74b2ebb64238aeb498c51b">ug::ReferenceObjectID</a></div><div class="ttdeci">ReferenceObjectID</div><div class="ttdoc">these ids are used to identify the shape of a geometric object.</div><div class="ttdef"><b>Definition:</b> grid_base_objects.h:74</div></div>
</div><!-- fragment --><p>The request of the global integration points takes place in <b>prep_elem()</b>, after the global ips have been updated for the element:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">template</span> &lt;<span class="keyword">class</span> TElem, <span class="keywordtype">int</span> TWorldDim&gt; <span class="keyword">class </span>TFVGeom,</div>
<div class="line">      <span class="keyword">typename</span> TDomain,</div>
<div class="line">      <span class="keyword">typename</span> TAlgebra&gt;</div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TElem &gt;</div>
<div class="line"><span class="keywordtype">bool</span> FVConvectionDiffusion&lt;TFVGeom, TDomain, TAlgebra&gt;::</div>
<div class="line">prep_elem(TElem* elem, <span class="keyword">const</span> LocalVector&amp; u,</div>
<div class="line">                <span class="keyword">const</span> LocalIndices&amp; glob_ind)</div>
<div class="line">{</div>
<div class="line"><span class="comment">//  Load corners of this element</span></div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = 0; i &lt; m_vCornerCoords.size(); ++i)</div>
<div class="line">  {</div>
<div class="line">    Vertex* vert = elem-&gt;vertex(i);</div>
<div class="line">    m_vCornerCoords[i] = m_aaPos[vert];</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"><span class="comment">//  Update Geometry for this element</span></div>
<div class="line">  TFVGeom&lt;TElem, dim&gt;&amp; geo = FVGeometryProvider::get_geom&lt;TFVGeom, TElem,dim&gt;();</div>
<div class="line">  <span class="keywordflow">try</span>{</div>
<div class="line">    geo.update(elem, m_pDomain-&gt;subset_handler(), vCornerCoords))</div>
<div class="line">  }</div>
<div class="line">  <a class="code" href="group__ugbase__common.html#ga10f56dc5558c42d0e0ab5bb875c73ac7">UG_CATCH_THROW</a>(<span class="stringliteral">&quot;FVConvectionDiffusion::prep_elem:&quot;</span></div>
<div class="line">          <span class="stringliteral">&quot; Cannot update Finite Volume Geometry.&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">//  set global positions for rhs</span></div>
<div class="line">  m_Diff.set_global_ips(geo.scvf_global_ips(), geo.num_scvf_ips());</div>
<div class="line">}</div>
<div class="ttc" id="agroup__ugbase__common_html_ga10f56dc5558c42d0e0ab5bb875c73ac7"><div class="ttname"><a href="group__ugbase__common.html#ga10f56dc5558c42d0e0ab5bb875c73ac7">UG_CATCH_THROW</a></div><div class="ttdeci">#define UG_CATCH_THROW(msg)</div><div class="ttdef"><b>Definition:</b> error.h:64</div></div>
</div><!-- fragment --><p>Then, in each <b>assemble_...()</b> function the data can be accessed at the integration points like this</p>
<div class="fragment"><div class="line"><span class="keywordtype">size_t</span> ip = 0;</div>
<div class="line"><span class="keywordflow">if</span>(!m_Diff.zero_data())</div>
<div class="line">{</div>
<div class="line"><span class="comment">//  loop Sub Control Volume Faces (SCVF)</span></div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = 0; i &lt; geo.num_scvf(); ++i)</div>
<div class="line">  {</div>
<div class="line">  <span class="comment">//  get current SCVF</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">typename</span> TFVGeom&lt;TElem, dim&gt;::SCVF&amp; scvf = geo.scvf(i);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//  loop integration point of SCVF</span></div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = 0; i &lt; scvf.num_ip(); ++i, ++ip)</div>
<div class="line">    {</div>
<div class="line">    <span class="comment">//  loop shape functions</span></div>
<div class="line">      <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> j = 0; j &lt; scvf.num_sh(); ++j)</div>
<div class="line">      {</div>
<div class="line">      <span class="comment">//  Compute Diffusion Tensor times Gradient</span></div>
<div class="line">        MathMatrix&lt;dim, dim&gt; ipDiffTensor = m_Diff[ip];</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><hr  />
 <h1><a class="anchor" id="secUserData"></a>
UserData</h1>
<hr  />
<p>The base class for Data, that can be plugged into the Data Import is given by the class <b>UserData</b>. In ug, we distinguish four kinds of UserData:</p>
<ul>
<li>
default data (usually zero or identity data) </li>
<li>
constant data </li>
<li>
data depending on \( (\vec{x}, t) \), i.e. on the global space coordinate and the time. </li>
<li>
data produced by other IElemDiscs. </li>
</ul>
<p>Default data is used, iff no data has been set to the Data Import. The the IElemDisc may decide to use a predefined default value. This is usually zero, sometimes identity.</p>
<p>The base class for the last three data, is the class </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TData&gt;</div>
<div class="line"><span class="keyword">class </span>UserData</div>
</div><!-- fragment --><p>This class can provide the data for the templated type. It knows:</p>
<ul>
<li>
The number of integration points </li>
<li>
The Data at the integration points </li>
</ul>
<p>Note, that we have to serve a variety of possible setting. This ranges between to extremes:</p>
<ul>
<li>
Data is used by several IElemDiscs at exactly the same points. Thus, we want to compute the data only once. </li>
<li>
Data is needed at different points. Thus, several data sets must be produced using the same evaluation function, but at different points. </li>
</ul>
<p>In order to implement this, every DataImport is connected to exactly one UserData. Then, it requests the needed ips using <b>register_local_ip_series( ... )</b> and gets a <b>Series ID</b>. This id is like a ticket for the Import. Each time it requests the data at its points, the Import must use the ID to indicate which series it has requested. Internally, requests to identical ip points, will produce identical series IDs and the data at those points will only be computed once, while several Imports have access to the data.</p>
<hr  />
 <h1><a class="anchor" id="secDataExport"></a>
Data Export</h1>
<hr  />
<p>Each IElemDisc can provide as many <b>DataExports</b> as it wants. In general, an Export can be regarded as the offer to compute data at integration points (and its derivative w.r.t. the local unknowns in case of Jacobian). Please note: if no request is made to use this offer, no computation or call to an export takes place, resulting in a zero overhead.</p>
<p>In order to implement the a DataExport, a class defines a member of this type. </p><div class="fragment"><div class="line">  DataExport&lt;MathVector&lt;dim&gt;, <a class="codeRef" href="../plugins/group__small__strain__mechanics.html#ga425548c7b0fe054612f37d1f3a4826b6">dim</a>, algebra_type&gt; m_DarcyVelExport;</div>
</div><!-- fragment --><p>Now, a evaluation function must be written in the same class, with the signature: </p><div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TElem&gt;</div>
<div class="line">  <span class="keywordtype">bool</span> </div>
<div class="line">  IElemDisc&lt;TAlgebra&gt;::</div>
<div class="line">  compute_darcy_export(<span class="keyword">const</span> LocalVector&amp; u, <span class="keywordtype">bool</span> compDeriv);</div>
</div><!-- fragment --><p>A DataExport uses the local integration points to compute the data.</p>
<p>On creation the IElemDisc must register all element types it can evalute the data for, by </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TElem&gt;</div>
<div class="line"><span class="keywordtype">void</span> register_all_assemble_functions(<span class="keywordtype">int</span> <span class="keywordtype">id</span>)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">typedef</span> DensityDrivenFlow T;</div>
<div class="line"> </div>
<div class="line">  m_DarcyVelExport.reg_export_fct(<span class="keywordtype">id</span>, <span class="keyword">this</span>, &amp;T::template compute_darcy_export&lt;TElem&gt;);</div>
<div class="line">}</div>
</div><!-- fragment --><hr  />
 <h1><a class="anchor" id="secEvaluationOrder"></a>
EvaluationOrder</h1>
<hr  />
<p>The order of evaluation is as follows.</p>
<ol>
<li>
Setup (before loop over all elements) <ol>
<li>
Get Imports from every IElemDisc. </li>
<li>
Sort the connected data by its behaviour: constant, user-defined and data-export data. Each type is scheduled for computation at a certain point. </li>
<li>
Remember imports that are connected to a non-zero-derivative data. This imports are scheduled for the evaluation of the linearized defect. </li>
<li>
TODO: Skip Exports, that are already scheduled. </li>
<li>
<b>set_roid(...)</b>: Set geometric object type for each IElemDisc to indicate which evaluation function must be used </li>
<li>
<b>prep_elem_loop(...)</b>: Call preparation of element loop for each IElemDisc. Local positions are set for DataImports here. </li>
<li>
For all DataImports: Set the geometric object type to indicate which evaluation function must be used </li>
<li>
For all DataExports: Set the geometric object type to indicate which evaluation function must be used </li>
<li>
Compute <b> Constant User Data </b>, since they only depend on number of integration points </li>
</ol>
</li>
<li>
Loop all elements. For each element do: <ol>
<li>
<b>prep_elem(...)</b>: Prepare element for each IElemDisc. Here, the new global ips are computed and set for each IDataImport </li>
<li>
Compute all user-defined data </li>
<li>
Compute all exports </li>
<li>
For Jacobian: Compute linearized defect w.r.t. to Imports </li>
<li>
<b>assemble_....(...)</b>: Call assemble function of each IElemDisc </li>
<li>
For Jacobian: Assemble inter-IElemDisc coupling by multiplying linearized defect with Data derivative for each import. </li>
</ol>
</li>
<li>
Post process (after loop over all elements) <ol>
<li>
<b>fsh_elem_loop()</b>: Finish element loop for each IElemDisc </li>
</ol>
</li>
</ol>
<p>The main point is, that first the ip positions are set and then the UserData is computed before the local assemble_... functions are called for each IElemDisc. Therefore, the computed user data can be used in these functions. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">ug4 - Documentation</a></li><li class="navelem"><a class="el" href="page_u_g4_development.html">Development</a></li><li class="navelem"><a class="el" href="page_l_d_introduction.html">libDiscretization</a></li>
    <li class="footer">Generated on Mon Feb 19 2024 00:54:37 for ug4 by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
