<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ug4: libGrid - Overview</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ug4
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('page_l_g_overview.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">libGrid - Overview </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><ul>
<li><a class="el" href="page_l_g_overview.html#secGrid">Grid</a></li>
<li><a class="el" href="page_l_g_overview.html#secGeomObjs">Geometric Objects</a></li>
<li><a class="el" href="page_l_g_overview.html#secObjectCreation">Object Creation</a></li>
<li><a class="el" href="page_l_g_overview.html#secObjectIteration">Object Iteration</a></li>
<li><a class="el" href="page_l_g_overview.html#secAttachments">Attachments</a></li>
<li><a class="el" href="page_l_g_overview.html#secNeighborhood">Neighborhood</a></li>
<li><a class="el" href="page_l_g_overview.html#secTools">Tools</a> <br  />
 <hr  />
 </li>
</ul>
<h1><a class="anchor" id="secGrid"></a>
Grid</h1>
<hr  />
<p> The central class of libGrid is the Grid class. It handles element creation, neighbourhood management, data-attachments and observers. The class MultiGrid is derived from Grid, and adds a hierarchical structure to the grids elements.</p><ul>
<li><a class="el" href="classug_1_1_grid.html" title="Manages the elements of a grid and their interconnection.">ug::Grid</a></li>
<li><a class="el" href="classug_1_1_multi_grid.html">ug::MultiGrid</a></li>
</ul>
<p><br  />
 </p><hr  />
 <h1><a class="anchor" id="secGeomObjs"></a>
Geometric Objects</h1>
<hr  />
<p> Geometric Objects are the building blocks of a grid. There are four different basic geometric objects:</p><ul>
<li><a class="el" href="classug_1_1_vertex.html" title="Base-class for all vertex-types.">ug::Vertex</a></li>
<li><a class="el" href="classug_1_1_edge.html" title="Base-class for edges.">ug::Edge</a></li>
<li><a class="el" href="classug_1_1_face.html" title="Faces are 2-dimensional objects.">ug::Face</a></li>
<li><a class="el" href="classug_1_1_volume.html" title="Volumes are 3-dimensional objects.">ug::Volume</a></li>
</ul>
<p>Those basic objects are then further specialized:</p><ul>
<li><a class="el" href="classug_1_1_vertex.html" title="Base-class for all vertex-types.">ug::Vertex</a></li>
<li><a class="el" href="classug_1_1_edge.html" title="Base-class for edges.">ug::Edge</a></li>
<li><a class="el" href="classug_1_1_triangle.html" title="the most simple form of a face">ug::Triangle</a>, <a class="el" href="classug_1_1_quadrilateral.html" title="a face with four points.">ug::Quadrilateral</a></li>
<li><a class="el" href="classug_1_1_tetrahedron.html" title="the most simple volume-element.">ug::Tetrahedron</a>, <a class="el" href="classug_1_1_hexahedron.html" title="A volume element with 6 quadrilateral sides.">ug::Hexahedron</a>, <a class="el" href="classug_1_1_prism.html" title="A volume element with 2 triangle and 3 quadrilateral sides.">ug::Prism</a>, <a class="el" href="classug_1_1_pyramid.html" title="A volume element with 4 triangle and 1 quadrilateral sides.">ug::Pyramid</a></li>
</ul>
<p>For hanging-node support the following objects are introduced:</p><ul>
<li><a class="el" href="classug_1_1_constrained_vertex.html" title="A vertex appearing on edges or faces.">ug::ConstrainedVertex</a></li>
<li><a class="el" href="classug_1_1_constraining_edge.html" title="contains elements of type">ug::ConstrainingEdge</a>. <a class="el" href="classug_1_1_constraining_edge.html" title="contains elements of type">ug::ConstrainingEdge</a></li>
<li><a class="el" href="classug_1_1_constraining_triangle.html" title="a triangle constraining other objects.">ug::ConstrainingTriangle</a>, <a class="el" href="classug_1_1_constraining_quadrilateral.html" title="a quadrilateral constraining other objects.">ug::ConstrainingQuadrilateral</a>, <a class="el" href="classug_1_1_constrained_triangle.html" title="a triangle constrained by another object.">ug::ConstrainedTriangle</a>, <a class="el" href="classug_1_1_constrained_quadrilateral.html" title="a quadrilateral constrained by another object.">ug::ConstrainedQuadrilateral</a></li>
</ul>
<p>All geometric objects deriving from Edge, Face or Volume feature methods to access the vertices of an element:</p><ul>
<li><a class="el" href="classug_1_1_face_vertices.html#a91c22d6b5fcc4c90e359685aafe2aa19">ug::Face::num_vertices</a> (the number of vertices / corners of the geometric object)</li>
<li><a class="el" href="classug_1_1_face_vertices.html#a8f18cc58d9b6142a2d3728cfe55159d1">ug::Face::vertex</a> (returns the i-th vertex of the geometric object)</li>
<li><a class="el" href="classug_1_1_face_vertices.html#a6b0da4dcacca2cec9869b7a87ad6381b">ug::Face::vertices</a> (returns a list of all vertices of the geometric object)</li>
</ul>
<p>Furthermore they define methods like</p><ul>
<li><a class="el" href="classug_1_1_face.html#abeecffdd8770d3a32117739c415b5241">ug::Face::num_sides</a> (tells how many sides the given face has)</li>
</ul>
<p>Please check the documentation of the different base types.</p>
<p><br  />
 </p><hr  />
 <h1><a class="anchor" id="secObjectCreation"></a>
Object Creation</h1>
<hr  />
<p> Geometric Objects are created through the <a class="el" href="classug_1_1_grid.html#adfae2fb22706392c881d20f696e97ba9" title="create a custom element.">ug::Grid::create</a> method (or <a class="el" href="classug_1_1_multi_grid.html#adf68de245ced2b583060bb158ed51555" title="create a custom element on a specific level.">ug::MultiGrid::create</a>). Since the Grid class only knows about the basic geometric objects, <a class="el" href="classug_1_1_grid.html#adfae2fb22706392c881d20f696e97ba9" title="create a custom element.">ug::Grid::create&lt;TGeomObj&gt;</a> is a template method, that takes the type of the geometric object that is to be created as template argument: </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceug.html">ug</a>;(</div>
<div class="line">...</div>
<div class="line">Grid g;</div>
<div class="line"><span class="comment">// create vertices </span></div>
<div class="line">Vertex* v1 = *g.create&lt;Vertex&gt;();</div>
<div class="line">Vertex* v2 = *g.create&lt;Vertex&gt;();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// create an edge </span></div>
<div class="line">g.create&lt;Edge&gt;(EdgeDescriptor(v1, v2));</div>
<div class="ttc" id="anamespaceug_html"><div class="ttname"><a href="namespaceug.html">ug</a></div><div class="ttdoc">the ug namespace</div></div>
</div><!-- fragment --><p>The create method takes an optional parameter: </p><div class="fragment"><div class="line"><a class="code" href="classug_1_1_grid.html#adfae2fb22706392c881d20f696e97ba9">ug::Grid::create</a>(GeometricObject* pParent = NULL);</div>
<div class="ttc" id="aclassug_1_1_grid_html_adfae2fb22706392c881d20f696e97ba9"><div class="ttname"><a href="classug_1_1_grid.html#adfae2fb22706392c881d20f696e97ba9">ug::Grid::create</a></div><div class="ttdeci">geometry_traits&lt; TGeomObj &gt;::iterator create(GridObject *pParent=NULL)</div><div class="ttdoc">create a custom element.</div><div class="ttdef"><b>Definition:</b> grid_impl.hpp:69</div></div>
</div><!-- fragment --><p> The parent is used in different ways:</p><ul>
<li><a class="el" href="classug_1_1_grid_subset_handler.html" title="Partitions elements of a grid into several subsets.">ug::GridSubsetHandler</a> can automatically assign a subset based on the parents subset.</li>
<li><a class="el" href="classug_1_1_selector.html" title="specialization of ISelector for a grid of class Grid.">ug::Selector</a> can automatically assign the selection-status based on the parents selection status.</li>
<li>A <a class="el" href="classug_1_1_multi_grid.html">ug::MultiGrid</a> inserts elements one level above the parents level.</li>
<li>You can use the parent in your own grid-observer specializations (derive from <a class="el" href="classug_1_1_grid_observer.html">ug::GridObserver</a>)</li>
</ul>
<p>All those beahviours can be enabled / disabled in the respective classes.</p>
<p><br  />
 </p><hr  />
 <h1><a class="anchor" id="secObjectIteration"></a>
Object Iteration</h1>
<hr  />
<p> libGrid uses the technique of iterators for geometric-object access. A separate iterator-type exists for each object-type:</p><ul>
<li><a class="el" href="namespaceug.html#a1903407556f1e2b80c006ae920ea8e0e" title="This Iterator will be used as base-class for iterators of specialized geometric objects.">ug::VertexIterator</a>, <a class="el" href="namespaceug.html#a9ef49097e6b5b6261ec9af3923db20ec">ug::RegularVertexIterator</a>, ...</li>
<li><a class="el" href="namespaceug.html#a499d06e0979bcf1e0eec2d93e1cb44ce">ug::EdgeIterator</a>, <a class="el" href="namespaceug.html#a71f56bc9433c161bd1a122c0bc8d668a">ug::RegularEdgeIterator</a>, ...</li>
<li><a class="el" href="namespaceug.html#a238c06e12b8d23c6fbdf6a9a6de07032">ug::FaceIterator</a>, <a class="el" href="namespaceug.html#a6a1797510c4362a7f426418dadba2635">ug::TriangleIterator</a>, <a class="el" href="namespaceug.html#a15ffcc65340980c745bdf5de374b100a">ug::QuadrilateralIterator</a>, ...</li>
<li><a class="el" href="namespaceug.html#acfca06691cc716e83d5e0bc6c584a3c6">ug::TetrahedronIterator</a>, <a class="el" href="namespaceug.html#aa72a71b4ad5415dd142debbc9a7cf278">ug::HexahedronIterator</a>, <a class="el" href="namespaceug.html#a1ad1d2d1ca5b66603e03caafb3969883">ug::PrismIterator</a>, <a class="el" href="namespaceug.html#af984ed5c411f44f263ebf617a9b849a6">ug::PyramidIterator</a></li>
</ul>
<p>You can query a grid for a begin and an end-iterator for each geometric-object type using <a class="el" href="classug_1_1_grid.html#ac61deaa5a86f28e8e78fa481467f5d45">ug::Grid::begin</a> and <a class="el" href="classug_1_1_grid.html#aecec2b9e3e45241347497a58de7aa13a">ug::Grid::end</a>. Both methods are template methods. The template argument specifies the type of geometric-object over which you want to iterate.</p>
<div class="fragment"><div class="line"><span class="comment">// Let g be a grid that already contains some geometric objects </span></div>
<div class="line"><span class="comment">// iterate over all vertices </span></div>
<div class="line"><span class="keywordflow">for</span>(<a class="code" href="namespaceug.html#a1903407556f1e2b80c006ae920ea8e0e">VertexIterator</a> iter = g.begin&lt;Vertex&gt;();</div>
<div class="line">  iter != g.end&lt;Vertex&gt;(); ++iter)</div>
<div class="line">{</div>
<div class="line">  Vertex* v = *iter;</div>
<div class="line">  ...</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// iterate over all faces </span></div>
<div class="line"><span class="keywordflow">for</span>(<a class="code" href="namespaceug.html#a238c06e12b8d23c6fbdf6a9a6de07032">FaceIterator</a> iter = g.begin&lt;Face&gt;();</div>
<div class="line">  iter != g.end&lt;Face&gt;(); ++iter)</div>
<div class="line">{</div>
<div class="line">  Face* f = *iter;</div>
<div class="line">  ...</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// iterate over all triangles </span></div>
<div class="line"><span class="keywordflow">for</span>(<a class="code" href="namespaceug.html#a6a1797510c4362a7f426418dadba2635">TriangleIterator</a> iter = g.begin&lt;Triangle&gt;();</div>
<div class="line">  iter != g.end&lt;Triangle&gt;(); ++iter)</div>
<div class="line">{</div>
<div class="line">  Triangle* t = *iter;</div>
<div class="line">  ...</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceug_html_a1903407556f1e2b80c006ae920ea8e0e"><div class="ttname"><a href="namespaceug.html#a1903407556f1e2b80c006ae920ea8e0e">ug::VertexIterator</a></div><div class="ttdeci">ElementStorage&lt; Vertex &gt;::SectionContainer::iterator VertexIterator</div><div class="ttdoc">This Iterator will be used as base-class for iterators of specialized geometric objects.</div><div class="ttdef"><b>Definition:</b> grid_base_object_traits.h:73</div></div>
<div class="ttc" id="anamespaceug_html_a238c06e12b8d23c6fbdf6a9a6de07032"><div class="ttname"><a href="namespaceug.html#a238c06e12b8d23c6fbdf6a9a6de07032">ug::FaceIterator</a></div><div class="ttdeci">ElementStorage&lt; Face &gt;::SectionContainer::iterator FaceIterator</div><div class="ttdef"><b>Definition:</b> grid_base_object_traits.h:79</div></div>
<div class="ttc" id="anamespaceug_html_a6a1797510c4362a7f426418dadba2635"><div class="ttname"><a href="namespaceug.html#a6a1797510c4362a7f426418dadba2635">ug::TriangleIterator</a></div><div class="ttdeci">geometry_traits&lt; Triangle &gt;::iterator TriangleIterator</div><div class="ttdef"><b>Definition:</b> grid_objects_2d.h:211</div></div>
</div><!-- fragment --><p>The same technique can be used to iterate over all Triangles of a subset: </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceug.html">ug</a>;</div>
<div class="line">...</div>
<div class="line"><a class="code" href="classug_1_1_grid.html">Grid</a> g;</div>
<div class="line"><a class="code" href="namespaceug.html#a4077697589380822c2f46b597f550f4b">SubsetHandler</a> sh(g);  <span class="comment">// short for GridSubsetHandler</span></div>
<div class="line">...</div>
<div class="line"><span class="comment">// iterate over all triangles in subset 0 </span></div>
<div class="line">for(<a class="code" href="namespaceug.html#a6a1797510c4362a7f426418dadba2635">TriangleIterator</a> iter = sh.begin&lt;Triangle&gt;(0);</div>
<div class="line">  iter != sh.end&lt;Triangle&gt;(0); ++iter)</div>
<div class="line">{</div>
<div class="line">  Triangle* t = *iter;</div>
<div class="line">  ...</div>
<div class="line">}</div>
<div class="ttc" id="aclassug_1_1_grid_html"><div class="ttname"><a href="classug_1_1_grid.html">ug::Grid</a></div><div class="ttdoc">Manages the elements of a grid and their interconnection.</div><div class="ttdef"><b>Definition:</b> grid.h:132</div></div>
<div class="ttc" id="anamespaceug_html_a4077697589380822c2f46b597f550f4b"><div class="ttname"><a href="namespaceug.html#a4077697589380822c2f46b597f550f4b">ug::SubsetHandler</a></div><div class="ttdeci">GridSubsetHandler SubsetHandler</div><div class="ttdef"><b>Definition:</b> subset_handler_grid.h:376</div></div>
</div><!-- fragment --><p>or a <a class="el" href="classug_1_1_selector.html" title="specialization of ISelector for a grid of class Grid.">ug::Selector</a> </p><div class="fragment"><div class="line">...</div>
<div class="line">Selector sel(g);</div>
<div class="line">...</div>
<div class="line">for(<a class="code" href="namespaceug.html#a6a1797510c4362a7f426418dadba2635">TriangleIterator</a> iter = sel.begin&lt;Triangle&gt;();</div>
<div class="line">  iter != sel.end&lt;Triangle&gt;(); ++iter)</div>
<div class="line">...</div>
</div><!-- fragment --><p>or a level of a <a class="el" href="classug_1_1_multi_grid.html">ug::MultiGrid</a> </p><div class="fragment"><div class="line">...</div>
<div class="line">MultiGrid mg;</div>
<div class="line">...</div>
<div class="line">for(<a class="code" href="namespaceug.html#a6a1797510c4362a7f426418dadba2635">TriangleIterator</a> iter = mg.begin&lt;Triangle&gt;(0);</div>
<div class="line">  iter != mg.end&lt;Triangle&gt;(0); ++iter)</div>
</div><!-- fragment --><p>or triangles on level l in subset i of a <a class="el" href="classug_1_1_multi_grid_subset_handler.html" title="Handles subsets on a per level basis.">ug::MultiGridSubsetHandler</a> </p><div class="fragment"><div class="line">...</div>
<div class="line">MGSubsetHandler mgsh(mg); <span class="comment">// short for MultiGridSubsetHandler</span></div>
<div class="line">...</div>
<div class="line">for(<a class="code" href="namespaceug.html#a6a1797510c4362a7f426418dadba2635">TriangleIterator</a> iter = mgsh.begin&lt;Triangle&gt;(i, l);</div>
<div class="line">  iter != mgsh.end&lt;Triangle&gt;(i, l); ++iter)</div>
<div class="line">...</div>
</div><!-- fragment --><p>There are even more classes that support this way of geometric-object iteration. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classug_1_1_grid_object_collection.html" title="a helper class that holds a collection of possibly unconnected geometric-objects.">ug::GridObjectCollection</a></dd></dl>
<p><br  />
 </p><hr  />
 <h1><a class="anchor" id="secAttachments"></a>
Attachments</h1>
<hr  />
<p> Through attachments custom data can be associated with the geometric objects in a <a class="el" href="classug_1_1_grid.html" title="Manages the elements of a grid and their interconnection.">ug::Grid</a> or a subset of a <a class="el" href="classug_1_1_grid_subset_handler.html" title="Partitions elements of a grid into several subsets.">ug::GridSubsetHandler</a> or <a class="el" href="classug_1_1_multi_grid_subset_handler.html" title="Handles subsets on a per level basis.">ug::MultiGridSubsetHandler</a>. Data is attached to all objects of the same basic type at once (<a class="el" href="classug_1_1_vertex.html" title="Base-class for all vertex-types.">ug::Vertex</a>, <a class="el" href="classug_1_1_edge.html" title="Base-class for edges.">ug::Edge</a>, <a class="el" href="classug_1_1_face.html" title="Faces are 2-dimensional objects.">ug::Face</a>, <a class="el" href="classug_1_1_volume.html" title="Volumes are 3-dimensional objects.">ug::Volume</a>).</p>
<p>Lets say we wanted to associate an integer with each vertex in a grid g. This could be done as follows: </p><div class="fragment"><div class="line"><span class="comment">// we define the attachment type  </span></div>
<div class="line"><span class="keyword">typedef</span> Attachment&lt;int&gt; <a class="code" href="namespaceug.html#a481b61f08e6f0643adb288dcb2d42b03">AInt</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The instance of the attachment-type serves as identifier for the attachment. </span></div>
<div class="line"><a class="code" href="namespaceug.html#a481b61f08e6f0643adb288dcb2d42b03">AInt</a> aInt;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Let g be an instance of ug::Grid or ug::MultiGrid</span></div>
<div class="line">g.attach_to_vertices(aInt);</div>
<div class="ttc" id="anamespaceug_html_a481b61f08e6f0643adb288dcb2d42b03"><div class="ttname"><a href="namespaceug.html#a481b61f08e6f0643adb288dcb2d42b03">ug::AInt</a></div><div class="ttdeci">Attachment&lt; int &gt; AInt</div><div class="ttdef"><b>Definition:</b> common_attachments.h:55</div></div>
</div><!-- fragment --><p>When aInt is being attached to the vertices of the grid, memory is automatically allocated and associated with the vertices. If you add or remove vertices, the memory is adjusted in the background.</p>
<p>To access the integer-value that is associated with each vertex, an attachment-accessor is required:</p>
<div class="fragment"><div class="line"><span class="comment">// a vertex-attachment-accessor for attachments of type AInt </span></div>
<div class="line"><span class="comment">// We want it to operate on the Grid g and on the attachment aInt  </span></div>
<div class="line">Grid::VertexAttachmentAccessor&lt;AInt&gt; aaInt(g, aInt);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// iterate over all vertices of the grid and assign 12 to the attached integer-value </span></div>
<div class="line"><span class="keywordflow">for</span>(<a class="code" href="namespaceug.html#a1903407556f1e2b80c006ae920ea8e0e">VertexIterator</a> iter = grid.vertices_begin(); iter != grid.vertices_end(); ++iter)</div>
<div class="line">  aaInt[*iter] = 12;</div>
</div><!-- fragment --><p>The vertex-attachment-accessor features the operator [] that takes a pointer to a vertex and returns a reference to the associated value.</p>
<p><br  />
 Data can be attached to elements of a subset of an <a class="el" href="classug_1_1_grid_subset_handler.html" title="Partitions elements of a grid into several subsets.">ug::GridSubsetHandler</a> or <a class="el" href="classug_1_1_multi_grid_subset_handler.html" title="Handles subsets on a per level basis.">ug::MultiGridSubsetHandler</a> like this: </p><div class="fragment"><div class="line">...</div>
<div class="line">SubsetHandler sh(g);</div>
<div class="line">...</div>
<div class="line"><span class="comment">// attach the integers to all faces in subset 2 </span></div>
<div class="line">sh.attach_to_faces(aInt, 2);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// access the attachment </span></div>
<div class="line">SubsetHandler::AttachmentAccessor&lt;Face, AInt&gt; aaIntSH2(sh, aInt, 2);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Assign values: </span></div>
<div class="line"><span class="comment">// Please note that you may only pass faces to the accessor that are contained in subset 2. </span></div>
<div class="line"><span class="keywordflow">for</span>(<a class="code" href="namespaceug.html#a238c06e12b8d23c6fbdf6a9a6de07032">FaceIterator</a> iter = sh.faces_begin(2); iter != sh.faces_end(2); ++iter)</div>
<div class="line">  aaIntSH2[*iter] = 17;</div>
</div><!-- fragment --><p><br  />
 </p><hr  />
 <h1><a class="anchor" id="secNeighborhood"></a>
Neighborhood</h1>
<hr  />
<p> Given a geometric object, there are several methods to access neighbor elements in a grid. The most powerful methods in this context is the method <a class="el" href="classug_1_1_grid.html#acfb4b5a6a7a0d46df0bdd25bbe55e74b" title="Puts all elements of type TAss which are contained in &#39;e&#39; or which contain &#39;e&#39; into elemsOut.">ug::Grid::associated_elements</a>. It can be used with any combination of geometric base objects. E.g., it can be used to retrieve all faces which are connected to an edge or all faces, which are connected to a volume element. Here is an example, where we retrieve a container with all edges, which are connected to a volume element:</p>
<div class="fragment"><div class="line"><span class="comment">//  Let vol be of type Volume* (or of any derived type) and grid of type Grid&amp;</span></div>
<div class="line"><span class="comment">//  declare a container in which we&#39;ll collect all associated edges of vol</span></div>
<div class="line">Grid::edge_traits::secure_container edges;</div>
<div class="line"> </div>
<div class="line">grid.associated_elements(edges, vol);</div>
<div class="line"> </div>
<div class="line"><span class="comment">//  one could now iterate over the received edges</span></div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = 0; i &lt; edges.size(); ++i){</div>
<div class="line">  Edge* e = edges[i];</div>
<div class="line">  <span class="comment">//...</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>The code works for all combinations of Vertex, Edge, Face and Volume. Note however, that the method does not guarantee, that the order of the elements in the returned container is the same as the order of the reference element, e.g., when collecting sides of a volume. Since some methods rely on the order, a second method exist, which guarantees that the order matches reference elements order: <a class="el" href="classug_1_1_grid.html#aeb1f90a5b4f7c8dd0d66ba42e1e93929" title="Puts all elements of type TAss which are contained in &#39;e&#39; into elemsOut in the reference elements ord...">ug::Grid::associated_elements_sorted</a>. The method can basically be used as associated_elements, but has the restriction, that the dimension of the elements in the returned container has to be lower than the dimension of the element in the second argument. Otherwise no order could be defined. Furthermore <a class="el" href="classug_1_1_grid.html#aeb1f90a5b4f7c8dd0d66ba42e1e93929" title="Puts all elements of type TAss which are contained in &#39;e&#39; into elemsOut in the reference elements ord...">ug::Grid::associated_elements_sorted</a> may be a little slower than <a class="el" href="classug_1_1_grid.html#acfb4b5a6a7a0d46df0bdd25bbe55e74b" title="Puts all elements of type TAss which are contained in &#39;e&#39; or which contain &#39;e&#39; into elemsOut.">ug::Grid::associated_elements</a>. The latter should thus be preferred, if the order is not important.</p>
<p>While those two methods allow to completely access all neighbors in a grid (possibly with a little work), some conveniance methods exist to, e.g., to retrieve a single side of an element or to retrieve all neighbors of the same geometric object type (e.g. all faces which are adjacent to a given face). All related methods are listed below.</p>
<p>The main methods to access associated elements, as explained above. Note that while those methods can be used to retrieve the vertices of, e.g., a Face, the direct way through Face::vertex or Face::vertices should be preferred if possible.</p><ul>
<li><a class="el" href="classug_1_1_grid.html#acfb4b5a6a7a0d46df0bdd25bbe55e74b" title="Puts all elements of type TAss which are contained in &#39;e&#39; or which contain &#39;e&#39; into elemsOut.">ug::Grid::associated_elements</a></li>
<li><a class="el" href="classug_1_1_grid.html#aeb1f90a5b4f7c8dd0d66ba42e1e93929" title="Puts all elements of type TAss which are contained in &#39;e&#39; into elemsOut in the reference elements ord...">ug::Grid::associated_elements_sorted</a></li>
</ul>
<p>Returns the geometric object given a couple of vertices</p><ul>
<li><a class="el" href="classug_1_1_grid.html#a631569f60d18f00177e8cf24e5b3e3ff" title="returns the edge between v1 and v2, if it exists. Returns NULL if not.">ug::Grid::get_edge</a></li>
<li><a class="el" href="classug_1_1_grid.html#a6970549d629877a26e896ed00f309210" title="returns the face that is described by fv.">ug::Grid::get_face</a></li>
<li><a class="el" href="classug_1_1_grid.html#a71943256ff9ca6c7c850db23d9d5160a" title="returns the volume that is described by ev.">ug::Grid::get_volume</a></li>
<li><a class="el" href="classug_1_1_grid.html#ac682d1dc43054317c9564af5bfdbb42f" title="returns the element for the given vertices.">ug::Grid::get_element</a></li>
</ul>
<p>Returns the i-th side of a geometric object (use e.g. Face::num_sides to retrieve the number of sides of that object).</p><ul>
<li><a class="el" href="classug_1_1_grid.html#ab629347e376069521d16bdef5db56951" title="This method returns the i-th side of an Edge, Face or Volume.">ug::Grid::get_side</a></li>
</ul>
<p>Furthermore methods exist to collect, e.g., all faces which are adjacent to a given face (same for vertices, edges and volumes):</p><ul>
<li><a class="el" href="group__lib__grid__algorithms__neighborhood__util.html#gada8aee34f6f23920bac25802273647e1" title="Collects all vertices that are connected by elements of the specified type.">ug::CollectNeighbors</a></li>
</ul>
<p><br  />
 </p><hr  />
 <h1><a class="anchor" id="secTools"></a>
Tools</h1>
<hr  />
<p> There are some classes that help tremendously when implementing algorithms: the Selector and the SubsetHandler.</p><ul>
<li><a class="el" href="classug_1_1_selector.html" title="specialization of ISelector for a grid of class Grid.">ug::Selector</a></li>
<li><a class="el" href="classug_1_1_grid_subset_handler.html" title="Partitions elements of a grid into several subsets.">ug::GridSubsetHandler</a>, <a class="el" href="classug_1_1_multi_grid_subset_handler.html" title="Handles subsets on a per level basis.">ug::MultiGridSubsetHandler</a> </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">ug4 - Documentation</a></li><li class="navelem"><a class="el" href="page_u_g4_development.html">Development</a></li><li class="navelem"><a class="el" href="page_l_g_introduction.html">libGrid</a></li>
    <li class="footer">Generated on Mon Dec 11 2023 00:57:43 for ug4 by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
