<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ug4: ug::tet_rules Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ug4
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespaceug_1_1tet__rules.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">ug::tet_rules Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a76aaa0d3db72d7532893684a989d38ee"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceug_1_1tet__rules.html#a76aaa0d3db72d7532893684a989d38ee">GlobalRefinementRule</a> { <a class="el" href="namespaceug_1_1tet__rules.html#a76aaa0d3db72d7532893684a989d38eeab68d323147de038b82283f4a2e9be6d2">STANDARD</a>
, <a class="el" href="namespaceug_1_1tet__rules.html#a76aaa0d3db72d7532893684a989d38eead23b107a795aa68259651ae52dbf8dd1">HYBRID_TET_OCT</a>
 }</td></tr>
<tr class="memdesc:a76aaa0d3db72d7532893684a989d38ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">identification of refinement rule to be used  <a href="namespaceug_1_1tet__rules.html#a76aaa0d3db72d7532893684a989d38ee">More...</a><br /></td></tr>
<tr class="separator:a76aaa0d3db72d7532893684a989d38ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9f7c36db5d2ca9ff6d1bb3e3c4cca91d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceug_1_1tet__rules.html#a76aaa0d3db72d7532893684a989d38ee">GlobalRefinementRule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceug_1_1tet__rules.html#a9f7c36db5d2ca9ff6d1bb3e3c4cca91d">GetRefinementRule</a> ()</td></tr>
<tr class="separator:a9f7c36db5d2ca9ff6d1bb3e3c4cca91d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af10518055aa3246e6443fb9d6fdc558e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceug_1_1tet__rules.html#af10518055aa3246e6443fb9d6fdc558e">InverseTetTransform</a> (int *indsOut, const int *transformedInds)</td></tr>
<tr class="separator:af10518055aa3246e6443fb9d6fdc558e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab1f521241774105d4bad174a580e5f7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceug_1_1tet__rules.html#aab1f521241774105d4bad174a580e5f7">IsRegularRefRule</a> (const int edgeMarks)</td></tr>
<tr class="memdesc:aab1f521241774105d4bad174a580e5f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if the specified edgeMarks would lead to a regular refinement  <a href="namespaceug_1_1tet__rules.html#aab1f521241774105d4bad174a580e5f7">More...</a><br /></td></tr>
<tr class="separator:aab1f521241774105d4bad174a580e5f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c86c46dc04aa4188846ea7a88ece6cd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceug_1_1tet__rules.html#a3c86c46dc04aa4188846ea7a88ece6cd">Refine</a> (int *newIndsOut, int *newEdgeVrts, bool &amp;newCenterOut, <a class="el" href="group__vectors.html#ga894cdb8af74f7a563a94fb49c220fdcd">vector3</a> *corners, bool *)</td></tr>
<tr class="separator:a3c86c46dc04aa4188846ea7a88ece6cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dab2c9e3961c63fe112e40421c450e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceug_1_1tet__rules.html#a1dab2c9e3961c63fe112e40421c450e8">SetRefinementRule</a> (<a class="el" href="namespaceug_1_1tet__rules.html#a76aaa0d3db72d7532893684a989d38ee">GlobalRefinementRule</a> refRule)</td></tr>
<tr class="separator:a1dab2c9e3961c63fe112e40421c450e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9b5fe75f9124a71640f054d68ca4e68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceug_1_1tet__rules.html#ac9b5fe75f9124a71640f054d68ca4e68">TetRotation</a> (int vrtsInOut[<a class="el" href="namespaceug_1_1tet__rules.html#a566c1e0b22e0abe654049abf3249a483">NUM_VERTICES</a>], const int fixedPoint, const size_t steps)</td></tr>
<tr class="memdesc:ac9b5fe75f9124a71640f054d68ca4e68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates the given tetrahedron while keeping the specified point fixed.  <a href="namespaceug_1_1tet__rules.html#ac9b5fe75f9124a71640f054d68ca4e68">More...</a><br /></td></tr>
<tr class="separator:ac9b5fe75f9124a71640f054d68ca4e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a6b45d48a4172cf156cef7243778a6bc6"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceug_1_1tet__rules.html#a6b45d48a4172cf156cef7243778a6bc6">EDGE_FROM_VRTS</a> [4][4]</td></tr>
<tr class="memdesc:a6b45d48a4172cf156cef7243778a6bc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associates the index of the connecting edge with each tuple of vertices.  <a href="namespaceug_1_1tet__rules.html#a6b45d48a4172cf156cef7243778a6bc6">More...</a><br /></td></tr>
<tr class="separator:a6b45d48a4172cf156cef7243778a6bc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8e2e877c0514cc085b81223a498d4a7"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceug_1_1tet__rules.html#ae8e2e877c0514cc085b81223a498d4a7">EDGE_VRT_INDS</a> [][2]</td></tr>
<tr class="memdesc:ae8e2e877c0514cc085b81223a498d4a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">the local vertex indices of the given edge  <a href="namespaceug_1_1tet__rules.html#ae8e2e877c0514cc085b81223a498d4a7">More...</a><br /></td></tr>
<tr class="separator:ae8e2e877c0514cc085b81223a498d4a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a9f42a950b7894b2e88547f24b31b06"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceug_1_1tet__rules.html#a5a9f42a950b7894b2e88547f24b31b06">FACE_CONTAINS_EDGE</a> [][6]</td></tr>
<tr class="memdesc:a5a9f42a950b7894b2e88547f24b31b06"><td class="mdescLeft">&#160;</td><td class="mdescRight">tells whether the i-th face contains the j-th edge  <a href="namespaceug_1_1tet__rules.html#a5a9f42a950b7894b2e88547f24b31b06">More...</a><br /></td></tr>
<tr class="separator:a5a9f42a950b7894b2e88547f24b31b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dcf2bc421db4e4081fbac4f395c2d76"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceug_1_1tet__rules.html#a7dcf2bc421db4e4081fbac4f395c2d76">FACE_EDGE_INDS</a> [4][4]</td></tr>
<tr class="memdesc:a7dcf2bc421db4e4081fbac4f395c2d76"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the j-th edge of the i-th face  <a href="namespaceug_1_1tet__rules.html#a7dcf2bc421db4e4081fbac4f395c2d76">More...</a><br /></td></tr>
<tr class="separator:a7dcf2bc421db4e4081fbac4f395c2d76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa3000c273e6c5fae6d85673cecd816d"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceug_1_1tet__rules.html#afa3000c273e6c5fae6d85673cecd816d">FACE_FROM_EDGES</a> [][6]</td></tr>
<tr class="memdesc:afa3000c273e6c5fae6d85673cecd816d"><td class="mdescLeft">&#160;</td><td class="mdescRight">given two edges, the table returns the face, which contains both (or -1)  <a href="namespaceug_1_1tet__rules.html#afa3000c273e6c5fae6d85673cecd816d">More...</a><br /></td></tr>
<tr class="separator:afa3000c273e6c5fae6d85673cecd816d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affc5181a744b23d51ce2e4685c23b66d"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceug_1_1tet__rules.html#affc5181a744b23d51ce2e4685c23b66d">FACE_FROM_VRTS</a> [4][4][4]</td></tr>
<tr class="memdesc:affc5181a744b23d51ce2e4685c23b66d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associates the index of the connecting face with each triple of vertices.  <a href="namespaceug_1_1tet__rules.html#affc5181a744b23d51ce2e4685c23b66d">More...</a><br /></td></tr>
<tr class="separator:affc5181a744b23d51ce2e4685c23b66d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14f45507fa9f7e4c9b279316ca1fbe26"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceug_1_1tet__rules.html#a14f45507fa9f7e4c9b279316ca1fbe26">FACE_VRT_INDS</a> [][4]</td></tr>
<tr class="memdesc:a14f45507fa9f7e4c9b279316ca1fbe26"><td class="mdescLeft">&#160;</td><td class="mdescRight">the local vertex indices of the given face  <a href="namespaceug_1_1tet__rules.html#a14f45507fa9f7e4c9b279316ca1fbe26">More...</a><br /></td></tr>
<tr class="separator:a14f45507fa9f7e4c9b279316ca1fbe26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e3a3b2ebed66f8b89877adc044440d7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceug_1_1tet__rules.html#a76aaa0d3db72d7532893684a989d38ee">GlobalRefinementRule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceug_1_1tet__rules.html#a5e3a3b2ebed66f8b89877adc044440d7">g_refinementRule</a> = <a class="el" href="namespaceug_1_1tet__rules.html#a76aaa0d3db72d7532893684a989d38eeab68d323147de038b82283f4a2e9be6d2">STANDARD</a></td></tr>
<tr class="memdesc:a5e3a3b2ebed66f8b89877adc044440d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">global refinement rule information switching between regular and subdivision volume refinement  <a href="namespaceug_1_1tet__rules.html#a5e3a3b2ebed66f8b89877adc044440d7">More...</a><br /></td></tr>
<tr class="separator:a5e3a3b2ebed66f8b89877adc044440d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a786e7291877bee650bd399a6ca3bedfb"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceug_1_1tet__rules.html#a786e7291877bee650bd399a6ca3bedfb">MAX_NUM_INDS_OUT</a> = 64</td></tr>
<tr class="separator:a786e7291877bee650bd399a6ca3bedfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d25d541669f0ca827b0823588aea527"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceug_1_1tet__rules.html#a7d25d541669f0ca827b0823588aea527">NUM_EDGES</a> = 6</td></tr>
<tr class="separator:a7d25d541669f0ca827b0823588aea527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add809a6e00e1b7639f9b9b69c6d45180"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceug_1_1tet__rules.html#add809a6e00e1b7639f9b9b69c6d45180">NUM_FACES</a> = 4</td></tr>
<tr class="separator:add809a6e00e1b7639f9b9b69c6d45180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa5300aee3a16d3a3b2b5ba3223e110"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceug_1_1tet__rules.html#a9fa5300aee3a16d3a3b2b5ba3223e110">NUM_QUADS</a> = 0</td></tr>
<tr class="separator:a9fa5300aee3a16d3a3b2b5ba3223e110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaacbbc9d4a3f5ae297d00c26f27b29e1"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceug_1_1tet__rules.html#aaacbbc9d4a3f5ae297d00c26f27b29e1">NUM_TRIS</a> = 4</td></tr>
<tr class="separator:aaacbbc9d4a3f5ae297d00c26f27b29e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a566c1e0b22e0abe654049abf3249a483"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceug_1_1tet__rules.html#a566c1e0b22e0abe654049abf3249a483">NUM_VERTICES</a> = 4</td></tr>
<tr class="separator:a566c1e0b22e0abe654049abf3249a483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0e6e7740342ff992d65e861a86a822c"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceug_1_1tet__rules.html#aa0e6e7740342ff992d65e861a86a822c">OPPOSED_EDGE</a> [] = {5, 3, 4, 1, 2, 0}</td></tr>
<tr class="memdesc:aa0e6e7740342ff992d65e861a86a822c"><td class="mdescLeft">&#160;</td><td class="mdescRight">for each edge the local index of the opposed edge  <a href="namespaceug_1_1tet__rules.html#aa0e6e7740342ff992d65e861a86a822c">More...</a><br /></td></tr>
<tr class="separator:aa0e6e7740342ff992d65e861a86a822c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1893cb1e2c7ba78c38d4c6c19a66fbc9"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceug_1_1tet__rules.html#a1893cb1e2c7ba78c38d4c6c19a66fbc9">OPPOSED_OBJECT</a> [][<a class="el" href="namespaceug_1_1tet__rules.html#a566c1e0b22e0abe654049abf3249a483">NUM_VERTICES</a>] = {{2, 1}, {2, 2}, {2, 3}, {2, 0}}</td></tr>
<tr class="separator:a1893cb1e2c7ba78c38d4c6c19a66fbc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a76aaa0d3db72d7532893684a989d38ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76aaa0d3db72d7532893684a989d38ee">&#9670;&nbsp;</a></span>GlobalRefinementRule</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceug_1_1tet__rules.html#a76aaa0d3db72d7532893684a989d38ee">ug::tet_rules::GlobalRefinementRule</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>identification of refinement rule to be used </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a76aaa0d3db72d7532893684a989d38eeab68d323147de038b82283f4a2e9be6d2"></a>STANDARD&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a76aaa0d3db72d7532893684a989d38eead23b107a795aa68259651ae52dbf8dd1"></a>HYBRID_TET_OCT&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a9f7c36db5d2ca9ff6d1bb3e3c4cca91d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f7c36db5d2ca9ff6d1bb3e3c4cca91d">&#9670;&nbsp;</a></span>GetRefinementRule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceug_1_1tet__rules.html#a76aaa0d3db72d7532893684a989d38ee">GlobalRefinementRule</a> ug::tet_rules::GetRefinementRule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceug_1_1tet__rules.html#a5e3a3b2ebed66f8b89877adc044440d7">g_refinementRule</a>.</p>

<p class="reference">Referenced by <a class="el" href="namespaceug.html#a04e558eb330f06eed22a5e5672745c44">ug::ApplySmoothSubdivisionVolumesToTopLevel()</a>.</p>

</div>
</div>
<a id="af10518055aa3246e6443fb9d6fdc558e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af10518055aa3246e6443fb9d6fdc558e">&#9670;&nbsp;</a></span>InverseTetTransform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ug::tet_rules::InverseTetTransform </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>indsOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>transformedInds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceug_1_1tet__rules.html#a566c1e0b22e0abe654049abf3249a483">NUM_VERTICES</a>, and <a class="el" href="group__ugbase__common.html#ga0b928ef153b78f1b5e025638cf28f841">UG_ASSERT</a>.</p>

<p class="reference">Referenced by <a class="el" href="namespaceug_1_1tet__rules.html#a3c86c46dc04aa4188846ea7a88ece6cd">Refine()</a>.</p>

</div>
</div>
<a id="aab1f521241774105d4bad174a580e5f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab1f521241774105d4bad174a580e5f7">&#9670;&nbsp;</a></span>IsRegularRefRule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ug::tet_rules::IsRegularRefRule </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>edgeMarks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns true if the specified edgeMarks would lead to a regular refinement </p>
<p>A regular refinement leads to new elements which are all similar to the original element. I.e. which are of the same type and which have similar angles.</p>
<dl class="section note"><dt>Note</dt><dd>this method does not perform refinement. Use 'Refine' with the specified edges instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edgeMarks</td><td>If the i-th edge shall be refined, the expression 'edgeMarks &amp; (1&lt;&lt;i) != 0' has to be true. You can specify multiple refine-edges using or-combinations. E.g., 'edgeMarks = (1&lt;&lt;i) | (1&lt;&lt;j)' would indicate that the i-th and the j-th edge shall be refined. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c86c46dc04aa4188846ea7a88ece6cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c86c46dc04aa4188846ea7a88ece6cd">&#9670;&nbsp;</a></span>Refine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ug::tet_rules::Refine </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>newIndsOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>newEdgeVrts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>newCenterOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__vectors.html#ga894cdb8af74f7a563a94fb49c220fdcd">vector3</a> *&#160;</td>
          <td class="paramname"><em>corners</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>isSnapPoint</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>returns an array of integers, which contains the indices of the objects resulting from the refinement of a tetrahedron.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newIndsOut</td><td>Array which has to be of size MAX_NUM_INDS_OUT. When the algorithm is done, the array will contain sequences of integers: {{gridObjectID, ind1, ind2, ...}, ...}. gridObjectID is a constant enumerated in GridObjectID and describes the type of the grid-object that is built from the following set of corner indices. Old vertices are referenced by their local index. Vertices created on an edge are indexed by the index of the edge + NUM_VERTICES. If an inner vertex has to be created, it is referenced by NUM_VERTICES + NUM_EDGES + NUM_FACES.</td></tr>
    <tr><td class="paramname">newEdgeVrts</td><td>Array of size NUM_EDGES, which has to contain 1 for each edge, which shall be refined and 0 for each edge, which won't be refined.</td></tr>
    <tr><td class="paramname">newCenterOut</td><td>If the refinement-rule requires a center vertex, then this parameter will be set to true. If not, it is set to false.</td></tr>
    <tr><td class="paramname">corners</td><td>(optional) List of the four corner positions of the tetrahedron. If it is specified, it is used during full refinement (all edges marked), to determine the best diagonal along which inner tetrahedrons are created. Corners are only considered during full refinement and are thus irrelevant during recursive refinement of other elements.</td></tr>
    <tr><td class="paramname">isSnapPoint</td><td>(optional) An array of size NUM_VERTICES. If all entries are set to 'false' the behaviour is the same as if the array wasn't specified. If a corner of a quadrilateral is a snap-point and if edges of that quadrilateral are refined, then only new edges connected to the snap-point are introduced. Note that only special snap-point constellations are supported.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of entries written to newIndsOut or 0, if the refinement could not be performed. </dd></dl>

<p class="reference">References <a class="el" href="namespaceug_1_1tet__rules.html#a6b45d48a4172cf156cef7243778a6bc6">EDGE_FROM_VRTS</a>, <a class="el" href="namespaceug_1_1tet__rules.html#ae8e2e877c0514cc085b81223a498d4a7">EDGE_VRT_INDS</a>, <a class="el" href="namespaceug_1_1tet__rules.html#a5a9f42a950b7894b2e88547f24b31b06">FACE_CONTAINS_EDGE</a>, <a class="el" href="namespaceug_1_1tet__rules.html#a7dcf2bc421db4e4081fbac4f395c2d76">FACE_EDGE_INDS</a>, <a class="el" href="namespaceug_1_1tet__rules.html#afa3000c273e6c5fae6d85673cecd816d">FACE_FROM_EDGES</a>, <a class="el" href="namespaceug_1_1tet__rules.html#affc5181a744b23d51ce2e4685c23b66d">FACE_FROM_VRTS</a>, <a class="el" href="namespaceug_1_1tet__rules.html#a14f45507fa9f7e4c9b279316ca1fbe26">FACE_VRT_INDS</a>, <a class="el" href="namespaceug_1_1tet__rules.html#a5e3a3b2ebed66f8b89877adc044440d7">g_refinementRule</a>, <a class="el" href="namespaceug.html#a02785d5fd4cf2dd569d72cfac0197574a6b43178821260f0c2dac2ec60e233b40">ug::GOID_OCTAHEDRON</a>, <a class="el" href="namespaceug.html#a02785d5fd4cf2dd569d72cfac0197574a295753ffcd68033bb34442d7855b46e3">ug::GOID_PRISM</a>, <a class="el" href="namespaceug.html#a02785d5fd4cf2dd569d72cfac0197574a9c63711bcda15a049668e36a24b820fd">ug::GOID_PYRAMID</a>, <a class="el" href="namespaceug.html#a02785d5fd4cf2dd569d72cfac0197574a6bd5ada865770fc6a5ab730446242999">ug::GOID_TETRAHEDRON</a>, <a class="el" href="namespaceug_1_1tet__rules.html#a76aaa0d3db72d7532893684a989d38eead23b107a795aa68259651ae52dbf8dd1">HYBRID_TET_OCT</a>, <a class="el" href="namespaceug_1_1tet__rules.html#af10518055aa3246e6443fb9d6fdc558e">InverseTetTransform()</a>, <a class="el" href="namespaceug_1_1tet__rules.html#a7d25d541669f0ca827b0823588aea527">NUM_EDGES</a>, <a class="el" href="namespaceug_1_1tet__rules.html#add809a6e00e1b7639f9b9b69c6d45180">NUM_FACES</a>, <a class="el" href="namespaceug_1_1tet__rules.html#a566c1e0b22e0abe654049abf3249a483">NUM_VERTICES</a>, <a class="el" href="namespaceug_1_1tet__rules.html#aa0e6e7740342ff992d65e861a86a822c">OPPOSED_EDGE</a>, <a class="el" href="namespaceug_1_1shared__rules.html#a7ac2b679a4bd43aa6e8509c82ace36ca">ug::shared_rules::RecursiveRefine()</a>, <a class="el" href="namespaceug_1_1tet__rules.html#a76aaa0d3db72d7532893684a989d38eeab68d323147de038b82283f4a2e9be6d2">STANDARD</a>, <a class="el" href="namespaceug_1_1tet__rules.html#ac9b5fe75f9124a71640f054d68ca4e68">TetRotation()</a>, <a class="el" href="group__vectors.html#ga945c247d94409091fd35fdbbcb5032c2">ug::VecAdd()</a>, <a class="el" href="group__vectors.html#ga7da70ab2d2c942a82b582f1cc7888069">ug::VecDistanceSq()</a>, and <a class="el" href="group__vectors.html#gaa0cd3e6bb61c8e341541f8cf3065ec6d">ug::VecScale()</a>.</p>

</div>
</div>
<a id="a1dab2c9e3961c63fe112e40421c450e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dab2c9e3961c63fe112e40421c450e8">&#9670;&nbsp;</a></span>SetRefinementRule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ug::tet_rules::SetRefinementRule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceug_1_1tet__rules.html#a76aaa0d3db72d7532893684a989d38ee">GlobalRefinementRule</a>&#160;</td>
          <td class="paramname"><em>refRule</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceug_1_1tet__rules.html#a5e3a3b2ebed66f8b89877adc044440d7">g_refinementRule</a>.</p>

<p class="reference">Referenced by <a class="el" href="namespaceug.html#ad79f8fee3e2472773499c16a3d0f672f">ug::SetTetRefinementRule()</a>.</p>

</div>
</div>
<a id="ac9b5fe75f9124a71640f054d68ca4e68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9b5fe75f9124a71640f054d68ca4e68">&#9670;&nbsp;</a></span>TetRotation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ug::tet_rules::TetRotation </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vrtsInOut</em>[NUM_VERTICES], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fixedPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>steps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotates the given tetrahedron while keeping the specified point fixed. </p>
<p>The face opposed to the fixed point is rotated in counter-clockwise order when viewed from the fixed point. e.g. </p><div class="fragment"><div class="line"> <span class="keywordtype">int</span> vrts[] = {0, 1, 2, 3};</div>
<div class="line"> <a class="code" href="namespaceug_1_1tet__rules.html#ac9b5fe75f9124a71640f054d68ca4e68">TetRotation</a>(vrts, 3, 1);</div>
<div class="line"><span class="comment">// -&gt; vrts == {2, 0, 1, 3}</span></div>
<div class="ttc" id="anamespaceug_1_1tet__rules_html_ac9b5fe75f9124a71640f054d68ca4e68"><div class="ttname"><a href="namespaceug_1_1tet__rules.html#ac9b5fe75f9124a71640f054d68ca4e68">ug::tet_rules::TetRotation</a></div><div class="ttdeci">void TetRotation(int vrtsInOut[NUM_VERTICES], const int fixedPoint, const size_t steps)</div><div class="ttdoc">Rotates the given tetrahedron while keeping the specified point fixed.</div><div class="ttdef"><b>Definition:</b> tetrahedron_rules.cpp:66</div></div>
</div><!-- fragment --> 
<p class="reference">References <a class="el" href="namespaceug_1_1tet__rules.html#a14f45507fa9f7e4c9b279316ca1fbe26">FACE_VRT_INDS</a>, and <a class="el" href="namespaceug_1_1tet__rules.html#a1893cb1e2c7ba78c38d4c6c19a66fbc9">OPPOSED_OBJECT</a>.</p>

<p class="reference">Referenced by <a class="el" href="namespaceug_1_1tet__rules.html#a3c86c46dc04aa4188846ea7a88ece6cd">Refine()</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a6b45d48a4172cf156cef7243778a6bc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b45d48a4172cf156cef7243778a6bc6">&#9670;&nbsp;</a></span>EDGE_FROM_VRTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int ug::tet_rules::EDGE_FROM_VRTS[4][4]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {{-1, 0, 2, 3}, {0, -1, 1, 4},</div>
<div class="line">                   {2, 1, -1, 5}, {3, 4, 5, -1}}</div>
</div><!-- fragment -->
<p>Associates the index of the connecting edge with each tuple of vertices. </p>
<p>Use two vertex indices to index into this table to retrieve the index of their connecting edge. </p>

<p class="reference">Referenced by <a class="el" href="namespaceug_1_1tet__rules.html#a3c86c46dc04aa4188846ea7a88ece6cd">Refine()</a>.</p>

</div>
</div>
<a id="ae8e2e877c0514cc085b81223a498d4a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8e2e877c0514cc085b81223a498d4a7">&#9670;&nbsp;</a></span>EDGE_VRT_INDS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int ug::tet_rules::EDGE_VRT_INDS[][2]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= { {0, 1}, {1, 2}, {2, 0},</div>
<div class="line">                  {0, 3}, {1, 3}, {2,3}}</div>
</div><!-- fragment -->
<p>the local vertex indices of the given edge </p>

<p class="reference">Referenced by <a class="el" href="namespaceug.html#a969635ff6b3f4dd361abb8760fce1f2a">ug::IsSliver()</a>, and <a class="el" href="namespaceug_1_1tet__rules.html#a3c86c46dc04aa4188846ea7a88ece6cd">Refine()</a>.</p>

</div>
</div>
<a id="a5a9f42a950b7894b2e88547f24b31b06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a9f42a950b7894b2e88547f24b31b06">&#9670;&nbsp;</a></span>FACE_CONTAINS_EDGE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int ug::tet_rules::FACE_CONTAINS_EDGE[][6]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {{1, 1, 1, 0, 0, 0}, {0, 1, 0, 0, 1, 1},</div>
<div class="line">                   {0, 0, 1, 1, 0, 1}, {1, 0, 0, 1, 1, 0}}</div>
</div><!-- fragment -->
<p>tells whether the i-th face contains the j-th edge </p>

<p class="reference">Referenced by <a class="el" href="namespaceug_1_1tet__rules.html#a3c86c46dc04aa4188846ea7a88ece6cd">Refine()</a>.</p>

</div>
</div>
<a id="a7dcf2bc421db4e4081fbac4f395c2d76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dcf2bc421db4e4081fbac4f395c2d76">&#9670;&nbsp;</a></span>FACE_EDGE_INDS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int ug::tet_rules::FACE_EDGE_INDS[4][4]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=   {{0, 1, 2, -1}, {4, 5, 1, -1},</div>
<div class="line">                   {2, 5, 3, -1}, {3, 4, 0, -1}}</div>
</div><!-- fragment -->
<p>returns the j-th edge of the i-th face </p>

<p class="reference">Referenced by <a class="el" href="namespaceug_1_1tet__rules.html#a3c86c46dc04aa4188846ea7a88ece6cd">Refine()</a>.</p>

</div>
</div>
<a id="afa3000c273e6c5fae6d85673cecd816d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa3000c273e6c5fae6d85673cecd816d">&#9670;&nbsp;</a></span>FACE_FROM_EDGES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int ug::tet_rules::FACE_FROM_EDGES[][6]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {{0, 0, 0, 3, 3, -1}, {0, 0, 0, -1, 1, 1},</div>
<div class="line">                   {0, 0, 0, 2, -1, 2}, {3, -1, 2, 2, 3, 2},</div>
<div class="line">                   {3, 1, -1, 3, 1, 1}, {-1, 1, 2, 2, 1, 1}}</div>
</div><!-- fragment -->
<p>given two edges, the table returns the face, which contains both (or -1) </p>

<p class="reference">Referenced by <a class="el" href="namespaceug_1_1tet__rules.html#a3c86c46dc04aa4188846ea7a88ece6cd">Refine()</a>.</p>

</div>
</div>
<a id="affc5181a744b23d51ce2e4685c23b66d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affc5181a744b23d51ce2e4685c23b66d">&#9670;&nbsp;</a></span>FACE_FROM_VRTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int ug::tet_rules::FACE_FROM_VRTS[4][4][4]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">      {{{-1, -1, -1, -1}, {-1, -1, 0, 3}, {-1, 0, -1, 2}, {-1, 3, 2, -1}},</div>
<div class="line">       {{-1, -1, 0, 3}, {-1, -1, -1, -1}, {0, -1, -1, 1}, {3, -1, 1, -1}},</div>
<div class="line">       {{-1, 0, -1, 2}, {0, -1, -1, 1}, {-1, -1, -1, -1}, {2, 1, -1, -1}},</div>
<div class="line">       {{-1, 3, 2, -1}, {3, -1, 1, -1}, {2, 1, -1, -1}, {-1, -1, -1, -1}}}</div>
</div><!-- fragment -->
<p>Associates the index of the connecting face with each triple of vertices. </p>
<p>Use three vertex indices to index into this table to retrieve the index of their connecting face. </p>

<p class="reference">Referenced by <a class="el" href="namespaceug_1_1tet__rules.html#a3c86c46dc04aa4188846ea7a88ece6cd">Refine()</a>.</p>

</div>
</div>
<a id="a14f45507fa9f7e4c9b279316ca1fbe26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14f45507fa9f7e4c9b279316ca1fbe26">&#9670;&nbsp;</a></span>FACE_VRT_INDS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int ug::tet_rules::FACE_VRT_INDS[][4]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= { {0, 1, 2, -1}, {1, 3, 2, -1},</div>
<div class="line">                  {0, 2, 3, -1}, {0, 3, 1, -1}}</div>
</div><!-- fragment -->
<p>the local vertex indices of the given face </p>

<p class="reference">Referenced by <a class="el" href="namespaceug_1_1tet__rules.html#a3c86c46dc04aa4188846ea7a88ece6cd">Refine()</a>, and <a class="el" href="namespaceug_1_1tet__rules.html#ac9b5fe75f9124a71640f054d68ca4e68">TetRotation()</a>.</p>

</div>
</div>
<a id="a5e3a3b2ebed66f8b89877adc044440d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e3a3b2ebed66f8b89877adc044440d7">&#9670;&nbsp;</a></span>g_refinementRule</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceug_1_1tet__rules.html#a76aaa0d3db72d7532893684a989d38ee">GlobalRefinementRule</a> ug::tet_rules::g_refinementRule = <a class="el" href="namespaceug_1_1tet__rules.html#a76aaa0d3db72d7532893684a989d38eeab68d323147de038b82283f4a2e9be6d2">STANDARD</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>global refinement rule information switching between regular and subdivision volume refinement </p>

<p class="reference">Referenced by <a class="el" href="namespaceug_1_1tet__rules.html#a9f7c36db5d2ca9ff6d1bb3e3c4cca91d">GetRefinementRule()</a>, <a class="el" href="namespaceug_1_1tet__rules.html#a3c86c46dc04aa4188846ea7a88ece6cd">Refine()</a>, and <a class="el" href="namespaceug_1_1tet__rules.html#a1dab2c9e3961c63fe112e40421c450e8">SetRefinementRule()</a>.</p>

</div>
</div>
<a id="a786e7291877bee650bd399a6ca3bedfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a786e7291877bee650bd399a6ca3bedfb">&#9670;&nbsp;</a></span>MAX_NUM_INDS_OUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int ug::tet_rules::MAX_NUM_INDS_OUT = 64</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7d25d541669f0ca827b0823588aea527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d25d541669f0ca827b0823588aea527">&#9670;&nbsp;</a></span>NUM_EDGES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int ug::tet_rules::NUM_EDGES = 6</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="namespaceug.html#a969635ff6b3f4dd361abb8760fce1f2a">ug::IsSliver()</a>, and <a class="el" href="namespaceug_1_1tet__rules.html#a3c86c46dc04aa4188846ea7a88ece6cd">Refine()</a>.</p>

</div>
</div>
<a id="add809a6e00e1b7639f9b9b69c6d45180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add809a6e00e1b7639f9b9b69c6d45180">&#9670;&nbsp;</a></span>NUM_FACES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int ug::tet_rules::NUM_FACES = 4</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="namespaceug_1_1tet__rules.html#a3c86c46dc04aa4188846ea7a88ece6cd">Refine()</a>.</p>

</div>
</div>
<a id="a9fa5300aee3a16d3a3b2b5ba3223e110"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fa5300aee3a16d3a3b2b5ba3223e110">&#9670;&nbsp;</a></span>NUM_QUADS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int ug::tet_rules::NUM_QUADS = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaacbbc9d4a3f5ae297d00c26f27b29e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaacbbc9d4a3f5ae297d00c26f27b29e1">&#9670;&nbsp;</a></span>NUM_TRIS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int ug::tet_rules::NUM_TRIS = 4</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a566c1e0b22e0abe654049abf3249a483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a566c1e0b22e0abe654049abf3249a483">&#9670;&nbsp;</a></span>NUM_VERTICES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int ug::tet_rules::NUM_VERTICES = 4</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="namespaceug_1_1tet__rules.html#af10518055aa3246e6443fb9d6fdc558e">InverseTetTransform()</a>, and <a class="el" href="namespaceug_1_1tet__rules.html#a3c86c46dc04aa4188846ea7a88ece6cd">Refine()</a>.</p>

</div>
</div>
<a id="aa0e6e7740342ff992d65e861a86a822c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0e6e7740342ff992d65e861a86a822c">&#9670;&nbsp;</a></span>OPPOSED_EDGE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int ug::tet_rules::OPPOSED_EDGE[] = {5, 3, 4, 1, 2, 0}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>for each edge the local index of the opposed edge </p>

<p class="reference">Referenced by <a class="el" href="group__lib__grid__algorithms__volume__util.html#gaba653e9d1d95962e667b950c72f97803">ug::IntersectPlaneWithTetrahedron()</a>, <a class="el" href="namespaceug.html#a969635ff6b3f4dd361abb8760fce1f2a">ug::IsSliver()</a>, and <a class="el" href="namespaceug_1_1tet__rules.html#a3c86c46dc04aa4188846ea7a88ece6cd">Refine()</a>.</p>

</div>
</div>
<a id="a1893cb1e2c7ba78c38d4c6c19a66fbc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1893cb1e2c7ba78c38d4c6c19a66fbc9">&#9670;&nbsp;</a></span>OPPOSED_OBJECT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int ug::tet_rules::OPPOSED_OBJECT[][<a class="el" href="namespaceug_1_1tet__rules.html#a566c1e0b22e0abe654049abf3249a483">NUM_VERTICES</a>] = {{2, 1}, {2, 2}, {2, 3}, {2, 0}}</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>for each vertex, a pair containing the object type (0: vrt, 1: edge, 2: face) and an index into the associated array, which describe the object which lies on the opposite side of the tetrahedron, to a given vertex. </p>

<p class="reference">Referenced by <a class="el" href="namespaceug_1_1tet__rules.html#ac9b5fe75f9124a71640f054d68ca4e68">TetRotation()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceug.html">ug</a></li><li class="navelem"><a class="el" href="namespaceug_1_1tet__rules.html">tet_rules</a></li>
    <li class="footer">Generated on Mon May 29 2023 01:05:39 for ug4 by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
