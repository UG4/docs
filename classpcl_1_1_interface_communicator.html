<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ug4: pcl::InterfaceCommunicator&lt; TLayout &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ug4
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classpcl_1_1_interface_communicator.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classpcl_1_1_interface_communicator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pcl::InterfaceCommunicator&lt; TLayout &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__ugbase.html">ugbase</a> &raquo; <a class="el" href="group__pcl.html">PCL</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Performs communication between interfaces on different processes.  
 <a href="classpcl_1_1_interface_communicator.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="pcl__interface__communicator_8h_source.html">pcl_interface_communicator.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcl_1_1_interface_communicator_1_1_extractor_info.html">ExtractorInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">holds information that will be passed to the extract routines.  <a href="structpcl_1_1_interface_communicator_1_1_extractor_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a763a93b2c981e76de0c42734cf5f46fa"><td class="memItemLeft" align="right" valign="top">typedef Layout::Interface&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_interface_communicator.html#a763a93b2c981e76de0c42734cf5f46fa">Interface</a></td></tr>
<tr class="separator:a763a93b2c981e76de0c42734cf5f46fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48b44bded123e31aa9e69388d98890f7"><td class="memItemLeft" align="right" valign="top">typedef TLayout&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_interface_communicator.html#a48b44bded123e31aa9e69388d98890f7">Layout</a></td></tr>
<tr class="separator:a48b44bded123e31aa9e69388d98890f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5174a14aaebb5f425fe05639bee983db"><td class="memItemLeft" align="right" valign="top">typedef Layout::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_interface_communicator.html#a5174a14aaebb5f425fe05639bee983db">Type</a></td></tr>
<tr class="separator:a5174a14aaebb5f425fe05639bee983db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a86d3ffad4801623f1401b0d14ef5c1ae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_interface_communicator.html#a86d3ffad4801623f1401b0d14ef5c1ae">communicate</a> (int tag=749345)</td></tr>
<tr class="memdesc:a86d3ffad4801623f1401b0d14ef5c1ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">sends and receives the collected data.  <a href="classpcl_1_1_interface_communicator.html#a86d3ffad4801623f1401b0d14ef5c1ae">More...</a><br /></td></tr>
<tr class="separator:a86d3ffad4801623f1401b0d14ef5c1ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f1951cc76e5c5fe69ba885729d45fd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_interface_communicator.html#a21f1951cc76e5c5fe69ba885729d45fd">communicate_and_resume</a> (int tag=749345)</td></tr>
<tr class="memdesc:a21f1951cc76e5c5fe69ba885729d45fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">collects data and communicates it with other processes without waiting for receive  <a href="classpcl_1_1_interface_communicator.html#a21f1951cc76e5c5fe69ba885729d45fd">More...</a><br /></td></tr>
<tr class="separator:a21f1951cc76e5c5fe69ba885729d45fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96d887f599093ff95d918d25336041d8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_interface_communicator.html#a96d887f599093ff95d918d25336041d8">communication_debugging_enabled</a> ()</td></tr>
<tr class="memdesc:a96d887f599093ff95d918d25336041d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if communication debugging is enabled  <a href="classpcl_1_1_interface_communicator.html#a96d887f599093ff95d918d25336041d8">More...</a><br /></td></tr>
<tr class="separator:a96d887f599093ff95d918d25336041d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa042ee3884036a1c79a90c19d1506dec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_interface_communicator.html#aa042ee3884036a1c79a90c19d1506dec">disable_communication_debugging</a> ()</td></tr>
<tr class="memdesc:aa042ee3884036a1c79a90c19d1506dec"><td class="mdescLeft">&#160;</td><td class="mdescRight">disables debugging of communication  <a href="classpcl_1_1_interface_communicator.html#aa042ee3884036a1c79a90c19d1506dec">More...</a><br /></td></tr>
<tr class="separator:aa042ee3884036a1c79a90c19d1506dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac77c0a994099d3f7e87cb62d0ebf76bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_interface_communicator.html#ac77c0a994099d3f7e87cb62d0ebf76bd">enable_communication_debugging</a> (const <a class="el" href="classpcl_1_1_process_communicator.html">ProcessCommunicator</a> &amp;involvedProcs=<a class="el" href="classpcl_1_1_process_communicator.html">ProcessCommunicator</a>(<a class="el" href="group__pcl.html#ggaea36d0e20ff31324ba10643d4e939e29aa5c08b5ef97c6bd825508c3901b24c9f">PCD_WORLD</a>))</td></tr>
<tr class="memdesc:ac77c0a994099d3f7e87cb62d0ebf76bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">enables debugging of communication. This has a severe effect on performance!  <a href="classpcl_1_1_interface_communicator.html#ac77c0a994099d3f7e87cb62d0ebf76bd">More...</a><br /></td></tr>
<tr class="separator:ac77c0a994099d3f7e87cb62d0ebf76bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a910aa7ae6683014651abc4f49589e520"><td class="memTemplParams" colspan="2">template&lt;class TLayoutMap &gt; </td></tr>
<tr class="memitem:a910aa7ae6683014651abc4f49589e520"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpcl_1_1_interface_communicator.html#a910aa7ae6683014651abc4f49589e520">exchange_data</a> (const TLayoutMap &amp;layoutMap, const typename TLayoutMap::Key &amp;keyFrom, const typename TLayoutMap::Key &amp;keyTo, <a class="el" href="classpcl_1_1_i_communication_policy.html">ICommunicationPolicy</a>&lt; TLayout &gt; &amp;commPol)</td></tr>
<tr class="memdesc:a910aa7ae6683014651abc4f49589e520"><td class="mdescLeft">&#160;</td><td class="mdescRight">internally calls send_data and receive_data with the specified layouts.  <a href="classpcl_1_1_interface_communicator.html#a910aa7ae6683014651abc4f49589e520">More...</a><br /></td></tr>
<tr class="separator:a910aa7ae6683014651abc4f49589e520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80589cef362a0f04b4e9479139a5d80b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_interface_communicator.html#a80589cef362a0f04b4e9479139a5d80b">InterfaceCommunicator</a> ()</td></tr>
<tr class="separator:a80589cef362a0f04b4e9479139a5d80b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae607a780043dc7c071c297285860947d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_interface_communicator.html#ae607a780043dc7c071c297285860947d">receive_data</a> (const <a class="el" href="classpcl_1_1_interface_communicator.html#a48b44bded123e31aa9e69388d98890f7">Layout</a> &amp;layout, <a class="el" href="classpcl_1_1_i_communication_policy.html">ICommunicationPolicy</a>&lt; TLayout &gt; &amp;commPol)</td></tr>
<tr class="memdesc:ae607a780043dc7c071c297285860947d"><td class="mdescLeft">&#160;</td><td class="mdescRight">registers an communication-policy to receive data on communicate.  <a href="classpcl_1_1_interface_communicator.html#ae607a780043dc7c071c297285860947d">More...</a><br /></td></tr>
<tr class="separator:ae607a780043dc7c071c297285860947d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7cd1f6556736ad0a9f556546166c1bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_interface_communicator.html#aa7cd1f6556736ad0a9f556546166c1bd">receive_data</a> (int srcProc, const <a class="el" href="classpcl_1_1_interface_communicator.html#a763a93b2c981e76de0c42734cf5f46fa">Interface</a> &amp;interface, <a class="el" href="classpcl_1_1_i_communication_policy.html">ICommunicationPolicy</a>&lt; TLayout &gt; &amp;commPol)</td></tr>
<tr class="memdesc:aa7cd1f6556736ad0a9f556546166c1bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">registers a communication-policy to receive data on communicate.  <a href="classpcl_1_1_interface_communicator.html#aa7cd1f6556736ad0a9f556546166c1bd">More...</a><br /></td></tr>
<tr class="separator:aa7cd1f6556736ad0a9f556546166c1bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a609eeb8b8ffa34be134c7daf394bf3cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_interface_communicator.html#a609eeb8b8ffa34be134c7daf394bf3cb">receive_raw</a> (int srcProc, <a class="el" href="classug_1_1_binary_buffer.html">ug::BinaryBuffer</a> &amp;bufOut, int bufSize=-1)</td></tr>
<tr class="memdesc:a609eeb8b8ffa34be134c7daf394bf3cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">registers a binary-stream to receive data from a source-proc.  <a href="classpcl_1_1_interface_communicator.html#a609eeb8b8ffa34be134c7daf394bf3cb">More...</a><br /></td></tr>
<tr class="separator:a609eeb8b8ffa34be134c7daf394bf3cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcc256ac2bc92c51bd202f53defbcc22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_interface_communicator.html#afcc256ac2bc92c51bd202f53defbcc22">receive_raw</a> (int srcProc, void *bufOut, int bufSize)</td></tr>
<tr class="memdesc:afcc256ac2bc92c51bd202f53defbcc22"><td class="mdescLeft">&#160;</td><td class="mdescRight">registers a buffer to receive data from a source-proc.  <a href="classpcl_1_1_interface_communicator.html#afcc256ac2bc92c51bd202f53defbcc22">More...</a><br /></td></tr>
<tr class="separator:afcc256ac2bc92c51bd202f53defbcc22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb2e0439fb37f9e16d8ee1613115705b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_interface_communicator.html#abb2e0439fb37f9e16d8ee1613115705b">send_data</a> (const <a class="el" href="classpcl_1_1_interface_communicator.html#a48b44bded123e31aa9e69388d98890f7">Layout</a> &amp;layout, <a class="el" href="classpcl_1_1_i_communication_policy.html">ICommunicationPolicy</a>&lt; TLayout &gt; &amp;commPol)</td></tr>
<tr class="memdesc:abb2e0439fb37f9e16d8ee1613115705b"><td class="mdescLeft">&#160;</td><td class="mdescRight">collects data that will be send during communicate.  <a href="classpcl_1_1_interface_communicator.html#abb2e0439fb37f9e16d8ee1613115705b">More...</a><br /></td></tr>
<tr class="separator:abb2e0439fb37f9e16d8ee1613115705b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a870c5820b4a0762086775b389f7f6aa0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_interface_communicator.html#a870c5820b4a0762086775b389f7f6aa0">send_data</a> (int targetProc, const <a class="el" href="classpcl_1_1_interface_communicator.html#a763a93b2c981e76de0c42734cf5f46fa">Interface</a> &amp;interface, <a class="el" href="classpcl_1_1_i_communication_policy.html">ICommunicationPolicy</a>&lt; TLayout &gt; &amp;commPol)</td></tr>
<tr class="memdesc:a870c5820b4a0762086775b389f7f6aa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">collects data that will be send during communicate.  <a href="classpcl_1_1_interface_communicator.html#a870c5820b4a0762086775b389f7f6aa0">More...</a><br /></td></tr>
<tr class="separator:a870c5820b4a0762086775b389f7f6aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4767341a2f0c75547892ed120ec06525"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_interface_communicator.html#a4767341a2f0c75547892ed120ec06525">send_raw</a> (int targetProc, const void *pBuff, int bufferSize, bool bSizeKnownAtTarget=false)</td></tr>
<tr class="memdesc:a4767341a2f0c75547892ed120ec06525"><td class="mdescLeft">&#160;</td><td class="mdescRight">sends raw data to a target-proc.  <a href="classpcl_1_1_interface_communicator.html#a4767341a2f0c75547892ed120ec06525">More...</a><br /></td></tr>
<tr class="separator:a4767341a2f0c75547892ed120ec06525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a418906b8eefcb378ac2c1e2ed4286002"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_interface_communicator.html#a418906b8eefcb378ac2c1e2ed4286002">wait</a> ()</td></tr>
<tr class="memdesc:a418906b8eefcb378ac2c1e2ed4286002"><td class="mdescLeft">&#160;</td><td class="mdescRight">waits for the data communicated by <a class="el" href="classpcl_1_1_interface_communicator.html#a21f1951cc76e5c5fe69ba885729d45fd" title="collects data and communicates it with other processes without waiting for receive">communicate_and_resume()</a> and extracts it  <a href="classpcl_1_1_interface_communicator.html#a418906b8eefcb378ac2c1e2ed4286002">More...</a><br /></td></tr>
<tr class="separator:a418906b8eefcb378ac2c1e2ed4286002"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:afa2472a6ea08dc79acc0de3eacf250e1"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; int, <a class="el" href="classug_1_1_binary_buffer.html">ug::BinaryBuffer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_interface_communicator.html#afa2472a6ea08dc79acc0de3eacf250e1">BufferMap</a></td></tr>
<tr class="separator:afa2472a6ea08dc79acc0de3eacf250e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1af1eae202df3726a98e45e05e2c1e71"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classpcl_1_1_i_communication_policy.html">ICommunicationPolicy</a>&lt; <a class="el" href="classpcl_1_1_interface_communicator.html#a48b44bded123e31aa9e69388d98890f7">Layout</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_interface_communicator.html#a1af1eae202df3726a98e45e05e2c1e71">CommPol</a></td></tr>
<tr class="separator:a1af1eae202df3726a98e45e05e2c1e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b25ff9e5336e86da565902bb6d1665"><td class="memItemLeft" align="right" valign="top">typedef std::list&lt; <a class="el" href="structpcl_1_1_interface_communicator_1_1_extractor_info.html">ExtractorInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_interface_communicator.html#ae9b25ff9e5336e86da565902bb6d1665">ExtractorInfoList</a></td></tr>
<tr class="memdesc:ae9b25ff9e5336e86da565902bb6d1665"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list that holds information about extractors.  <a href="classpcl_1_1_interface_communicator.html#ae9b25ff9e5336e86da565902bb6d1665">More...</a><br /></td></tr>
<tr class="separator:ae9b25ff9e5336e86da565902bb6d1665"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a071fa6d259edc0427a3e574a4d307194"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_interface_communicator.html#a071fa6d259edc0427a3e574a4d307194">collect_layout_buffer_sizes</a> (const TLayout &amp;layout, <a class="el" href="classpcl_1_1_i_communication_policy.html">ICommunicationPolicy</a>&lt; TLayout &gt; &amp;commPol, std::map&lt; int, int &gt; *pMapBuffSizesOut, const <a class="el" href="classpcl_1_1layout__tags_1_1multi__level__layout__tag.html">layout_tags::multi_level_layout_tag</a> &amp;)</td></tr>
<tr class="memdesc:a071fa6d259edc0427a3e574a4d307194"><td class="mdescLeft">&#160;</td><td class="mdescRight">collects buffer sizes for a given layout and stores them in a map  <a href="classpcl_1_1_interface_communicator.html#a071fa6d259edc0427a3e574a4d307194">More...</a><br /></td></tr>
<tr class="separator:a071fa6d259edc0427a3e574a4d307194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef087d0a54ed121ed9d37cadc0740e69"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_interface_communicator.html#aef087d0a54ed121ed9d37cadc0740e69">collect_layout_buffer_sizes</a> (const TLayout &amp;layout, <a class="el" href="classpcl_1_1_i_communication_policy.html">ICommunicationPolicy</a>&lt; TLayout &gt; &amp;commPol, std::map&lt; int, int &gt; *pMapBuffSizesOut, const <a class="el" href="classpcl_1_1layout__tags_1_1single__level__layout__tag.html">layout_tags::single_level_layout_tag</a> &amp;)</td></tr>
<tr class="memdesc:aef087d0a54ed121ed9d37cadc0740e69"><td class="mdescLeft">&#160;</td><td class="mdescRight">collects buffer sizes for a given layout and stores them in a map  <a href="classpcl_1_1_interface_communicator.html#aef087d0a54ed121ed9d37cadc0740e69">More...</a><br /></td></tr>
<tr class="separator:aef087d0a54ed121ed9d37cadc0740e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f4459d2a5b9fbecbb0f4c00792f738b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_interface_communicator.html#a7f4459d2a5b9fbecbb0f4c00792f738b">extract_data</a> (const TLayout &amp;layout, <a class="el" href="classpcl_1_1_interface_communicator.html#afa2472a6ea08dc79acc0de3eacf250e1">BufferMap</a> &amp;bufMap, <a class="el" href="classpcl_1_1_interface_communicator.html#a1af1eae202df3726a98e45e05e2c1e71">CommPol</a> &amp;extractor)</td></tr>
<tr class="memdesc:a7f4459d2a5b9fbecbb0f4c00792f738b"><td class="mdescLeft">&#160;</td><td class="mdescRight">extract data from stream-pack  <a href="classpcl_1_1_interface_communicator.html#a7f4459d2a5b9fbecbb0f4c00792f738b">More...</a><br /></td></tr>
<tr class="separator:a7f4459d2a5b9fbecbb0f4c00792f738b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbc4e8b27b2c3ac94aad4650d29945ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_interface_communicator.html#acbc4e8b27b2c3ac94aad4650d29945ec">extract_data</a> (const TLayout &amp;layout, <a class="el" href="classpcl_1_1_interface_communicator.html#afa2472a6ea08dc79acc0de3eacf250e1">BufferMap</a> &amp;bufMap, <a class="el" href="classpcl_1_1_interface_communicator.html#a1af1eae202df3726a98e45e05e2c1e71">CommPol</a> &amp;extractor, const <a class="el" href="classpcl_1_1layout__tags_1_1multi__level__layout__tag.html">layout_tags::multi_level_layout_tag</a> &amp;)</td></tr>
<tr class="separator:acbc4e8b27b2c3ac94aad4650d29945ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04298c49f16b2426f0f869e8ac09583a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_interface_communicator.html#a04298c49f16b2426f0f869e8ac09583a">extract_data</a> (const TLayout &amp;layout, <a class="el" href="classpcl_1_1_interface_communicator.html#afa2472a6ea08dc79acc0de3eacf250e1">BufferMap</a> &amp;bufMap, <a class="el" href="classpcl_1_1_interface_communicator.html#a1af1eae202df3726a98e45e05e2c1e71">CommPol</a> &amp;extractor, const <a class="el" href="classpcl_1_1layout__tags_1_1single__level__layout__tag.html">layout_tags::single_level_layout_tag</a> &amp;)</td></tr>
<tr class="separator:a04298c49f16b2426f0f869e8ac09583a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe95f7714d60902e947d086f6aa0e8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_interface_communicator.html#a3fe95f7714d60902e947d086f6aa0e8e">prepare_receiver_buffer_map</a> (<a class="el" href="classpcl_1_1_interface_communicator.html#afa2472a6ea08dc79acc0de3eacf250e1">BufferMap</a> &amp;bufMap, std::set&lt; int &gt; &amp;curProcs, const TLayout &amp;layout)</td></tr>
<tr class="memdesc:a3fe95f7714d60902e947d086f6aa0e8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">prepare stream-pack-in  <a href="classpcl_1_1_interface_communicator.html#a3fe95f7714d60902e947d086f6aa0e8e">More...</a><br /></td></tr>
<tr class="separator:a3fe95f7714d60902e947d086f6aa0e8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73a54af0cea2ae7e1df76de57d35f065"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_interface_communicator.html#a73a54af0cea2ae7e1df76de57d35f065">prepare_receiver_buffer_map</a> (<a class="el" href="classpcl_1_1_interface_communicator.html#afa2472a6ea08dc79acc0de3eacf250e1">BufferMap</a> &amp;streamPack, std::set&lt; int &gt; &amp;curProcs, const TLayout &amp;layout, const <a class="el" href="classpcl_1_1layout__tags_1_1multi__level__layout__tag.html">layout_tags::multi_level_layout_tag</a> &amp;)</td></tr>
<tr class="memdesc:a73a54af0cea2ae7e1df76de57d35f065"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialization of stream-pack preparation for multi-level-layouts  <a href="classpcl_1_1_interface_communicator.html#a73a54af0cea2ae7e1df76de57d35f065">More...</a><br /></td></tr>
<tr class="separator:a73a54af0cea2ae7e1df76de57d35f065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d326372dda618a83311429c4a29e62a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_interface_communicator.html#a9d326372dda618a83311429c4a29e62a">prepare_receiver_buffer_map</a> (<a class="el" href="classpcl_1_1_interface_communicator.html#afa2472a6ea08dc79acc0de3eacf250e1">BufferMap</a> &amp;streamPack, std::set&lt; int &gt; &amp;curProcs, const TLayout &amp;layout, const <a class="el" href="classpcl_1_1layout__tags_1_1single__level__layout__tag.html">layout_tags::single_level_layout_tag</a> &amp;)</td></tr>
<tr class="memdesc:a9d326372dda618a83311429c4a29e62a"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialization of stream-pack preparation for single-level-layouts  <a href="classpcl_1_1_interface_communicator.html#a9d326372dda618a83311429c4a29e62a">More...</a><br /></td></tr>
<tr class="separator:a9d326372dda618a83311429c4a29e62a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad27b6e5b9fb0594995b71a4ef56d5348"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_interface_communicator.html#ad27b6e5b9fb0594995b71a4ef56d5348">send_data</a> (const <a class="el" href="classpcl_1_1_interface_communicator.html#a48b44bded123e31aa9e69388d98890f7">Layout</a> &amp;layout, <a class="el" href="classpcl_1_1_i_communication_policy.html">ICommunicationPolicy</a>&lt; TLayout &gt; &amp;commPol, const <a class="el" href="classpcl_1_1layout__tags_1_1multi__level__layout__tag.html">layout_tags::multi_level_layout_tag</a> &amp;)</td></tr>
<tr class="memdesc:ad27b6e5b9fb0594995b71a4ef56d5348"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper to collect data from multi-level-layouts <br  />
  <a href="classpcl_1_1_interface_communicator.html#ad27b6e5b9fb0594995b71a4ef56d5348">More...</a><br /></td></tr>
<tr class="separator:ad27b6e5b9fb0594995b71a4ef56d5348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0956b3c433264b20cb5fd31d616674b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_interface_communicator.html#a0956b3c433264b20cb5fd31d616674b8">send_data</a> (const <a class="el" href="classpcl_1_1_interface_communicator.html#a48b44bded123e31aa9e69388d98890f7">Layout</a> &amp;layout, <a class="el" href="classpcl_1_1_i_communication_policy.html">ICommunicationPolicy</a>&lt; TLayout &gt; &amp;commPol, const <a class="el" href="classpcl_1_1layout__tags_1_1single__level__layout__tag.html">layout_tags::single_level_layout_tag</a> &amp;)</td></tr>
<tr class="memdesc:a0956b3c433264b20cb5fd31d616674b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper to collect data from single-level-layouts  <a href="classpcl_1_1_interface_communicator.html#a0956b3c433264b20cb5fd31d616674b8">More...</a><br /></td></tr>
<tr class="separator:a0956b3c433264b20cb5fd31d616674b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a5cbdecc5f5a2a9c9c6034547fcde7c5f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_interface_communicator.html#a5cbdecc5f5a2a9c9c6034547fcde7c5f">m_bDebugCommunication</a></td></tr>
<tr class="memdesc:a5cbdecc5f5a2a9c9c6034547fcde7c5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if the communication shall be debugged.  <a href="classpcl_1_1_interface_communicator.html#a5cbdecc5f5a2a9c9c6034547fcde7c5f">More...</a><br /></td></tr>
<tr class="separator:a5cbdecc5f5a2a9c9c6034547fcde7c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6565f5074239d9fb348c07e2dd82f429"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_interface_communicator.html#a6565f5074239d9fb348c07e2dd82f429">m_bSendBuffersFixed</a></td></tr>
<tr class="memdesc:a6565f5074239d9fb348c07e2dd82f429"><td class="mdescLeft">&#160;</td><td class="mdescRight">holds info whether all send-buffers are of predetermined fixed size.  <a href="classpcl_1_1_interface_communicator.html#a6565f5074239d9fb348c07e2dd82f429">More...</a><br /></td></tr>
<tr class="separator:a6565f5074239d9fb348c07e2dd82f429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0212c21104dbd03759d8e117295940d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_interface_communicator.html#afa2472a6ea08dc79acc0de3eacf250e1">BufferMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_interface_communicator.html#a0212c21104dbd03759d8e117295940d9">m_bufMapIn</a></td></tr>
<tr class="memdesc:a0212c21104dbd03759d8e117295940d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">holds the buffers that are used to receive data  <a href="classpcl_1_1_interface_communicator.html#a0212c21104dbd03759d8e117295940d9">More...</a><br /></td></tr>
<tr class="separator:a0212c21104dbd03759d8e117295940d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d47852ec1cd0e0dfa73253a17e75af1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_interface_communicator.html#afa2472a6ea08dc79acc0de3eacf250e1">BufferMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_interface_communicator.html#a7d47852ec1cd0e0dfa73253a17e75af1">m_bufMapOut</a></td></tr>
<tr class="memdesc:a7d47852ec1cd0e0dfa73253a17e75af1"><td class="mdescLeft">&#160;</td><td class="mdescRight">holds the buffers that are used to send data  <a href="classpcl_1_1_interface_communicator.html#a7d47852ec1cd0e0dfa73253a17e75af1">More...</a><br /></td></tr>
<tr class="separator:a7d47852ec1cd0e0dfa73253a17e75af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acba2cafc1ebc91862f666db6ccf2c63c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_interface_communicator.html#acba2cafc1ebc91862f666db6ccf2c63c">m_curComTag</a></td></tr>
<tr class="memdesc:acba2cafc1ebc91862f666db6ccf2c63c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the tag for the currently performed communication.  <a href="classpcl_1_1_interface_communicator.html#acba2cafc1ebc91862f666db6ccf2c63c">More...</a><br /></td></tr>
<tr class="separator:acba2cafc1ebc91862f666db6ccf2c63c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9de358487721bf54afa1ee5982819958"><td class="memItemLeft" align="right" valign="top">std::set&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_interface_communicator.html#a9de358487721bf54afa1ee5982819958">m_curInProcs</a></td></tr>
<tr class="memdesc:a9de358487721bf54afa1ee5982819958"><td class="mdescLeft">&#160;</td><td class="mdescRight">stores in-procs for the next communication step  <a href="classpcl_1_1_interface_communicator.html#a9de358487721bf54afa1ee5982819958">More...</a><br /></td></tr>
<tr class="separator:a9de358487721bf54afa1ee5982819958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71562f592ae9583f524f8470f153d566"><td class="memItemLeft" align="right" valign="top">std::set&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_interface_communicator.html#a71562f592ae9583f524f8470f153d566">m_curOutProcs</a></td></tr>
<tr class="memdesc:a71562f592ae9583f524f8470f153d566"><td class="mdescLeft">&#160;</td><td class="mdescRight">stores out-procs for the next communication step  <a href="classpcl_1_1_interface_communicator.html#a71562f592ae9583f524f8470f153d566">More...</a><br /></td></tr>
<tr class="separator:a71562f592ae9583f524f8470f153d566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ff1ed82be90a56fa4520cbd90d481a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_process_communicator.html">ProcessCommunicator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_interface_communicator.html#a7ff1ed82be90a56fa4520cbd90d481a8">m_debugProcComm</a></td></tr>
<tr class="memdesc:a7ff1ed82be90a56fa4520cbd90d481a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This procComm holds the processes that shall participate during communication-debugging.  <a href="classpcl_1_1_interface_communicator.html#a7ff1ed82be90a56fa4520cbd90d481a8">More...</a><br /></td></tr>
<tr class="separator:a7ff1ed82be90a56fa4520cbd90d481a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68c2545238ae905542e14e89b27e2976"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcl_1_1_interface_communicator.html#ae9b25ff9e5336e86da565902bb6d1665">ExtractorInfoList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_interface_communicator.html#a68c2545238ae905542e14e89b27e2976">m_extractorInfos</a></td></tr>
<tr class="memdesc:a68c2545238ae905542e14e89b27e2976"><td class="mdescLeft">&#160;</td><td class="mdescRight">holds information about the extractors that are awaiting data.  <a href="classpcl_1_1_interface_communicator.html#a68c2545238ae905542e14e89b27e2976">More...</a><br /></td></tr>
<tr class="separator:a68c2545238ae905542e14e89b27e2976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a179ea5ca86ec1ca3bfa197b3b677b79f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; MPI_Request &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_interface_communicator.html#a179ea5ca86ec1ca3bfa197b3b677b79f">m_vReceiveRequests</a></td></tr>
<tr class="separator:a179ea5ca86ec1ca3bfa197b3b677b79f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa76857933e2b62b7afae7121ccfacfc3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; MPI_Request &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_interface_communicator.html#aa76857933e2b62b7afae7121ccfacfc3">m_vSendRequests</a></td></tr>
<tr class="memdesc:aa76857933e2b62b7afae7121ccfacfc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">used by communicate, communicate_and_resume and wait, to check whether communication is done.  <a href="classpcl_1_1_interface_communicator.html#aa76857933e2b62b7afae7121ccfacfc3">More...</a><br /></td></tr>
<tr class="separator:aa76857933e2b62b7afae7121ccfacfc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class TLayout&gt;<br />
class pcl::InterfaceCommunicator&lt; TLayout &gt;</h3>

<p>Performs communication between interfaces on different processes. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="afa2472a6ea08dc79acc0de3eacf250e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa2472a6ea08dc79acc0de3eacf250e1">&#9670;&nbsp;</a></span>BufferMap</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TLayout &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;int, <a class="el" href="classug_1_1_binary_buffer.html">ug::BinaryBuffer</a>&gt; <a class="el" href="classpcl_1_1_interface_communicator.html">pcl::InterfaceCommunicator</a>&lt; TLayout &gt;::<a class="el" href="classpcl_1_1_interface_communicator.html#afa2472a6ea08dc79acc0de3eacf250e1">BufferMap</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1af1eae202df3726a98e45e05e2c1e71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1af1eae202df3726a98e45e05e2c1e71">&#9670;&nbsp;</a></span>CommPol</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TLayout &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classpcl_1_1_i_communication_policy.html">ICommunicationPolicy</a>&lt;<a class="el" href="classpcl_1_1_interface_communicator.html#a48b44bded123e31aa9e69388d98890f7">Layout</a>&gt; <a class="el" href="classpcl_1_1_interface_communicator.html">pcl::InterfaceCommunicator</a>&lt; TLayout &gt;::<a class="el" href="classpcl_1_1_interface_communicator.html#a1af1eae202df3726a98e45e05e2c1e71">CommPol</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae9b25ff9e5336e86da565902bb6d1665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9b25ff9e5336e86da565902bb6d1665">&#9670;&nbsp;</a></span>ExtractorInfoList</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TLayout &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::list&lt;<a class="el" href="structpcl_1_1_interface_communicator_1_1_extractor_info.html">ExtractorInfo</a>&gt; <a class="el" href="classpcl_1_1_interface_communicator.html">pcl::InterfaceCommunicator</a>&lt; TLayout &gt;::<a class="el" href="classpcl_1_1_interface_communicator.html#ae9b25ff9e5336e86da565902bb6d1665">ExtractorInfoList</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A list that holds information about extractors. </p>

</div>
</div>
<a id="a763a93b2c981e76de0c42734cf5f46fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a763a93b2c981e76de0c42734cf5f46fa">&#9670;&nbsp;</a></span>Interface</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TLayout &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Layout::Interface <a class="el" href="classpcl_1_1_interface_communicator.html">pcl::InterfaceCommunicator</a>&lt; TLayout &gt;::<a class="el" href="classpcl_1_1_interface_communicator.html#a763a93b2c981e76de0c42734cf5f46fa">Interface</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a48b44bded123e31aa9e69388d98890f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48b44bded123e31aa9e69388d98890f7">&#9670;&nbsp;</a></span>Layout</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TLayout &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef TLayout <a class="el" href="classpcl_1_1_interface_communicator.html">pcl::InterfaceCommunicator</a>&lt; TLayout &gt;::<a class="el" href="classpcl_1_1_interface_communicator.html#a48b44bded123e31aa9e69388d98890f7">Layout</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5174a14aaebb5f425fe05639bee983db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5174a14aaebb5f425fe05639bee983db">&#9670;&nbsp;</a></span>Type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TLayout &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Layout::Type <a class="el" href="classpcl_1_1_interface_communicator.html">pcl::InterfaceCommunicator</a>&lt; TLayout &gt;::<a class="el" href="classpcl_1_1_interface_communicator.html#a5174a14aaebb5f425fe05639bee983db">Type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a80589cef362a0f04b4e9479139a5d80b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80589cef362a0f04b4e9479139a5d80b">&#9670;&nbsp;</a></span>InterfaceCommunicator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TLayout &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcl_1_1_interface_communicator.html">pcl::InterfaceCommunicator</a>&lt; TLayout &gt;::<a class="el" href="classpcl_1_1_interface_communicator.html">InterfaceCommunicator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a071fa6d259edc0427a3e574a4d307194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a071fa6d259edc0427a3e574a4d307194">&#9670;&nbsp;</a></span>collect_layout_buffer_sizes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TLayout &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpcl_1_1_interface_communicator.html">pcl::InterfaceCommunicator</a>&lt; TLayout &gt;::collect_layout_buffer_sizes </td>
          <td>(</td>
          <td class="paramtype">const TLayout &amp;&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_i_communication_policy.html">ICommunicationPolicy</a>&lt; TLayout &gt; &amp;&#160;</td>
          <td class="paramname"><em>commPol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; int, int &gt; *&#160;</td>
          <td class="paramname"><em>pMapBuffSizesOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1layout__tags_1_1multi__level__layout__tag.html">layout_tags::multi_level_layout_tag</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>collects buffer sizes for a given layout and stores them in a map </p>
<p>The given map holds pairs of procID, bufferSize If buffer-sizes can't be determined, false is returned. if pMmapBuffSizesOut == NULL, the method will simply determine whether all buffersizes can be calculated. </p>

</div>
</div>
<a id="aef087d0a54ed121ed9d37cadc0740e69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef087d0a54ed121ed9d37cadc0740e69">&#9670;&nbsp;</a></span>collect_layout_buffer_sizes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TLayout &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpcl_1_1_interface_communicator.html">pcl::InterfaceCommunicator</a>&lt; TLayout &gt;::collect_layout_buffer_sizes </td>
          <td>(</td>
          <td class="paramtype">const TLayout &amp;&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_i_communication_policy.html">ICommunicationPolicy</a>&lt; TLayout &gt; &amp;&#160;</td>
          <td class="paramname"><em>commPol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; int, int &gt; *&#160;</td>
          <td class="paramname"><em>pMapBuffSizesOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1layout__tags_1_1single__level__layout__tag.html">layout_tags::single_level_layout_tag</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>collects buffer sizes for a given layout and stores them in a map </p>
<p>The given map holds pairs of procID, bufferSize If buffer-sizes can't be determined, false is returned. if pMmapBuffSizesOut == NULL, the method will simply determine whether all buffersizes can be calculated. </p>

</div>
</div>
<a id="a86d3ffad4801623f1401b0d14ef5c1ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86d3ffad4801623f1401b0d14ef5c1ae">&#9670;&nbsp;</a></span>communicate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TLayout &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpcl_1_1_interface_communicator.html">pcl::InterfaceCommunicator</a>&lt; TLayout &gt;::communicate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tag</em> = <code>749345</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sends and receives the collected data. </p>
<p>The collected data will be send to the associated processes. The extract routines of the communication-policies which were registered through Communicator::receive_data will be called with the received data. After all received data is processed, the communication-policies are released. Make sure that you will keep your communication-policies in memory until this point. </p><dl class="section note"><dt>Note</dt><dd>Calling <a class="el" href="classpcl_1_1_interface_communicator.html#a86d3ffad4801623f1401b0d14ef5c1ae" title="sends and receives the collected data.">communicate()</a> is effectively the same as calling <a class="el" href="classpcl_1_1_interface_communicator.html#a21f1951cc76e5c5fe69ba885729d45fd" title="collects data and communicates it with other processes without waiting for receive">communicate_and_resume()</a> directly followed by <a class="el" href="classpcl_1_1_interface_communicator.html#a418906b8eefcb378ac2c1e2ed4286002" title="waits for the data communicated by communicate_and_resume() and extracts it">wait()</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>For internal communications the provided tag is used. The default value is fine in most cases and normally only has to be adjusted if one performs multiple communications at the same time (e.g. with different communicators). </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="namespaceug.html#abf8d23b0126010ea83a0260e6b23cbab">ug::AddConnectionsBetweenSlaves()</a>, <a class="el" href="namespaceug.html#a91093ee2bea136e72d3f5b3b88d2df0f">ug::AddExtraProcessEntriesToSubdomainLayout()</a>, <a class="el" href="group__lib__algebra__parallelization__util.html#gaecc2ecad8e08839d585ef1846667e44f">ug::AdditiveToConsistent()</a>, <a class="el" href="group__lib__algebra__parallelization__util.html#ga7cce17d66c105ef07b39137bcb130efa">ug::AdditiveToUnique()</a>, <a class="el" href="classug_1_1_surface_view.html#ade410254ea56d32dfa36d4fb6dd3e2b1">ug::SurfaceView::adjust_parallel_surface_states()</a>, <a class="el" href="namespaceug.html#a4743d926f2f2cd7db4fa299f0642b4c3">ug::ApplySmoothManifoldPosToTopLevelAveragingScheme()</a>, <a class="el" href="namespaceug.html#af2e53b962feba0e26502b06d7770eb81">ug::ApplySmoothManifoldPosToTopLevelButterflyScheme()</a>, <a class="el" href="namespaceug.html#a0c467abe9522c00d1bc3b8d5ca33a127">ug::ApplySmoothManifoldPosToTopLevelLoopScheme()</a>, <a class="el" href="namespaceug.html#afb771ee88536fc9837ee31184baa6324">ug::ApplySmoothVolumePosToTopLevel()</a>, <a class="el" href="namespaceug.html#ae9ecd0109e8c22c09d7ac46d33cbfce8">ug::AttachmentAllReduce()</a>, <a class="el" href="namespaceug.html#a407965f836f31b38e65bf51b67621c90">ug::BroadcastVectorFromOne()</a>, <a class="el" href="namespaceug.html#a273bb5f079aaccb4af3c3cf7cea8c4f4">ug::BuildDomainDecompositionLayouts()</a>, <a class="el" href="namespaceug.html#a207b43e7431f56746521de393a8f3fda">ug::BuildOneToManyLayout()</a>, <a class="el" href="namespaceug.html#ac45a89faef0c41d4b1829d0eebcde624">ug::CalculateNumElemsVertexAttachmentInTopLevel()</a>, <a class="el" href="namespaceug.html#a1f25691c0a4c39dcdf56e43bfc6a5b12">ug::CalculateNumManifoldEdgesVertexAttachmentInParentLevel()</a>, <a class="el" href="namespaceug.html#a4eb172228c22430098083cb4636199da">ug::CalculateNumManifoldFacesVertexAttachmentInTopLevel()</a>, <a class="el" href="classug_1_1_parallel_vector.html#a38358ca446e1842509a109f68c559b15">ug::ParallelVector&lt; TVector &gt;::check_storage_type()</a>, <a class="el" href="group__lib__grid__algorithms__log__util.html#gad5615b17dcc9ac76f1e82e2ac221e253">ug::CheckDistributedObjectConstraintTypes()</a>, <a class="el" href="classug_1_1_parallel_coloring.html#a2441e719844e4d0472ad8cd90519476b">ug::ParallelColoring::color()</a>, <a class="el" href="namespaceug.html#a575780c9cf1df85a47e6e11474da57e8">ug::CommunicateConnections()</a>, <a class="el" href="group__lib__algebra__parallelization__scheme.html#ga42fc159ebc025f6ed82a10d411e98980">ug::CommunicateOnInterfaces()</a>, <a class="el" href="group__lib__algebra__parallelization__util.html#gaae7502365fc2b2a3a1867c8e06324cd8">ug::CopyValues()</a>, <a class="el" href="group__lib__grid__parallelization.html#gaf7f72133e15d61d2159ea0123e9cb1d1">ug::CreateAndDistributeGlobalIDs()</a>, <a class="el" href="namespaceug.html#ae8e45115b6ad475d36b77748e5eb236e">ug::CreateSurfaceView()</a>, <a class="el" href="classug_1_1_com_pol___check_distributed_parent_states.html#a141ef27eb3d02e4f004fd4066efabd58">ug::ComPol_CheckDistributedParentStates&lt; TLayout &gt;::exchange_data()</a>, <a class="el" href="classug_1_1_com_pol___new_constrained_verticals.html#adec26837a64b7471c3f89e5f047c14ea">ug::ComPol_NewConstrainedVerticals&lt; TLayout &gt;::exchange_data()</a>, <a class="el" href="namespaceug.html#a5af96adea6fad9c993087e1827390670">ug::ExchangeAndAdjustSideErrors()</a>, <a class="el" href="namespaceug.html#a817bf4cc726c4dcdcbebec6386bc4421">ug::GatherVectorOnOne()</a>, <a class="el" href="classug_1_1_parallel_dual_graph.html#af3649ee9fabbfe0bd5106e418521b430">ug::ParallelDualGraph&lt; TGeomBaseObj, TIndexType, TConnectingObj &gt;::generate_graph()</a>, <a class="el" href="group__lib__algebra__parallelization__util.html#ga16d29da500a93fd47184d23442fcd5ed">ug::GenerateGlobalAlgebraIDs()</a>, <a class="el" href="namespaceug.html#a18b06f5618d879be669451b63ecedcbb">ug::GenerateGlobalConsecutiveIndices()</a>, <a class="el" href="classug_1_1_grid_function.html#a5f2d176dbd6f05c9e7b4f7a324d50e63">ug::GridFunction&lt; TDomain, TAlgebra &gt;::grid_changed_callback()</a>, <a class="el" href="classug_1_1_grid_function.html#a66ff1a49bcb52cd8322488c542a5dc00">ug::GridFunction&lt; TDomain, TAlgebra &gt;::grid_distribution_callback()</a>, <a class="el" href="namespaceug.html#a15d12b1d241b74a8af3f5f9e4c0989f6">ug::MarkForAdaption_GradientAverage()</a>, <a class="el" href="group__lib__algebra__parallelization__util.html#ga3da2c2603824b8c974b22d8b2f67275b">ug::MatAddSlaveRowsToMasterRowOverlap0()</a>, <a class="el" href="group__lib__algebra__parallelization__util.html#ga62ff21e4f3ecc0f4803e61725edd7fed">ug::MatMakeConsistentOverlap0()</a>, <a class="el" href="namespaceug.html#a1e2f0b6aac231e9a09bd4bde94e27096">ug::PartitionMultiGridLevel_ParmetisKway()</a>, <a class="el" href="namespaceug.html#a89527e1bbc6cc71eeafe0f1ca66f26c3">ug::ProjectHierarchyToSubdivisionLimit()</a>, <a class="el" href="classug_1_1_copy_attachment_handler.html#a8ed3409d95a2a9a0374d7601108d08b2">ug::CopyAttachmentHandler&lt; TElem, TAttachment &gt;::propagate_to_level()</a>, <a class="el" href="namespaceug.html#aa02c3e50e639d113542694d8ac23caf0">ug::ReceiveGlobalLayout()</a>, <a class="el" href="namespaceug.html#a8481589812a443f06888946f76ef7c17">ug::ReceiveMatrix()</a>, <a class="el" href="group__lib__algebra__parallelization__scheme.html#ga5aad3f86e8a9e2c70b0968a6d5124b78">ug::ReceiveOnInterfaces()</a>, <a class="el" href="namespaceug.html#a1d63d73632c3e0f086b875d823ed75a9">ug::SendGlobalLayout()</a>, <a class="el" href="namespaceug.html#adf469b73bc057daa50f80ffaa8152daa">ug::SendMatrix()</a>, <a class="el" href="group__lib__algebra__parallelization__scheme.html#ga18f49154cc1a2df44d3f3a05f7fe4553">ug::SendOnInterfaces()</a>, <a class="el" href="classug_1_1_side_and_elem_err_est_data.html#a32d684e870d1d42aa96d45c89c9c7938">ug::SideAndElemErrEstData&lt; TDomain &gt;::summarize_err_est_data()</a>, <a class="el" href="namespaceug.html#a509939970b3fe690765620053d3eb3fd">ug::SynchronizeDistInfos()</a>, <a class="el" href="group__pcl.html#ga08d85b285b592ad668f6446928aee4bc">pcl::TestLayoutIsDoubleEnded()</a>, <a class="el" href="group__pcl.html#gad1cd918b4420c242102c720802be33c9">pcl::TestSizeOfInterfacesInLayoutsMatch()</a>, <a class="el" href="group__lib__algebra__parallelization__util.html#ga41105b645bc5319e94c405fd4670b848">ug::UniqueToConsistent()</a>, <a class="el" href="namespaceug.html#af9cf5991c0e29731708ebb4ee2aa8167">ug::VecBroadcast()</a>, <a class="el" href="group__lib__algebra__parallelization__util.html#ga0b8fc9258a77acf678a224ad4366e65e">ug::VecCopy()</a>, <a class="el" href="namespaceug.html#a8a13837cfbbc85b3d1f571d091e28370">ug::VecGather()</a>, <a class="el" href="group__lib__algebra__parallelization__util.html#ga8263314ed9f4dc23d502a82e85038c78">ug::VecSubtractOneSlaveFromMaster()</a>, and <a class="el" href="group__lib__algebra__parallelization__util.html#ga7ec969fdb51f7876a953e584f640650d">ug::VecSubtractOnLayout()</a>.</p>

</div>
</div>
<a id="a21f1951cc76e5c5fe69ba885729d45fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21f1951cc76e5c5fe69ba885729d45fd">&#9670;&nbsp;</a></span>communicate_and_resume()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TLayout &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpcl_1_1_interface_communicator.html">pcl::InterfaceCommunicator</a>&lt; TLayout &gt;::communicate_and_resume </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tag</em> = <code>749345</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>collects data and communicates it with other processes without waiting for receive </p>
<p>Data will be collected from the communication-policies registered in send(...) and communicated to other processes. The method however won't wait until the data has arrived at its target processes and thus can't extract the received data. This has to be done manually by calling <a class="el" href="classpcl_1_1_interface_communicator.html#a418906b8eefcb378ac2c1e2ed4286002" title="waits for the data communicated by communicate_and_resume() and extracts it">wait()</a>. </p><dl class="section note"><dt>Note</dt><dd>Instead of using <a class="el" href="classpcl_1_1_interface_communicator.html#a21f1951cc76e5c5fe69ba885729d45fd" title="collects data and communicates it with other processes without waiting for receive">communicate_and_resume()</a> and <a class="el" href="classpcl_1_1_interface_communicator.html#a418906b8eefcb378ac2c1e2ed4286002" title="waits for the data communicated by communicate_and_resume() and extracts it">wait()</a> you could simply call communicate. Separating communication and wait however gives you the benefit of being able to continue with other calculations while communication is performed. </dd>
<dd>
A call to <a class="el" href="classpcl_1_1_interface_communicator.html#a21f1951cc76e5c5fe69ba885729d45fd" title="collects data and communicates it with other processes without waiting for receive">communicate_and_resume()</a> has to be followed by a call to <a class="el" href="classpcl_1_1_interface_communicator.html#a418906b8eefcb378ac2c1e2ed4286002" title="waits for the data communicated by communicate_and_resume() and extracts it">wait()</a>. You may not call <a class="el" href="classpcl_1_1_interface_communicator.html#a21f1951cc76e5c5fe69ba885729d45fd" title="collects data and communicates it with other processes without waiting for receive">communicate_and_resume()</a> twice on a single communicator without callin <a class="el" href="classpcl_1_1_interface_communicator.html#a418906b8eefcb378ac2c1e2ed4286002" title="waits for the data communicated by communicate_and_resume() and extracts it">wait()</a> in between. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>For internal communications the provided tag is used. The default value is fine in most cases and normally only has to be adjusted if one performs multiple communications at the same time (e.g. with different communicators). </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classug_1_1_binary_buffer.html#a1ff86563b8133d53b9293d4ec45484d6">ug::BinaryBuffer::buffer()</a>, <a class="el" href="classpcl_1_1_i_communication_policy.html#a7ebdb3f3261e62a2d3c282a642ebe916">pcl::ICommunicationPolicy&lt; TLayout &gt;::get_required_buffer_size()</a>, <a class="el" href="group__ugbase__common.html#gac6e4134e75d5415051a7c1b77a31b1cb">ug::LIB_PCL</a>, <a class="el" href="structpcl_1_1_interface_communicator_1_1_extractor_info.html#a3547ad8fd391c7c86b3d2f0c3059e525">pcl::InterfaceCommunicator&lt; TLayout &gt;::ExtractorInfo::m_extractor</a>, <a class="el" href="structpcl_1_1_interface_communicator_1_1_extractor_info.html#af29feb20912dc927b3fe0e074b561740">pcl::InterfaceCommunicator&lt; TLayout &gt;::ExtractorInfo::m_interface</a>, <a class="el" href="structpcl_1_1_interface_communicator_1_1_extractor_info.html#af7cb898c4a0bd102e37ea4c65f8bb97c">pcl::InterfaceCommunicator&lt; TLayout &gt;::ExtractorInfo::m_layout</a>, <a class="el" href="structpcl_1_1_interface_communicator_1_1_extractor_info.html#a5161d213723c7f627b70bb3b7377073b">pcl::InterfaceCommunicator&lt; TLayout &gt;::ExtractorInfo::m_rawSize</a>, <a class="el" href="structpcl_1_1_interface_communicator_1_1_extractor_info.html#ad136d3655b33978eeb272037615750fc">pcl::InterfaceCommunicator&lt; TLayout &gt;::ExtractorInfo::m_srcProc</a>, <a class="el" href="pcl__comm__world_8cpp.html#aeea8035bdcb7db449f8b4dcc738a8969">PCL_COMM_WORLD</a>, <a class="el" href="pcl__profiling_8h.html#a2ed0c268a471877fea32f207d9ad4908">PCL_PROFILE</a>, <a class="el" href="classug_1_1_binary_buffer.html#a4cbcf7f6b48ec299252eabb0c2910434">ug::BinaryBuffer::reserve()</a>, <a class="el" href="group__pcl.html#gabab6c185c6357a55c2c8ca70abed4d91">pcl::SendRecvBuffersMatch()</a>, <a class="el" href="group__pcl.html#ga5a0a84167219d54a9147374c16f5b128">pcl::SendRecvListsMatch()</a>, <a class="el" href="classug_1_1_binary_buffer.html#a39f333c178a905687b80654132f7e8ba">ug::BinaryBuffer::set_write_pos()</a>, <a class="el" href="group__ugbase__common.html#ga77cdb11fde48a872846a4dfd3aa9f4d2">UG_DLOG</a>, <a class="el" href="group__ugbase__common.html#ga849480b16e1d7c49266a92cd5db63942">UG_LOG</a>, <a class="el" href="group__ugbase__common.html#ga43687df88af405f6ac7058dd3639993d">UG_THROW</a>, <a class="el" href="group__pcl.html#ga65ebca4d784f8d31cbd34ee084257c85">pcl::Waitall()</a>, and <a class="el" href="classug_1_1_binary_buffer.html#acb333d1a7093992faa6b2c2a6dc6f046">ug::BinaryBuffer::write_pos()</a>.</p>

</div>
</div>
<a id="a96d887f599093ff95d918d25336041d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96d887f599093ff95d918d25336041d8">&#9670;&nbsp;</a></span>communication_debugging_enabled()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TLayout &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpcl_1_1_interface_communicator.html">pcl::InterfaceCommunicator</a>&lt; TLayout &gt;::communication_debugging_enabled</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns true if communication debugging is enabled </p>

</div>
</div>
<a id="aa042ee3884036a1c79a90c19d1506dec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa042ee3884036a1c79a90c19d1506dec">&#9670;&nbsp;</a></span>disable_communication_debugging()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TLayout &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_interface_communicator.html">pcl::InterfaceCommunicator</a>&lt; TLayout &gt;::disable_communication_debugging</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>disables debugging of communication </p>

</div>
</div>
<a id="ac77c0a994099d3f7e87cb62d0ebf76bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac77c0a994099d3f7e87cb62d0ebf76bd">&#9670;&nbsp;</a></span>enable_communication_debugging()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TLayout &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_interface_communicator.html">pcl::InterfaceCommunicator</a>&lt; TLayout &gt;::enable_communication_debugging </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_process_communicator.html">ProcessCommunicator</a> &amp;&#160;</td>
          <td class="paramname"><em>involvedProcs</em> = <code><a class="el" href="classpcl_1_1_process_communicator.html">ProcessCommunicator</a>(<a class="el" href="group__pcl.html#ggaea36d0e20ff31324ba10643d4e939e29aa5c08b5ef97c6bd825508c3901b24c9f">PCD_WORLD</a>)</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>enables debugging of communication. This has a severe effect on performance! </p>
<p>communication debugging will execute some code during <a class="el" href="classpcl_1_1_interface_communicator.html#a86d3ffad4801623f1401b0d14ef5c1ae" title="sends and receives the collected data.">communicate()</a>, which checks whether matching sends and receives have been scheduled with matching buffer sizes.</p>
<p>If not all processes participate during communication, you have to specify a process-communicator (involvedProcs), which includes all and only the procs, which will call communicate later on. If no process communicator is specified, then PCD_WORLD is used.</p>
<p>Note that communication debugging introduces additional communication which considerable slows down performance. You should only use it temporarily, if you encounter problems during communication.</p>
<p>Don't forget to call <a class="el" href="classpcl_1_1_interface_communicator.html#aa042ee3884036a1c79a90c19d1506dec" title="disables debugging of communication">disable_communication_debugging()</a>, when you're done with debugging. </p>

<p class="reference">References <a class="el" href="group__ugbase__common.html#ga849480b16e1d7c49266a92cd5db63942">UG_LOG</a>.</p>

</div>
</div>
<a id="a910aa7ae6683014651abc4f49589e520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a910aa7ae6683014651abc4f49589e520">&#9670;&nbsp;</a></span>exchange_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TLayout &gt; </div>
<div class="memtemplate">
template&lt;class TLayoutMap &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_interface_communicator.html">pcl::InterfaceCommunicator</a>&lt; TLayout &gt;::exchange_data </td>
          <td>(</td>
          <td class="paramtype">const TLayoutMap &amp;&#160;</td>
          <td class="paramname"><em>layoutMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename TLayoutMap::Key &amp;&#160;</td>
          <td class="paramname"><em>keyFrom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename TLayoutMap::Key &amp;&#160;</td>
          <td class="paramname"><em>keyTo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_i_communication_policy.html">ICommunicationPolicy</a>&lt; TLayout &gt; &amp;&#160;</td>
          <td class="paramname"><em>commPol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>internally calls send_data and receive_data with the specified layouts. </p>
<p>Note that data is not communicated until communicate has been called.</p>
<p>TLayout has to feature the following typedefs and methods: </p><div class="fragment"><div class="line"><span class="comment">// The type of the key with which a layout can be identified.</span></div>
<div class="line">Key</div>
<div class="line"> </div>
<div class="line"><span class="comment">// returns true, if the layout exists.</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> TType&gt;</div>
<div class="line"><span class="keywordtype">bool</span> has_layout(<span class="keyword">const</span> TLayoutMap::Key&amp; key);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// returns the layout that is associated with the given key.</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> TType&gt;</div>
<div class="line">TLayout&amp; get_layout(<span class="keyword">const</span> TLayoutMap::Key&amp; key);</div>
</div><!-- fragment --><p>The methods will only be called with type <a class="el" href="classpcl_1_1_interface_communicator.html#a5174a14aaebb5f425fe05639bee983db">InterfaceCommunicator::Type</a>.</p>
<p>This method is particularily useful if you categorize layouts on a process. If you separate your layouts into master and slave layouts, you could use this method e.g. to copy data from all master-layouts to all slave-layouts of a type with a single call. </p>

<p class="reference">Referenced by <a class="el" href="classug_1_1_surface_view.html#ade410254ea56d32dfa36d4fb6dd3e2b1">ug::SurfaceView::adjust_parallel_surface_states()</a>, <a class="el" href="namespaceug.html#a4743d926f2f2cd7db4fa299f0642b4c3">ug::ApplySmoothManifoldPosToTopLevelAveragingScheme()</a>, <a class="el" href="namespaceug.html#af2e53b962feba0e26502b06d7770eb81">ug::ApplySmoothManifoldPosToTopLevelButterflyScheme()</a>, <a class="el" href="namespaceug.html#a0c467abe9522c00d1bc3b8d5ca33a127">ug::ApplySmoothManifoldPosToTopLevelLoopScheme()</a>, <a class="el" href="namespaceug.html#afb771ee88536fc9837ee31184baa6324">ug::ApplySmoothVolumePosToTopLevel()</a>, <a class="el" href="namespaceug.html#ae9ecd0109e8c22c09d7ac46d33cbfce8">ug::AttachmentAllReduce()</a>, <a class="el" href="namespaceug.html#ac45a89faef0c41d4b1829d0eebcde624">ug::CalculateNumElemsVertexAttachmentInTopLevel()</a>, <a class="el" href="namespaceug.html#a1f25691c0a4c39dcdf56e43bfc6a5b12">ug::CalculateNumManifoldEdgesVertexAttachmentInParentLevel()</a>, <a class="el" href="namespaceug.html#a4eb172228c22430098083cb4636199da">ug::CalculateNumManifoldFacesVertexAttachmentInTopLevel()</a>, <a class="el" href="group__lib__grid__algorithms__log__util.html#gad5615b17dcc9ac76f1e82e2ac221e253">ug::CheckDistributedObjectConstraintTypes()</a>, <a class="el" href="group__lib__grid__parallelization.html#gaf7f72133e15d61d2159ea0123e9cb1d1">ug::CreateAndDistributeGlobalIDs()</a>, <a class="el" href="classug_1_1_com_pol___new_constrained_verticals.html#adec26837a64b7471c3f89e5f047c14ea">ug::ComPol_NewConstrainedVerticals&lt; TLayout &gt;::exchange_data()</a>, <a class="el" href="namespaceug.html#a5af96adea6fad9c993087e1827390670">ug::ExchangeAndAdjustSideErrors()</a>, <a class="el" href="classug_1_1_grid_function.html#a5f2d176dbd6f05c9e7b4f7a324d50e63">ug::GridFunction&lt; TDomain, TAlgebra &gt;::grid_changed_callback()</a>, <a class="el" href="classug_1_1_grid_function.html#a66ff1a49bcb52cd8322488c542a5dc00">ug::GridFunction&lt; TDomain, TAlgebra &gt;::grid_distribution_callback()</a>, <a class="el" href="namespaceug.html#a15d12b1d241b74a8af3f5f9e4c0989f6">ug::MarkForAdaption_GradientAverage()</a>, <a class="el" href="namespaceug.html#a89527e1bbc6cc71eeafe0f1ca66f26c3">ug::ProjectHierarchyToSubdivisionLimit()</a>, <a class="el" href="classug_1_1_copy_attachment_handler.html#a8ed3409d95a2a9a0374d7601108d08b2">ug::CopyAttachmentHandler&lt; TElem, TAttachment &gt;::propagate_to_level()</a>, <a class="el" href="classug_1_1_side_and_elem_err_est_data.html#a32d684e870d1d42aa96d45c89c9c7938">ug::SideAndElemErrEstData&lt; TDomain &gt;::summarize_err_est_data()</a>, and <a class="el" href="namespaceug.html#a509939970b3fe690765620053d3eb3fd">ug::SynchronizeDistInfos()</a>.</p>

</div>
</div>
<a id="a7f4459d2a5b9fbecbb0f4c00792f738b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f4459d2a5b9fbecbb0f4c00792f738b">&#9670;&nbsp;</a></span>extract_data() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TLayout &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_interface_communicator.html">pcl::InterfaceCommunicator</a>&lt; TLayout &gt;::extract_data </td>
          <td>(</td>
          <td class="paramtype">const TLayout &amp;&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_interface_communicator.html#afa2472a6ea08dc79acc0de3eacf250e1">BufferMap</a> &amp;&#160;</td>
          <td class="paramname"><em>bufMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_interface_communicator.html#a1af1eae202df3726a98e45e05e2c1e71">CommPol</a> &amp;&#160;</td>
          <td class="paramname"><em>extractor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>extract data from stream-pack </p>

<p class="reference">References <a class="el" href="pcl__profiling_8h.html#ac5cb0fae94673273f14b6e70c782cba8">PCL_PROFILE_FUNC</a>.</p>

</div>
</div>
<a id="acbc4e8b27b2c3ac94aad4650d29945ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbc4e8b27b2c3ac94aad4650d29945ec">&#9670;&nbsp;</a></span>extract_data() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TLayout &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_interface_communicator.html">pcl::InterfaceCommunicator</a>&lt; TLayout &gt;::extract_data </td>
          <td>(</td>
          <td class="paramtype">const TLayout &amp;&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_interface_communicator.html#afa2472a6ea08dc79acc0de3eacf250e1">BufferMap</a> &amp;&#160;</td>
          <td class="paramname"><em>bufMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_interface_communicator.html#a1af1eae202df3726a98e45e05e2c1e71">CommPol</a> &amp;&#160;</td>
          <td class="paramname"><em>extractor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1layout__tags_1_1multi__level__layout__tag.html">layout_tags::multi_level_layout_tag</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="classpcl_1_1_i_communication_policy.html#aff3da4776f049ce25d62195372d386a2">pcl::ICommunicationPolicy&lt; TLayout &gt;::begin_layout_extraction()</a>, <a class="el" href="classpcl_1_1_i_communication_policy.html#ac97e59662228504ffe50f5fa9d7632fa">pcl::ICommunicationPolicy&lt; TLayout &gt;::begin_level_extraction()</a>, <a class="el" href="classpcl_1_1_i_communication_policy.html#ade38fba8154f808c527e61707c256a97">pcl::ICommunicationPolicy&lt; TLayout &gt;::end_layout_extraction()</a>, and <a class="el" href="classpcl_1_1_i_communication_policy.html#a9e3ac435c42e66a366c7c854a030df41">pcl::ICommunicationPolicy&lt; TLayout &gt;::extract()</a>.</p>

</div>
</div>
<a id="a04298c49f16b2426f0f869e8ac09583a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04298c49f16b2426f0f869e8ac09583a">&#9670;&nbsp;</a></span>extract_data() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TLayout &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_interface_communicator.html">pcl::InterfaceCommunicator</a>&lt; TLayout &gt;::extract_data </td>
          <td>(</td>
          <td class="paramtype">const TLayout &amp;&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_interface_communicator.html#afa2472a6ea08dc79acc0de3eacf250e1">BufferMap</a> &amp;&#160;</td>
          <td class="paramname"><em>bufMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_interface_communicator.html#a1af1eae202df3726a98e45e05e2c1e71">CommPol</a> &amp;&#160;</td>
          <td class="paramname"><em>extractor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1layout__tags_1_1single__level__layout__tag.html">layout_tags::single_level_layout_tag</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="classpcl_1_1_i_communication_policy.html#aff3da4776f049ce25d62195372d386a2">pcl::ICommunicationPolicy&lt; TLayout &gt;::begin_layout_extraction()</a>, <a class="el" href="classpcl_1_1_i_communication_policy.html#ac97e59662228504ffe50f5fa9d7632fa">pcl::ICommunicationPolicy&lt; TLayout &gt;::begin_level_extraction()</a>, <a class="el" href="classpcl_1_1_i_communication_policy.html#ade38fba8154f808c527e61707c256a97">pcl::ICommunicationPolicy&lt; TLayout &gt;::end_layout_extraction()</a>, and <a class="el" href="classpcl_1_1_i_communication_policy.html#a9e3ac435c42e66a366c7c854a030df41">pcl::ICommunicationPolicy&lt; TLayout &gt;::extract()</a>.</p>

</div>
</div>
<a id="a3fe95f7714d60902e947d086f6aa0e8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fe95f7714d60902e947d086f6aa0e8e">&#9670;&nbsp;</a></span>prepare_receiver_buffer_map() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TLayout &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_interface_communicator.html">pcl::InterfaceCommunicator</a>&lt; TLayout &gt;::prepare_receiver_buffer_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_interface_communicator.html#afa2472a6ea08dc79acc0de3eacf250e1">BufferMap</a> &amp;&#160;</td>
          <td class="paramname"><em>bufMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>curProcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TLayout &amp;&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>prepare stream-pack-in </p>

</div>
</div>
<a id="a73a54af0cea2ae7e1df76de57d35f065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73a54af0cea2ae7e1df76de57d35f065">&#9670;&nbsp;</a></span>prepare_receiver_buffer_map() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TLayout &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_interface_communicator.html">pcl::InterfaceCommunicator</a>&lt; TLayout &gt;::prepare_receiver_buffer_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_interface_communicator.html#afa2472a6ea08dc79acc0de3eacf250e1">BufferMap</a> &amp;&#160;</td>
          <td class="paramname"><em>streamPack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>curProcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TLayout &amp;&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1layout__tags_1_1multi__level__layout__tag.html">layout_tags::multi_level_layout_tag</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>specialization of stream-pack preparation for multi-level-layouts </p>

</div>
</div>
<a id="a9d326372dda618a83311429c4a29e62a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d326372dda618a83311429c4a29e62a">&#9670;&nbsp;</a></span>prepare_receiver_buffer_map() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TLayout &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_interface_communicator.html">pcl::InterfaceCommunicator</a>&lt; TLayout &gt;::prepare_receiver_buffer_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_interface_communicator.html#afa2472a6ea08dc79acc0de3eacf250e1">BufferMap</a> &amp;&#160;</td>
          <td class="paramname"><em>streamPack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>curProcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TLayout &amp;&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1layout__tags_1_1single__level__layout__tag.html">layout_tags::single_level_layout_tag</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>specialization of stream-pack preparation for single-level-layouts </p>

</div>
</div>
<a id="ae607a780043dc7c071c297285860947d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae607a780043dc7c071c297285860947d">&#9670;&nbsp;</a></span>receive_data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TLayout &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_interface_communicator.html">pcl::InterfaceCommunicator</a>&lt; TLayout &gt;::receive_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_interface_communicator.html#a48b44bded123e31aa9e69388d98890f7">Layout</a> &amp;&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_i_communication_policy.html">ICommunicationPolicy</a>&lt; TLayout &gt; &amp;&#160;</td>
          <td class="paramname"><em>commPol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>registers an communication-policy to receive data on communicate. </p>
<p>Receives have to be registered before communicate is executed. make sure that your instance of the communication-policy exists until communicate has benn executed. </p>

</div>
</div>
<a id="aa7cd1f6556736ad0a9f556546166c1bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7cd1f6556736ad0a9f556546166c1bd">&#9670;&nbsp;</a></span>receive_data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TLayout &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_interface_communicator.html">pcl::InterfaceCommunicator</a>&lt; TLayout &gt;::receive_data </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcProc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_interface_communicator.html#a763a93b2c981e76de0c42734cf5f46fa">Interface</a> &amp;&#160;</td>
          <td class="paramname"><em>interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_i_communication_policy.html">ICommunicationPolicy</a>&lt; TLayout &gt; &amp;&#160;</td>
          <td class="paramname"><em>commPol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>registers a communication-policy to receive data on communicate. </p>
<p>Receives have to be registered before communicate is executed. make sure that your instance of the communication-policy exists until communicate has benn executed. </p>

<p class="reference">Referenced by <a class="el" href="namespaceug.html#a91093ee2bea136e72d3f5b3b88d2df0f">ug::AddExtraProcessEntriesToSubdomainLayout()</a>, <a class="el" href="group__lib__algebra__parallelization__util.html#gaecc2ecad8e08839d585ef1846667e44f">ug::AdditiveToConsistent()</a>, <a class="el" href="group__lib__algebra__parallelization__util.html#ga7cce17d66c105ef07b39137bcb130efa">ug::AdditiveToUnique()</a>, <a class="el" href="namespaceug.html#a407965f836f31b38e65bf51b67621c90">ug::BroadcastVectorFromOne()</a>, <a class="el" href="namespaceug.html#a273bb5f079aaccb4af3c3cf7cea8c4f4">ug::BuildDomainDecompositionLayouts()</a>, <a class="el" href="namespaceug.html#a207b43e7431f56746521de393a8f3fda">ug::BuildOneToManyLayout()</a>, <a class="el" href="classug_1_1_parallel_vector.html#a38358ca446e1842509a109f68c559b15">ug::ParallelVector&lt; TVector &gt;::check_storage_type()</a>, <a class="el" href="namespaceug.html#a575780c9cf1df85a47e6e11474da57e8">ug::CommunicateConnections()</a>, <a class="el" href="group__lib__algebra__parallelization__util.html#gaae7502365fc2b2a3a1867c8e06324cd8">ug::CopyValues()</a>, <a class="el" href="namespaceug.html#ae8e45115b6ad475d36b77748e5eb236e">ug::CreateSurfaceView()</a>, <a class="el" href="classug_1_1_com_pol___check_distributed_parent_states.html#a141ef27eb3d02e4f004fd4066efabd58">ug::ComPol_CheckDistributedParentStates&lt; TLayout &gt;::exchange_data()</a>, <a class="el" href="namespaceug.html#a817bf4cc726c4dcdcbebec6386bc4421">ug::GatherVectorOnOne()</a>, <a class="el" href="classug_1_1_parallel_dual_graph.html#af3649ee9fabbfe0bd5106e418521b430">ug::ParallelDualGraph&lt; TGeomBaseObj, TIndexType, TConnectingObj &gt;::generate_graph()</a>, <a class="el" href="group__lib__algebra__parallelization__util.html#ga16d29da500a93fd47184d23442fcd5ed">ug::GenerateGlobalAlgebraIDs()</a>, <a class="el" href="namespaceug.html#a18b06f5618d879be669451b63ecedcbb">ug::GenerateGlobalConsecutiveIndices()</a>, <a class="el" href="group__lib__algebra__parallelization__util.html#ga3da2c2603824b8c974b22d8b2f67275b">ug::MatAddSlaveRowsToMasterRowOverlap0()</a>, <a class="el" href="group__lib__algebra__parallelization__util.html#ga62ff21e4f3ecc0f4803e61725edd7fed">ug::MatMakeConsistentOverlap0()</a>, <a class="el" href="namespaceug.html#a1e2f0b6aac231e9a09bd4bde94e27096">ug::PartitionMultiGridLevel_ParmetisKway()</a>, <a class="el" href="group__lib__algebra__parallelization__util.html#ga41105b645bc5319e94c405fd4670b848">ug::UniqueToConsistent()</a>, <a class="el" href="namespaceug.html#af9cf5991c0e29731708ebb4ee2aa8167">ug::VecBroadcast()</a>, <a class="el" href="group__lib__algebra__parallelization__util.html#ga0b8fc9258a77acf678a224ad4366e65e">ug::VecCopy()</a>, <a class="el" href="namespaceug.html#a8a13837cfbbc85b3d1f571d091e28370">ug::VecGather()</a>, <a class="el" href="group__lib__algebra__parallelization__util.html#ga8263314ed9f4dc23d502a82e85038c78">ug::VecSubtractOneSlaveFromMaster()</a>, and <a class="el" href="group__lib__algebra__parallelization__util.html#ga7ec969fdb51f7876a953e584f640650d">ug::VecSubtractOnLayout()</a>.</p>

</div>
</div>
<a id="a609eeb8b8ffa34be134c7daf394bf3cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a609eeb8b8ffa34be134c7daf394bf3cb">&#9670;&nbsp;</a></span>receive_raw() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TLayout &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_interface_communicator.html">pcl::InterfaceCommunicator</a>&lt; TLayout &gt;::receive_raw </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcProc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_binary_buffer.html">ug::BinaryBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>bufOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bufSize</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>registers a binary-stream to receive data from a source-proc. </p>
<p>Receives data that has been sent with send_raw. If send_raw was called with bSizeKnownAtTarget == true, an exact bufferSize has to be specified. If bSizeKnownAtTarget was set to false, bufferSize has to be set to -1.</p>
<p>Make sure that binStreamOut exists until communicate has been executed.</p>
<p>Please note that this method should only be used if custom data should be send in a block with data that is communicated through interfaces, since an additional copy-operation has to be performed. If you're only interested in sending raw data, you should take a look into pcl::ProcessCommunicator::receive. </p>

<p class="reference">Referenced by <a class="el" href="namespaceug.html#abf8d23b0126010ea83a0260e6b23cbab">ug::AddConnectionsBetweenSlaves()</a>, <a class="el" href="classug_1_1_parallel_coloring.html#a2441e719844e4d0472ad8cd90519476b">ug::ParallelColoring::color()</a>, <a class="el" href="group__lib__algebra__parallelization__scheme.html#ga42fc159ebc025f6ed82a10d411e98980">ug::CommunicateOnInterfaces()</a>, <a class="el" href="classug_1_1_new_layout_creator.html#ab5eb042ae239d7e1b0843c98fb1e44ec">ug::NewLayoutCreator::issue()</a>, <a class="el" href="classug_1_1_parallel_nodes.html#a2433ee50a6a91566a5be7488bc0f962a">ug::ParallelNodes::issue()</a>, <a class="el" href="classug_1_1_row_sending_scheme.html#aba407c07ce27c97c5b960688762229f0">ug::RowSendingScheme&lt; matrix_type &gt;::issue_send()</a>, <a class="el" href="namespaceug.html#aa02c3e50e639d113542694d8ac23caf0">ug::ReceiveGlobalLayout()</a>, <a class="el" href="namespaceug.html#a8481589812a443f06888946f76ef7c17">ug::ReceiveMatrix()</a>, <a class="el" href="group__lib__algebra__parallelization__scheme.html#ga5aad3f86e8a9e2c70b0968a6d5124b78">ug::ReceiveOnInterfaces()</a>, <a class="el" href="group__pcl.html#ga08d85b285b592ad668f6446928aee4bc">pcl::TestLayoutIsDoubleEnded()</a>, and <a class="el" href="group__pcl.html#gad1cd918b4420c242102c720802be33c9">pcl::TestSizeOfInterfacesInLayoutsMatch()</a>.</p>

</div>
</div>
<a id="afcc256ac2bc92c51bd202f53defbcc22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcc256ac2bc92c51bd202f53defbcc22">&#9670;&nbsp;</a></span>receive_raw() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TLayout &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_interface_communicator.html">pcl::InterfaceCommunicator</a>&lt; TLayout &gt;::receive_raw </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcProc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>bufOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bufSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>registers a buffer to receive data from a source-proc. </p>
<p>Receives data that has been sent with send_raw. This method may only be used if send_raw was called with bSizeKnownAtTarget == true. Call receive_raw with a binary- stream instead, if buffer-sizes are not known.</p>
<p>Make sure that the buffer points to valid memory until communicate has been executed.</p>
<p>Please note that this method should only be used if custom data should be send in a block with data that is communicated through interfaces, since an additional copy-operation has to be performed. If you're only interested in sending raw data, you should take a look into pcl::ProcessCommunicator::receive. </p>

</div>
</div>
<a id="abb2e0439fb37f9e16d8ee1613115705b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb2e0439fb37f9e16d8ee1613115705b">&#9670;&nbsp;</a></span>send_data() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TLayout &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_interface_communicator.html">pcl::InterfaceCommunicator</a>&lt; TLayout &gt;::send_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_interface_communicator.html#a48b44bded123e31aa9e69388d98890f7">Layout</a> &amp;&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_i_communication_policy.html">ICommunicationPolicy</a>&lt; TLayout &gt; &amp;&#160;</td>
          <td class="paramname"><em>commPol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>collects data that will be send during communicate. </p>
<p>Calls <a class="el" href="classpcl_1_1_i_communication_policy.html#aaefb079f94ea045d63456b45ee7e1a4c" title="should write data which is associated with the interface elements to the buffer.">ICommunicationPolicy&lt;TLayout&gt;::collect</a> with the specified layout and the binary stream that is associated with the layouts target processes. Note that data will not be send until communicate has been called. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classpcl_1_1_interface_communicator.html#aa7cd1f6556736ad0a9f556546166c1bd" title="registers a communication-policy to receive data on communicate.">receive_data</a>, <a class="el" href="classpcl_1_1_interface_communicator.html#a910aa7ae6683014651abc4f49589e520" title="internally calls send_data and receive_data with the specified layouts.">exchange_data</a> </dd></dl>

<p class="reference">References <a class="el" href="pcl__profiling_8h.html#a2ed0c268a471877fea32f207d9ad4908">PCL_PROFILE</a>.</p>

</div>
</div>
<a id="ad27b6e5b9fb0594995b71a4ef56d5348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad27b6e5b9fb0594995b71a4ef56d5348">&#9670;&nbsp;</a></span>send_data() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TLayout &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_interface_communicator.html">pcl::InterfaceCommunicator</a>&lt; TLayout &gt;::send_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_interface_communicator.html#a48b44bded123e31aa9e69388d98890f7">Layout</a> &amp;&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_i_communication_policy.html">ICommunicationPolicy</a>&lt; TLayout &gt; &amp;&#160;</td>
          <td class="paramname"><em>commPol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1layout__tags_1_1multi__level__layout__tag.html">layout_tags::multi_level_layout_tag</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>helper to collect data from multi-level-layouts <br  />
 </p>

</div>
</div>
<a id="a0956b3c433264b20cb5fd31d616674b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0956b3c433264b20cb5fd31d616674b8">&#9670;&nbsp;</a></span>send_data() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TLayout &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_interface_communicator.html">pcl::InterfaceCommunicator</a>&lt; TLayout &gt;::send_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_interface_communicator.html#a48b44bded123e31aa9e69388d98890f7">Layout</a> &amp;&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_i_communication_policy.html">ICommunicationPolicy</a>&lt; TLayout &gt; &amp;&#160;</td>
          <td class="paramname"><em>commPol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1layout__tags_1_1single__level__layout__tag.html">layout_tags::single_level_layout_tag</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>helper to collect data from single-level-layouts </p>

</div>
</div>
<a id="a870c5820b4a0762086775b389f7f6aa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a870c5820b4a0762086775b389f7f6aa0">&#9670;&nbsp;</a></span>send_data() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TLayout &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_interface_communicator.html">pcl::InterfaceCommunicator</a>&lt; TLayout &gt;::send_data </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>targetProc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_interface_communicator.html#a763a93b2c981e76de0c42734cf5f46fa">Interface</a> &amp;&#160;</td>
          <td class="paramname"><em>interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_i_communication_policy.html">ICommunicationPolicy</a>&lt; TLayout &gt; &amp;&#160;</td>
          <td class="paramname"><em>commPol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>collects data that will be send during communicate. </p>
<p>Calls <a class="el" href="classpcl_1_1_i_communication_policy.html#aaefb079f94ea045d63456b45ee7e1a4c" title="should write data which is associated with the interface elements to the buffer.">ICommunicationPolicy&lt;TLayout&gt;::collect</a> with the specified interface and the binary stream that is associated with the specified target process. Note that data will not be send until communicate has been called. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classpcl_1_1_interface_communicator.html#aa7cd1f6556736ad0a9f556546166c1bd" title="registers a communication-policy to receive data on communicate.">receive_data</a>, <a class="el" href="classpcl_1_1_interface_communicator.html#a910aa7ae6683014651abc4f49589e520" title="internally calls send_data and receive_data with the specified layouts.">exchange_data</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="namespaceug.html#a91093ee2bea136e72d3f5b3b88d2df0f">ug::AddExtraProcessEntriesToSubdomainLayout()</a>, <a class="el" href="group__lib__algebra__parallelization__util.html#gaecc2ecad8e08839d585ef1846667e44f">ug::AdditiveToConsistent()</a>, <a class="el" href="group__lib__algebra__parallelization__util.html#ga7cce17d66c105ef07b39137bcb130efa">ug::AdditiveToUnique()</a>, <a class="el" href="namespaceug.html#a407965f836f31b38e65bf51b67621c90">ug::BroadcastVectorFromOne()</a>, <a class="el" href="namespaceug.html#a273bb5f079aaccb4af3c3cf7cea8c4f4">ug::BuildDomainDecompositionLayouts()</a>, <a class="el" href="namespaceug.html#a207b43e7431f56746521de393a8f3fda">ug::BuildOneToManyLayout()</a>, <a class="el" href="classug_1_1_parallel_vector.html#a38358ca446e1842509a109f68c559b15">ug::ParallelVector&lt; TVector &gt;::check_storage_type()</a>, <a class="el" href="namespaceug.html#a575780c9cf1df85a47e6e11474da57e8">ug::CommunicateConnections()</a>, <a class="el" href="group__lib__algebra__parallelization__util.html#gaae7502365fc2b2a3a1867c8e06324cd8">ug::CopyValues()</a>, <a class="el" href="namespaceug.html#ae8e45115b6ad475d36b77748e5eb236e">ug::CreateSurfaceView()</a>, <a class="el" href="classug_1_1_com_pol___check_distributed_parent_states.html#a141ef27eb3d02e4f004fd4066efabd58">ug::ComPol_CheckDistributedParentStates&lt; TLayout &gt;::exchange_data()</a>, <a class="el" href="namespaceug.html#a817bf4cc726c4dcdcbebec6386bc4421">ug::GatherVectorOnOne()</a>, <a class="el" href="classug_1_1_parallel_dual_graph.html#af3649ee9fabbfe0bd5106e418521b430">ug::ParallelDualGraph&lt; TGeomBaseObj, TIndexType, TConnectingObj &gt;::generate_graph()</a>, <a class="el" href="group__lib__algebra__parallelization__util.html#ga16d29da500a93fd47184d23442fcd5ed">ug::GenerateGlobalAlgebraIDs()</a>, <a class="el" href="namespaceug.html#a18b06f5618d879be669451b63ecedcbb">ug::GenerateGlobalConsecutiveIndices()</a>, <a class="el" href="group__lib__algebra__parallelization__util.html#ga3da2c2603824b8c974b22d8b2f67275b">ug::MatAddSlaveRowsToMasterRowOverlap0()</a>, <a class="el" href="group__lib__algebra__parallelization__util.html#ga62ff21e4f3ecc0f4803e61725edd7fed">ug::MatMakeConsistentOverlap0()</a>, <a class="el" href="namespaceug.html#a1e2f0b6aac231e9a09bd4bde94e27096">ug::PartitionMultiGridLevel_ParmetisKway()</a>, <a class="el" href="group__lib__algebra__parallelization__util.html#ga41105b645bc5319e94c405fd4670b848">ug::UniqueToConsistent()</a>, <a class="el" href="namespaceug.html#af9cf5991c0e29731708ebb4ee2aa8167">ug::VecBroadcast()</a>, <a class="el" href="group__lib__algebra__parallelization__util.html#ga0b8fc9258a77acf678a224ad4366e65e">ug::VecCopy()</a>, <a class="el" href="namespaceug.html#a8a13837cfbbc85b3d1f571d091e28370">ug::VecGather()</a>, <a class="el" href="group__lib__algebra__parallelization__util.html#ga8263314ed9f4dc23d502a82e85038c78">ug::VecSubtractOneSlaveFromMaster()</a>, and <a class="el" href="group__lib__algebra__parallelization__util.html#ga7ec969fdb51f7876a953e584f640650d">ug::VecSubtractOnLayout()</a>.</p>

</div>
</div>
<a id="a4767341a2f0c75547892ed120ec06525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4767341a2f0c75547892ed120ec06525">&#9670;&nbsp;</a></span>send_raw()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TLayout &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_interface_communicator.html">pcl::InterfaceCommunicator</a>&lt; TLayout &gt;::send_raw </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>targetProc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pBuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bSizeKnownAtTarget</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sends raw data to a target-proc. </p>
<p>Shedules the data in pBuff to be sent to the target-proc pBuff can be reused or cleared directly after the call returns.</p>
<p>Data sent with this method can be received using receive_raw.</p>
<p>Please note that this method should only be used if custom data should be send in a block with data that is communicated through interfaces, since an additional copy-operation at the target process has to be performed. If you're only interested in sending raw data, you should take a look into pcl::ProcessCommunicator::send. </p>

<p class="reference">References <a class="el" href="group__pcl.html#ga7a09a2eab069305ca735847eed023d2f">pcl::NumProcs()</a>, and <a class="el" href="classug_1_1_binary_buffer.html#aeb08df178483b53bf1069f985c08e245">ug::BinaryBuffer::write()</a>.</p>

<p class="reference">Referenced by <a class="el" href="namespaceug.html#abf8d23b0126010ea83a0260e6b23cbab">ug::AddConnectionsBetweenSlaves()</a>, <a class="el" href="classug_1_1_parallel_coloring.html#a2441e719844e4d0472ad8cd90519476b">ug::ParallelColoring::color()</a>, <a class="el" href="group__lib__algebra__parallelization__scheme.html#ga42fc159ebc025f6ed82a10d411e98980">ug::CommunicateOnInterfaces()</a>, <a class="el" href="classug_1_1_new_layout_creator.html#ab5eb042ae239d7e1b0843c98fb1e44ec">ug::NewLayoutCreator::issue()</a>, <a class="el" href="classug_1_1_parallel_nodes.html#a2433ee50a6a91566a5be7488bc0f962a">ug::ParallelNodes::issue()</a>, <a class="el" href="classug_1_1_row_sending_scheme.html#aba407c07ce27c97c5b960688762229f0">ug::RowSendingScheme&lt; matrix_type &gt;::issue_send()</a>, <a class="el" href="namespaceug.html#a1d63d73632c3e0f086b875d823ed75a9">ug::SendGlobalLayout()</a>, <a class="el" href="namespaceug.html#adf469b73bc057daa50f80ffaa8152daa">ug::SendMatrix()</a>, <a class="el" href="group__lib__algebra__parallelization__scheme.html#ga18f49154cc1a2df44d3f3a05f7fe4553">ug::SendOnInterfaces()</a>, <a class="el" href="group__pcl.html#ga08d85b285b592ad668f6446928aee4bc">pcl::TestLayoutIsDoubleEnded()</a>, and <a class="el" href="group__pcl.html#gad1cd918b4420c242102c720802be33c9">pcl::TestSizeOfInterfacesInLayoutsMatch()</a>.</p>

</div>
</div>
<a id="a418906b8eefcb378ac2c1e2ed4286002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a418906b8eefcb378ac2c1e2ed4286002">&#9670;&nbsp;</a></span>wait()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TLayout &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1_interface_communicator.html">pcl::InterfaceCommunicator</a>&lt; TLayout &gt;::wait</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>waits for the data communicated by <a class="el" href="classpcl_1_1_interface_communicator.html#a21f1951cc76e5c5fe69ba885729d45fd" title="collects data and communicates it with other processes without waiting for receive">communicate_and_resume()</a> and extracts it </p>
<p>The extract routines of the communication-policies which were registered through Communicator::receive_data will be called with the received data. After all received data is processed, the communication-policies are released. Make sure that you will keep your communication-policies in memory until this point. </p>

<p class="reference">References <a class="el" href="classug_1_1_binary_buffer.html#a1ff86563b8133d53b9293d4ec45484d6">ug::BinaryBuffer::buffer()</a>, <a class="el" href="classug_1_1_binary_buffer.html#ac696123c44faa5d08b4ee340311c25f0">ug::BinaryBuffer::clear()</a>, <a class="el" href="classpcl_1_1_i_communication_policy.html#a9e3ac435c42e66a366c7c854a030df41">pcl::ICommunicationPolicy&lt; TLayout &gt;::extract()</a>, <a class="el" href="structpcl_1_1_interface_communicator_1_1_extractor_info.html#aff926eb39404571e0347d482be86b699">pcl::InterfaceCommunicator&lt; TLayout &gt;::ExtractorInfo::m_binBuffer</a>, <a class="el" href="structpcl_1_1_interface_communicator_1_1_extractor_info.html#a16b97dddd6f855799974cb3a46857d87">pcl::InterfaceCommunicator&lt; TLayout &gt;::ExtractorInfo::m_buffer</a>, <a class="el" href="structpcl_1_1_interface_communicator_1_1_extractor_info.html#a3547ad8fd391c7c86b3d2f0c3059e525">pcl::InterfaceCommunicator&lt; TLayout &gt;::ExtractorInfo::m_extractor</a>, <a class="el" href="structpcl_1_1_interface_communicator_1_1_extractor_info.html#af29feb20912dc927b3fe0e074b561740">pcl::InterfaceCommunicator&lt; TLayout &gt;::ExtractorInfo::m_interface</a>, <a class="el" href="structpcl_1_1_interface_communicator_1_1_extractor_info.html#af7cb898c4a0bd102e37ea4c65f8bb97c">pcl::InterfaceCommunicator&lt; TLayout &gt;::ExtractorInfo::m_layout</a>, <a class="el" href="structpcl_1_1_interface_communicator_1_1_extractor_info.html#a5161d213723c7f627b70bb3b7377073b">pcl::InterfaceCommunicator&lt; TLayout &gt;::ExtractorInfo::m_rawSize</a>, <a class="el" href="structpcl_1_1_interface_communicator_1_1_extractor_info.html#ad136d3655b33978eeb272037615750fc">pcl::InterfaceCommunicator&lt; TLayout &gt;::ExtractorInfo::m_srcProc</a>, <a class="el" href="pcl__profiling_8h.html#a2ed0c268a471877fea32f207d9ad4908">PCL_PROFILE</a>, <a class="el" href="classug_1_1_binary_buffer.html#a607b2b38de6c95289186b9b80ebe45ab">ug::BinaryBuffer::read()</a>, <a class="el" href="classug_1_1_binary_buffer.html#a4cbcf7f6b48ec299252eabb0c2910434">ug::BinaryBuffer::reserve()</a>, <a class="el" href="classug_1_1_binary_buffer.html#a39f333c178a905687b80654132f7e8ba">ug::BinaryBuffer::set_write_pos()</a>, and <a class="el" href="group__pcl.html#ga65ebca4d784f8d31cbd34ee084257c85">pcl::Waitall()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a5cbdecc5f5a2a9c9c6034547fcde7c5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cbdecc5f5a2a9c9c6034547fcde7c5f">&#9670;&nbsp;</a></span>m_bDebugCommunication</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TLayout &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpcl_1_1_interface_communicator.html">pcl::InterfaceCommunicator</a>&lt; TLayout &gt;::m_bDebugCommunication</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>true if the communication shall be debugged. </p>

</div>
</div>
<a id="a6565f5074239d9fb348c07e2dd82f429"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6565f5074239d9fb348c07e2dd82f429">&#9670;&nbsp;</a></span>m_bSendBuffersFixed</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TLayout &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpcl_1_1_interface_communicator.html">pcl::InterfaceCommunicator</a>&lt; TLayout &gt;::m_bSendBuffersFixed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>holds info whether all send-buffers are of predetermined fixed size. </p>
<p>reset to true after each communication-step. </p>

</div>
</div>
<a id="a0212c21104dbd03759d8e117295940d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0212c21104dbd03759d8e117295940d9">&#9670;&nbsp;</a></span>m_bufMapIn</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TLayout &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcl_1_1_interface_communicator.html#afa2472a6ea08dc79acc0de3eacf250e1">BufferMap</a> <a class="el" href="classpcl_1_1_interface_communicator.html">pcl::InterfaceCommunicator</a>&lt; TLayout &gt;::m_bufMapIn</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>holds the buffers that are used to receive data </p>

</div>
</div>
<a id="a7d47852ec1cd0e0dfa73253a17e75af1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d47852ec1cd0e0dfa73253a17e75af1">&#9670;&nbsp;</a></span>m_bufMapOut</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TLayout &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcl_1_1_interface_communicator.html#afa2472a6ea08dc79acc0de3eacf250e1">BufferMap</a> <a class="el" href="classpcl_1_1_interface_communicator.html">pcl::InterfaceCommunicator</a>&lt; TLayout &gt;::m_bufMapOut</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>holds the buffers that are used to send data </p>

</div>
</div>
<a id="acba2cafc1ebc91862f666db6ccf2c63c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acba2cafc1ebc91862f666db6ccf2c63c">&#9670;&nbsp;</a></span>m_curComTag</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TLayout &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classpcl_1_1_interface_communicator.html">pcl::InterfaceCommunicator</a>&lt; TLayout &gt;::m_curComTag</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the tag for the currently performed communication. </p>
<p>Set to -1 if no communication is currently performed. </p>

</div>
</div>
<a id="a9de358487721bf54afa1ee5982819958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9de358487721bf54afa1ee5982819958">&#9670;&nbsp;</a></span>m_curInProcs</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TLayout &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;int&gt; <a class="el" href="classpcl_1_1_interface_communicator.html">pcl::InterfaceCommunicator</a>&lt; TLayout &gt;::m_curInProcs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>stores in-procs for the next communication step </p>

</div>
</div>
<a id="a71562f592ae9583f524f8470f153d566"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71562f592ae9583f524f8470f153d566">&#9670;&nbsp;</a></span>m_curOutProcs</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TLayout &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;int&gt; <a class="el" href="classpcl_1_1_interface_communicator.html">pcl::InterfaceCommunicator</a>&lt; TLayout &gt;::m_curOutProcs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>stores out-procs for the next communication step </p>

</div>
</div>
<a id="a7ff1ed82be90a56fa4520cbd90d481a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ff1ed82be90a56fa4520cbd90d481a8">&#9670;&nbsp;</a></span>m_debugProcComm</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TLayout &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcl_1_1_process_communicator.html">ProcessCommunicator</a> <a class="el" href="classpcl_1_1_interface_communicator.html">pcl::InterfaceCommunicator</a>&lt; TLayout &gt;::m_debugProcComm</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This procComm holds the processes that shall participate during communication-debugging. </p>

</div>
</div>
<a id="a68c2545238ae905542e14e89b27e2976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68c2545238ae905542e14e89b27e2976">&#9670;&nbsp;</a></span>m_extractorInfos</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TLayout &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcl_1_1_interface_communicator.html#ae9b25ff9e5336e86da565902bb6d1665">ExtractorInfoList</a> <a class="el" href="classpcl_1_1_interface_communicator.html">pcl::InterfaceCommunicator</a>&lt; TLayout &gt;::m_extractorInfos</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>holds information about the extractors that are awaiting data. </p>

</div>
</div>
<a id="a179ea5ca86ec1ca3bfa197b3b677b79f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a179ea5ca86ec1ca3bfa197b3b677b79f">&#9670;&nbsp;</a></span>m_vReceiveRequests</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TLayout &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;MPI_Request&gt; <a class="el" href="classpcl_1_1_interface_communicator.html">pcl::InterfaceCommunicator</a>&lt; TLayout &gt;::m_vReceiveRequests</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa76857933e2b62b7afae7121ccfacfc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa76857933e2b62b7afae7121ccfacfc3">&#9670;&nbsp;</a></span>m_vSendRequests</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TLayout &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;MPI_Request&gt; <a class="el" href="classpcl_1_1_interface_communicator.html">pcl::InterfaceCommunicator</a>&lt; TLayout &gt;::m_vSendRequests</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>used by communicate, communicate_and_resume and wait, to check whether communication is done. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>ugbase/pcl/<a class="el" href="pcl__interface__communicator_8h_source.html">pcl_interface_communicator.h</a></li>
<li>ugbase/pcl/<a class="el" href="pcl__interface__communicator__impl_8hpp_source.html">pcl_interface_communicator_impl.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacepcl.html">pcl</a></li><li class="navelem"><a class="el" href="classpcl_1_1_interface_communicator.html">InterfaceCommunicator</a></li>
    <li class="footer">Generated on Mon Jul 24 2023 01:07:57 for ug4 by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
