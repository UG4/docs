<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ug4: ug::LinearIteratorProduct&lt; X, Y &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ug4
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classug_1_1_linear_iterator_product.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classug_1_1_linear_iterator_product-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ug::LinearIteratorProduct&lt; X, Y &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="iterator__product_8h_source.html">iterator_product.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for ug::LinearIteratorProduct&lt; X, Y &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="classug_1_1_linear_iterator_product.png" usemap="#ug::LinearIteratorProduct_3C_20X_2C_20Y_20_3E_map" alt=""/>
  <map id="ug::LinearIteratorProduct_3C_20X_2C_20Y_20_3E_map" name="ug::LinearIteratorProduct_3C_20X_2C_20Y_20_3E_map">
<area href="classug_1_1_combined_linear_iterator.html" alt="ug::CombinedLinearIterator&lt; X, Y &gt;" shape="rect" coords="0,56,215,80"/>
<area href="classug_1_1_i_linear_iterator.html" alt="ug::ILinearIterator&lt; X, Y &gt;" shape="rect" coords="0,0,215,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a02e86028179573d375634aea90584070"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_linear_iterator_product.html#a02e86028179573d375634aea90584070">apply</a> (Y &amp;c, const X &amp;d)</td></tr>
<tr class="memdesc:a02e86028179573d375634aea90584070"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute new correction c = B*d  <a href="classug_1_1_linear_iterator_product.html#a02e86028179573d375634aea90584070">More...</a><br /></td></tr>
<tr class="separator:a02e86028179573d375634aea90584070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5847b63a9e2be7aa55ed40ddfed5a3bf"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_linear_iterator_product.html#a5847b63a9e2be7aa55ed40ddfed5a3bf">apply_update_defect</a> (Y &amp;c, X &amp;d)</td></tr>
<tr class="memdesc:a5847b63a9e2be7aa55ed40ddfed5a3bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute new correction c = B*d and update defect d := d - A*c  <a href="classug_1_1_linear_iterator_product.html#a5847b63a9e2be7aa55ed40ddfed5a3bf">More...</a><br /></td></tr>
<tr class="separator:a5847b63a9e2be7aa55ed40ddfed5a3bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3b1a2fa3e0618496b037370d3b8acaa"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="classug_1_1_i_linear_iterator.html">ILinearIterator</a>&lt; X, Y &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_linear_iterator_product.html#af3b1a2fa3e0618496b037370d3b8acaa">clone</a> ()</td></tr>
<tr class="memdesc:af3b1a2fa3e0618496b037370d3b8acaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">clone  <a href="classug_1_1_linear_iterator_product.html#af3b1a2fa3e0618496b037370d3b8acaa">More...</a><br /></td></tr>
<tr class="separator:af3b1a2fa3e0618496b037370d3b8acaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9598cd49ec7a121743a9fc0ba90dc383"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_linear_iterator_product.html#a9598cd49ec7a121743a9fc0ba90dc383">init</a> (<a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="classug_1_1_i_linear_operator.html">ILinearOperator</a>&lt; Y, X &gt; &gt; J, const Y &amp;u)</td></tr>
<tr class="memdesc:a9598cd49ec7a121743a9fc0ba90dc383"><td class="mdescLeft">&#160;</td><td class="mdescRight">initialize for operator J(u) and linearization point u  <a href="classug_1_1_linear_iterator_product.html#a9598cd49ec7a121743a9fc0ba90dc383">More...</a><br /></td></tr>
<tr class="separator:a9598cd49ec7a121743a9fc0ba90dc383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d53e7fbe6458c9432a8939766136f2d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_linear_iterator_product.html#a8d53e7fbe6458c9432a8939766136f2d">init</a> (<a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="classug_1_1_i_linear_operator.html">ILinearOperator</a>&lt; Y, X &gt; &gt; L)</td></tr>
<tr class="memdesc:a8d53e7fbe6458c9432a8939766136f2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">initialize for linear operator L  <a href="classug_1_1_linear_iterator_product.html#a8d53e7fbe6458c9432a8939766136f2d">More...</a><br /></td></tr>
<tr class="separator:a8d53e7fbe6458c9432a8939766136f2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99fb56d64d9d0755db79174a4835dfab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_linear_iterator_product.html#a99fb56d64d9d0755db79174a4835dfab">LinearIteratorProduct</a> ()</td></tr>
<tr class="separator:a99fb56d64d9d0755db79174a4835dfab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90ea0c80ab8e772a5781d7c08e191888"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_linear_iterator_product.html#a90ea0c80ab8e772a5781d7c08e191888">LinearIteratorProduct</a> (const std::vector&lt; <a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="classug_1_1_i_linear_iterator.html">ILinearIterator</a>&lt; X, Y &gt; &gt; &gt; &amp;vIterator)</td></tr>
<tr class="separator:a90ea0c80ab8e772a5781d7c08e191888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a331642d77347b520f0aad7e60a931f7b"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_linear_iterator_product.html#a331642d77347b520f0aad7e60a931f7b">name</a> () const</td></tr>
<tr class="memdesc:a331642d77347b520f0aad7e60a931f7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the name of iterator  <a href="classug_1_1_linear_iterator_product.html#a331642d77347b520f0aad7e60a931f7b">More...</a><br /></td></tr>
<tr class="separator:a331642d77347b520f0aad7e60a931f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classug_1_1_combined_linear_iterator"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classug_1_1_combined_linear_iterator')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classug_1_1_combined_linear_iterator.html">ug::CombinedLinearIterator&lt; X, Y &gt;</a></td></tr>
<tr class="memitem:ad10284a45c81b8774a5636574dd6e145 inherit pub_methods_classug_1_1_combined_linear_iterator"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_combined_linear_iterator.html#ad10284a45c81b8774a5636574dd6e145">add_iterator</a> (<a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="classug_1_1_i_linear_iterator.html">ILinearIterator</a>&lt; X, Y &gt; &gt; I)</td></tr>
<tr class="separator:ad10284a45c81b8774a5636574dd6e145 inherit pub_methods_classug_1_1_combined_linear_iterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac844dd9544de013d684e2173ab9927fe inherit pub_methods_classug_1_1_combined_linear_iterator"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_combined_linear_iterator.html#ac844dd9544de013d684e2173ab9927fe">add_iterator</a> (<a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="classug_1_1_i_linear_iterator.html">ILinearIterator</a>&lt; X, Y &gt; &gt; I, size_t nr)</td></tr>
<tr class="separator:ac844dd9544de013d684e2173ab9927fe inherit pub_methods_classug_1_1_combined_linear_iterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80cbdafb290dd8507d815cf58ebf57b4 inherit pub_methods_classug_1_1_combined_linear_iterator"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_combined_linear_iterator.html#a80cbdafb290dd8507d815cf58ebf57b4">CombinedLinearIterator</a> ()</td></tr>
<tr class="separator:a80cbdafb290dd8507d815cf58ebf57b4 inherit pub_methods_classug_1_1_combined_linear_iterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abef59a687ca8623e6aaa380f254fb66f inherit pub_methods_classug_1_1_combined_linear_iterator"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_combined_linear_iterator.html#abef59a687ca8623e6aaa380f254fb66f">CombinedLinearIterator</a> (const std::vector&lt; <a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="classug_1_1_i_linear_iterator.html">ILinearIterator</a>&lt; X, Y &gt; &gt; &gt; &amp;vIterator)</td></tr>
<tr class="separator:abef59a687ca8623e6aaa380f254fb66f inherit pub_methods_classug_1_1_combined_linear_iterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae600111ba69302310c468c67f0a7bc45 inherit pub_methods_classug_1_1_combined_linear_iterator"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_combined_linear_iterator.html#ae600111ba69302310c468c67f0a7bc45">supports_parallel</a> () const</td></tr>
<tr class="memdesc:ae600111ba69302310c468c67f0a7bc45 inherit pub_methods_classug_1_1_combined_linear_iterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns if parallel solving is supported  <a href="classug_1_1_combined_linear_iterator.html#ae600111ba69302310c468c67f0a7bc45">More...</a><br /></td></tr>
<tr class="separator:ae600111ba69302310c468c67f0a7bc45 inherit pub_methods_classug_1_1_combined_linear_iterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classug_1_1_i_linear_iterator"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classug_1_1_i_linear_iterator')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classug_1_1_i_linear_iterator.html">ug::ILinearIterator&lt; X, Y &gt;</a></td></tr>
<tr class="memitem:a418ce3a32db18417d9783f7d094c2945 inherit pub_methods_classug_1_1_i_linear_iterator"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_i_linear_iterator.html#a418ce3a32db18417d9783f7d094c2945">config_string</a> () const</td></tr>
<tr class="separator:a418ce3a32db18417d9783f7d094c2945 inherit pub_methods_classug_1_1_i_linear_iterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa437a6b8395a5ced9f88a4fed5b1bd77 inherit pub_methods_classug_1_1_i_linear_iterator"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="classug_1_1_i_damping.html">IDamping</a>&lt; X, Y &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_i_linear_iterator.html#aa437a6b8395a5ced9f88a4fed5b1bd77">damping</a> ()</td></tr>
<tr class="memdesc:aa437a6b8395a5ced9f88a4fed5b1bd77 inherit pub_methods_classug_1_1_i_linear_iterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the scaling  <a href="classug_1_1_i_linear_iterator.html#aa437a6b8395a5ced9f88a4fed5b1bd77">More...</a><br /></td></tr>
<tr class="separator:aa437a6b8395a5ced9f88a4fed5b1bd77 inherit pub_methods_classug_1_1_i_linear_iterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefc546bf97351373f54619ab9b5b8a46 inherit pub_methods_classug_1_1_i_linear_iterator"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_i_linear_iterator.html#aefc546bf97351373f54619ab9b5b8a46">ILinearIterator</a> ()</td></tr>
<tr class="memdesc:aefc546bf97351373f54619ab9b5b8a46 inherit pub_methods_classug_1_1_i_linear_iterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor  <a href="classug_1_1_i_linear_iterator.html#aefc546bf97351373f54619ab9b5b8a46">More...</a><br /></td></tr>
<tr class="separator:aefc546bf97351373f54619ab9b5b8a46 inherit pub_methods_classug_1_1_i_linear_iterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea663dfc186d01de17e335a6e42a57ff inherit pub_methods_classug_1_1_i_linear_iterator"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_i_linear_iterator.html#aea663dfc186d01de17e335a6e42a57ff">ILinearIterator</a> (const <a class="el" href="classug_1_1_i_linear_iterator.html">ILinearIterator</a>&lt; X, Y &gt; &amp;parent)</td></tr>
<tr class="memdesc:aea663dfc186d01de17e335a6e42a57ff inherit pub_methods_classug_1_1_i_linear_iterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy constructor  <a href="classug_1_1_i_linear_iterator.html#aea663dfc186d01de17e335a6e42a57ff">More...</a><br /></td></tr>
<tr class="separator:aea663dfc186d01de17e335a6e42a57ff inherit pub_methods_classug_1_1_i_linear_iterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1deaa4063fddd6a5b2a409730e81befb inherit pub_methods_classug_1_1_i_linear_iterator"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_i_linear_iterator.html#a1deaa4063fddd6a5b2a409730e81befb">set_damp</a> (<a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a> factor)</td></tr>
<tr class="memdesc:a1deaa4063fddd6a5b2a409730e81befb inherit pub_methods_classug_1_1_i_linear_iterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the damping to a constant factor  <a href="classug_1_1_i_linear_iterator.html#a1deaa4063fddd6a5b2a409730e81befb">More...</a><br /></td></tr>
<tr class="separator:a1deaa4063fddd6a5b2a409730e81befb inherit pub_methods_classug_1_1_i_linear_iterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2801c0b3a3a7844da204768578aa4e60 inherit pub_methods_classug_1_1_i_linear_iterator"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_i_linear_iterator.html#a2801c0b3a3a7844da204768578aa4e60">set_damp</a> (<a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="classug_1_1_i_damping.html">IDamping</a>&lt; X, Y &gt; &gt; spScaling)</td></tr>
<tr class="memdesc:a2801c0b3a3a7844da204768578aa4e60 inherit pub_methods_classug_1_1_i_linear_iterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets a scaling for the correction  <a href="classug_1_1_i_linear_iterator.html#a2801c0b3a3a7844da204768578aa4e60">More...</a><br /></td></tr>
<tr class="separator:a2801c0b3a3a7844da204768578aa4e60 inherit pub_methods_classug_1_1_i_linear_iterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7171232f6c9c7d9cdf2e4284b7a37b67 inherit pub_methods_classug_1_1_i_linear_iterator"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_i_linear_iterator.html#a7171232f6c9c7d9cdf2e4284b7a37b67">~ILinearIterator</a> ()</td></tr>
<tr class="memdesc:a7171232f6c9c7d9cdf2e4284b7a37b67 inherit pub_methods_classug_1_1_i_linear_iterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">virtual destructor  <a href="classug_1_1_i_linear_iterator.html#a7171232f6c9c7d9cdf2e4284b7a37b67">More...</a><br /></td></tr>
<tr class="separator:a7171232f6c9c7d9cdf2e4284b7a37b67 inherit pub_methods_classug_1_1_i_linear_iterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:ab45de64f727996c5c1bfeb04d19957af"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classug_1_1_combined_linear_iterator.html">CombinedLinearIterator</a>&lt; X, Y &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_linear_iterator_product.html#ab45de64f727996c5c1bfeb04d19957af">base_type</a></td></tr>
<tr class="separator:ab45de64f727996c5c1bfeb04d19957af"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ae4e5cc1ae6b7e5ffe5bec77276beff95"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="classug_1_1_i_linear_iterator.html">ILinearIterator</a>&lt; X, Y &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_linear_iterator_product.html#ae4e5cc1ae6b7e5ffe5bec77276beff95">m_vIterator</a></td></tr>
<tr class="separator:ae4e5cc1ae6b7e5ffe5bec77276beff95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classug_1_1_combined_linear_iterator"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classug_1_1_combined_linear_iterator')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classug_1_1_combined_linear_iterator.html">ug::CombinedLinearIterator&lt; X, Y &gt;</a></td></tr>
<tr class="memitem:ae4e5cc1ae6b7e5ffe5bec77276beff95 inherit pro_attribs_classug_1_1_combined_linear_iterator"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="classug_1_1_i_linear_iterator.html">ILinearIterator</a>&lt; X, Y &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_combined_linear_iterator.html#ae4e5cc1ae6b7e5ffe5bec77276beff95">m_vIterator</a></td></tr>
<tr class="separator:ae4e5cc1ae6b7e5ffe5bec77276beff95 inherit pro_attribs_classug_1_1_combined_linear_iterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classug_1_1_i_linear_iterator"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classug_1_1_i_linear_iterator')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classug_1_1_i_linear_iterator.html">ug::ILinearIterator&lt; X, Y &gt;</a></td></tr>
<tr class="memitem:a061ffcb25819046dd8bfba3626049208 inherit pro_attribs_classug_1_1_i_linear_iterator"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="classug_1_1_i_damping.html">IDamping</a>&lt; X, Y &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_i_linear_iterator.html#a061ffcb25819046dd8bfba3626049208">m_spDamping</a></td></tr>
<tr class="memdesc:a061ffcb25819046dd8bfba3626049208 inherit pro_attribs_classug_1_1_i_linear_iterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">the scaling  <a href="classug_1_1_i_linear_iterator.html#a061ffcb25819046dd8bfba3626049208">More...</a><br /></td></tr>
<tr class="separator:a061ffcb25819046dd8bfba3626049208 inherit pro_attribs_classug_1_1_i_linear_iterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classug_1_1_i_linear_iterator"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classug_1_1_i_linear_iterator')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classug_1_1_i_linear_iterator.html">ug::ILinearIterator&lt; X, Y &gt;</a></td></tr>
<tr class="memitem:a7a54a9eabc77a3121f5526febb25d825 inherit pub_types_classug_1_1_i_linear_iterator"><td class="memItemLeft" align="right" valign="top">typedef Y&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_i_linear_iterator.html#a7a54a9eabc77a3121f5526febb25d825">codomain_function_type</a></td></tr>
<tr class="memdesc:a7a54a9eabc77a3121f5526febb25d825 inherit pub_types_classug_1_1_i_linear_iterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Range space.  <a href="classug_1_1_i_linear_iterator.html#a7a54a9eabc77a3121f5526febb25d825">More...</a><br /></td></tr>
<tr class="separator:a7a54a9eabc77a3121f5526febb25d825 inherit pub_types_classug_1_1_i_linear_iterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a8964b8c1e183414871acf84083cb3e inherit pub_types_classug_1_1_i_linear_iterator"><td class="memItemLeft" align="right" valign="top">typedef X&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_i_linear_iterator.html#a8a8964b8c1e183414871acf84083cb3e">domain_function_type</a></td></tr>
<tr class="memdesc:a8a8964b8c1e183414871acf84083cb3e inherit pub_types_classug_1_1_i_linear_iterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Domain space.  <a href="classug_1_1_i_linear_iterator.html#a8a8964b8c1e183414871acf84083cb3e">More...</a><br /></td></tr>
<tr class="separator:a8a8964b8c1e183414871acf84083cb3e inherit pub_types_classug_1_1_i_linear_iterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename X, typename Y&gt;<br />
class ug::LinearIteratorProduct&lt; X, Y &gt;</h3>

<p>This operator is a product of <a class="el" href="classug_1_1_i_linear_iterator.html" title="describes a linear iterator">ILinearIterator</a> (multiplicative composition). </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ab45de64f727996c5c1bfeb04d19957af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab45de64f727996c5c1bfeb04d19957af">&#9670;&nbsp;</a></span>base_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename X , typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classug_1_1_combined_linear_iterator.html">CombinedLinearIterator</a>&lt;X,Y&gt; <a class="el" href="classug_1_1_linear_iterator_product.html">ug::LinearIteratorProduct</a>&lt; X, Y &gt;::<a class="el" href="classug_1_1_linear_iterator_product.html#ab45de64f727996c5c1bfeb04d19957af">base_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a99fb56d64d9d0755db79174a4835dfab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99fb56d64d9d0755db79174a4835dfab">&#9670;&nbsp;</a></span>LinearIteratorProduct() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename X , typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classug_1_1_linear_iterator_product.html">ug::LinearIteratorProduct</a>&lt; X, Y &gt;::<a class="el" href="classug_1_1_linear_iterator_product.html">LinearIteratorProduct</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="classug_1_1_linear_iterator_product.html#af3b1a2fa3e0618496b037370d3b8acaa">ug::LinearIteratorProduct&lt; X, Y &gt;::clone()</a>.</p>

</div>
</div>
<a id="a90ea0c80ab8e772a5781d7c08e191888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90ea0c80ab8e772a5781d7c08e191888">&#9670;&nbsp;</a></span>LinearIteratorProduct() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename X , typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classug_1_1_linear_iterator_product.html">ug::LinearIteratorProduct</a>&lt; X, Y &gt;::<a class="el" href="classug_1_1_linear_iterator_product.html">LinearIteratorProduct</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="classug_1_1_i_linear_iterator.html">ILinearIterator</a>&lt; X, Y &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vIterator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a02e86028179573d375634aea90584070"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02e86028179573d375634aea90584070">&#9670;&nbsp;</a></span>apply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename X , typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classug_1_1_linear_iterator_product.html">ug::LinearIteratorProduct</a>&lt; X, Y &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">Y &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compute new correction c = B*d </p>
<p>This method applies the iterator operator, i.e. c = B*d. The domain function d remains unchanged. Note, that this method can always be implemented by creating a copy of d and calling apply_update_defect with this copy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>defect </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">c</td><td>correction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool success flag </dd></dl>

<p>Implements <a class="el" href="classug_1_1_combined_linear_iterator.html#ac0bf2c6d4b73442b61d8d454bbc54ba8">ug::CombinedLinearIterator&lt; X, Y &gt;</a>.</p>

<p class="reference">References <a class="el" href="classug_1_1_linear_iterator_product.html#a5847b63a9e2be7aa55ed40ddfed5a3bf">ug::LinearIteratorProduct&lt; X, Y &gt;::apply_update_defect()</a>.</p>

</div>
</div>
<a id="a5847b63a9e2be7aa55ed40ddfed5a3bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5847b63a9e2be7aa55ed40ddfed5a3bf">&#9670;&nbsp;</a></span>apply_update_defect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename X , typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classug_1_1_linear_iterator_product.html">ug::LinearIteratorProduct</a>&lt; X, Y &gt;::apply_update_defect </td>
          <td>(</td>
          <td class="paramtype">Y &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compute new correction c = B*d and update defect d := d - A*c </p>
<p>This method applies the inverse operator, i.e. c = B*d. The domain function d is changed in the way, that the defect d := d - A*c is returned in the function. This is always useful, when the iterating algorithm can (or must) update the defect during computation (this is e.g. the case for the geometric multigrid method). Note, that this method can always be implemented by calling apply and then computing d := d - A*c.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d</td><td>defect </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>correction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool success flag </dd></dl>

<p>Implements <a class="el" href="classug_1_1_combined_linear_iterator.html#aca0c9d196afaff556b68a058fa1c8b54">ug::CombinedLinearIterator&lt; X, Y &gt;</a>.</p>

<p class="reference">References <a class="el" href="classug_1_1_linear_iterator_product.html#ae4e5cc1ae6b7e5ffe5bec77276beff95">ug::LinearIteratorProduct&lt; X, Y &gt;::m_vIterator</a>.</p>

<p class="reference">Referenced by <a class="el" href="classug_1_1_linear_iterator_product.html#a02e86028179573d375634aea90584070">ug::LinearIteratorProduct&lt; X, Y &gt;::apply()</a>.</p>

</div>
</div>
<a id="af3b1a2fa3e0618496b037370d3b8acaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3b1a2fa3e0618496b037370d3b8acaa">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename X , typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt;<a class="el" href="classug_1_1_i_linear_iterator.html">ILinearIterator</a>&lt;X,Y&gt; &gt; <a class="el" href="classug_1_1_linear_iterator_product.html">ug::LinearIteratorProduct</a>&lt; X, Y &gt;::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>clone </p>

<p>Implements <a class="el" href="classug_1_1_combined_linear_iterator.html#a4547c174ac9b318fc0b1bc6f5b6aefae">ug::CombinedLinearIterator&lt; X, Y &gt;</a>.</p>

<p class="reference">References <a class="el" href="classug_1_1_linear_iterator_product.html#a99fb56d64d9d0755db79174a4835dfab">ug::LinearIteratorProduct&lt; X, Y &gt;::LinearIteratorProduct()</a>, and <a class="el" href="smart__pointer_8h.html#a8ba0055baeb80cdf31c501403f7f302f">make_sp()</a>.</p>

</div>
</div>
<a id="a9598cd49ec7a121743a9fc0ba90dc383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9598cd49ec7a121743a9fc0ba90dc383">&#9670;&nbsp;</a></span>init() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename X , typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classug_1_1_linear_iterator_product.html">ug::LinearIteratorProduct</a>&lt; X, Y &gt;::init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="classug_1_1_i_linear_operator.html">ILinearOperator</a>&lt; Y, X &gt; &gt;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Y &amp;&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>initialize for operator J(u) and linearization point u </p>
<p>This method passes the linear operator J(u) that should be used as underlying by this iterator. As second argument the linearization point is passed. This is needed e.g. for the geometric multigrid method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">J</td><td>linearized operator to use as underlying </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">u</td><td>linearization point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool success flag </dd></dl>

<p>Implements <a class="el" href="classug_1_1_combined_linear_iterator.html#a6d015d5c3251e5beb3c43696d2ea1eb2">ug::CombinedLinearIterator&lt; X, Y &gt;</a>.</p>

<p class="reference">References <a class="el" href="classug_1_1_linear_iterator_product.html#ae4e5cc1ae6b7e5ffe5bec77276beff95">ug::LinearIteratorProduct&lt; X, Y &gt;::m_vIterator</a>.</p>

</div>
</div>
<a id="a8d53e7fbe6458c9432a8939766136f2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d53e7fbe6458c9432a8939766136f2d">&#9670;&nbsp;</a></span>init() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename X , typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classug_1_1_linear_iterator_product.html">ug::LinearIteratorProduct</a>&lt; X, Y &gt;::init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="classug_1_1_i_linear_operator.html">ILinearOperator</a>&lt; Y, X &gt; &gt;&#160;</td>
          <td class="paramname"><em>L</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>initialize for linear operator L </p>
<p>This method passes the operator L that used as underlying by this operator. In addition some preparation step can be made.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">L</td><td>linear operator to use as underlying </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool success flag </dd></dl>

<p>Implements <a class="el" href="classug_1_1_combined_linear_iterator.html#a68467cd6da4e97c58ff6bceb95092a26">ug::CombinedLinearIterator&lt; X, Y &gt;</a>.</p>

<p class="reference">References <a class="el" href="classug_1_1_linear_iterator_product.html#ae4e5cc1ae6b7e5ffe5bec77276beff95">ug::LinearIteratorProduct&lt; X, Y &gt;::m_vIterator</a>.</p>

</div>
</div>
<a id="a331642d77347b520f0aad7e60a931f7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a331642d77347b520f0aad7e60a931f7b">&#9670;&nbsp;</a></span>name()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename X , typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* <a class="el" href="classug_1_1_linear_iterator_product.html">ug::LinearIteratorProduct</a>&lt; X, Y &gt;::name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the name of iterator </p>
<p>This method returns the name of the iterator operator. This function is typically needed, when the iterator operator is used inside of another operator and some debug output should be printed</p>
<dl class="section return"><dt>Returns</dt><dd>const char* name of inverse operator </dd></dl>

<p>Implements <a class="el" href="classug_1_1_combined_linear_iterator.html#a59dcda0da2d46c07b74633f9e8c16102">ug::CombinedLinearIterator&lt; X, Y &gt;</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ae4e5cc1ae6b7e5ffe5bec77276beff95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4e5cc1ae6b7e5ffe5bec77276beff95">&#9670;&nbsp;</a></span>m_vIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename X , typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt;<a class="el" href="classug_1_1_i_linear_iterator.html">ILinearIterator</a>&lt;X,Y&gt; &gt; &gt; <a class="el" href="classug_1_1_combined_linear_iterator.html">ug::CombinedLinearIterator</a>&lt; X, Y &gt;::m_vIterator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="classug_1_1_linear_iterator_product.html#a5847b63a9e2be7aa55ed40ddfed5a3bf">ug::LinearIteratorProduct&lt; X, Y &gt;::apply_update_defect()</a>, and <a class="el" href="classug_1_1_linear_iterator_product.html#a9598cd49ec7a121743a9fc0ba90dc383">ug::LinearIteratorProduct&lt; X, Y &gt;::init()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>ugbase/lib_algebra/operator/preconditioner/<a class="el" href="iterator__product_8h_source.html">iterator_product.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceug.html">ug</a></li><li class="navelem"><a class="el" href="classug_1_1_linear_iterator_product.html">LinearIteratorProduct</a></li>
    <li class="footer">Generated on Mon Feb 26 2024 00:54:52 for ug4 by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
