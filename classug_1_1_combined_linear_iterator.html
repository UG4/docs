<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ug4: ug::CombinedLinearIterator&lt; X, Y &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ug4
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classug_1_1_combined_linear_iterator.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classug_1_1_combined_linear_iterator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ug::CombinedLinearIterator&lt; X, Y &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="iterator__product_8h_source.html">iterator_product.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for ug::CombinedLinearIterator&lt; X, Y &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="classug_1_1_combined_linear_iterator.png" usemap="#ug::CombinedLinearIterator_3C_20X_2C_20Y_20_3E_map" alt=""/>
  <map id="ug::CombinedLinearIterator_3C_20X_2C_20Y_20_3E_map" name="ug::CombinedLinearIterator_3C_20X_2C_20Y_20_3E_map">
<area href="classug_1_1_i_linear_iterator.html" alt="ug::ILinearIterator&lt; X, Y &gt;" shape="rect" coords="112,0,327,24"/>
<area href="classug_1_1_linear_iterator_product.html" alt="ug::LinearIteratorProduct&lt; X, Y &gt;" shape="rect" coords="0,112,215,136"/>
<area href="classug_1_1_linear_iterator_sum.html" alt="ug::LinearIteratorSum&lt; X, Y &gt;" shape="rect" coords="225,112,440,136"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad10284a45c81b8774a5636574dd6e145"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_combined_linear_iterator.html#ad10284a45c81b8774a5636574dd6e145">add_iterator</a> (<a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="classug_1_1_i_linear_iterator.html">ILinearIterator</a>&lt; X, Y &gt; &gt; I)</td></tr>
<tr class="separator:ad10284a45c81b8774a5636574dd6e145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac844dd9544de013d684e2173ab9927fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_combined_linear_iterator.html#ac844dd9544de013d684e2173ab9927fe">add_iterator</a> (<a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="classug_1_1_i_linear_iterator.html">ILinearIterator</a>&lt; X, Y &gt; &gt; I, size_t nr)</td></tr>
<tr class="separator:ac844dd9544de013d684e2173ab9927fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0bf2c6d4b73442b61d8d454bbc54ba8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_combined_linear_iterator.html#ac0bf2c6d4b73442b61d8d454bbc54ba8">apply</a> (Y &amp;c, const X &amp;d)=0</td></tr>
<tr class="memdesc:ac0bf2c6d4b73442b61d8d454bbc54ba8"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute new correction c = B*d  <a href="classug_1_1_combined_linear_iterator.html#ac0bf2c6d4b73442b61d8d454bbc54ba8">More...</a><br /></td></tr>
<tr class="separator:ac0bf2c6d4b73442b61d8d454bbc54ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca0c9d196afaff556b68a058fa1c8b54"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_combined_linear_iterator.html#aca0c9d196afaff556b68a058fa1c8b54">apply_update_defect</a> (Y &amp;c, X &amp;d)=0</td></tr>
<tr class="memdesc:aca0c9d196afaff556b68a058fa1c8b54"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute new correction c = B*d and update defect d := d - A*c  <a href="classug_1_1_combined_linear_iterator.html#aca0c9d196afaff556b68a058fa1c8b54">More...</a><br /></td></tr>
<tr class="separator:aca0c9d196afaff556b68a058fa1c8b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4547c174ac9b318fc0b1bc6f5b6aefae"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="classug_1_1_i_linear_iterator.html">ILinearIterator</a>&lt; X, Y &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_combined_linear_iterator.html#a4547c174ac9b318fc0b1bc6f5b6aefae">clone</a> ()=0</td></tr>
<tr class="memdesc:a4547c174ac9b318fc0b1bc6f5b6aefae"><td class="mdescLeft">&#160;</td><td class="mdescRight">clone  <a href="classug_1_1_combined_linear_iterator.html#a4547c174ac9b318fc0b1bc6f5b6aefae">More...</a><br /></td></tr>
<tr class="separator:a4547c174ac9b318fc0b1bc6f5b6aefae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80cbdafb290dd8507d815cf58ebf57b4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_combined_linear_iterator.html#a80cbdafb290dd8507d815cf58ebf57b4">CombinedLinearIterator</a> ()</td></tr>
<tr class="separator:a80cbdafb290dd8507d815cf58ebf57b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abef59a687ca8623e6aaa380f254fb66f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_combined_linear_iterator.html#abef59a687ca8623e6aaa380f254fb66f">CombinedLinearIterator</a> (const std::vector&lt; <a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="classug_1_1_i_linear_iterator.html">ILinearIterator</a>&lt; X, Y &gt; &gt; &gt; &amp;vIterator)</td></tr>
<tr class="separator:abef59a687ca8623e6aaa380f254fb66f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d015d5c3251e5beb3c43696d2ea1eb2"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_combined_linear_iterator.html#a6d015d5c3251e5beb3c43696d2ea1eb2">init</a> (<a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="classug_1_1_i_linear_operator.html">ILinearOperator</a>&lt; Y, X &gt; &gt; J, const Y &amp;u)=0</td></tr>
<tr class="memdesc:a6d015d5c3251e5beb3c43696d2ea1eb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">initialize for operator J(u) and linearization point u  <a href="classug_1_1_combined_linear_iterator.html#a6d015d5c3251e5beb3c43696d2ea1eb2">More...</a><br /></td></tr>
<tr class="separator:a6d015d5c3251e5beb3c43696d2ea1eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68467cd6da4e97c58ff6bceb95092a26"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_combined_linear_iterator.html#a68467cd6da4e97c58ff6bceb95092a26">init</a> (<a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="classug_1_1_i_linear_operator.html">ILinearOperator</a>&lt; Y, X &gt; &gt; L)=0</td></tr>
<tr class="memdesc:a68467cd6da4e97c58ff6bceb95092a26"><td class="mdescLeft">&#160;</td><td class="mdescRight">initialize for linear operator L  <a href="classug_1_1_combined_linear_iterator.html#a68467cd6da4e97c58ff6bceb95092a26">More...</a><br /></td></tr>
<tr class="separator:a68467cd6da4e97c58ff6bceb95092a26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59dcda0da2d46c07b74633f9e8c16102"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_combined_linear_iterator.html#a59dcda0da2d46c07b74633f9e8c16102">name</a> () const =0</td></tr>
<tr class="memdesc:a59dcda0da2d46c07b74633f9e8c16102"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the name of iterator  <a href="classug_1_1_combined_linear_iterator.html#a59dcda0da2d46c07b74633f9e8c16102">More...</a><br /></td></tr>
<tr class="separator:a59dcda0da2d46c07b74633f9e8c16102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae600111ba69302310c468c67f0a7bc45"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_combined_linear_iterator.html#ae600111ba69302310c468c67f0a7bc45">supports_parallel</a> () const</td></tr>
<tr class="memdesc:ae600111ba69302310c468c67f0a7bc45"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns if parallel solving is supported  <a href="classug_1_1_combined_linear_iterator.html#ae600111ba69302310c468c67f0a7bc45">More...</a><br /></td></tr>
<tr class="separator:ae600111ba69302310c468c67f0a7bc45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classug_1_1_i_linear_iterator"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classug_1_1_i_linear_iterator')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classug_1_1_i_linear_iterator.html">ug::ILinearIterator&lt; X, Y &gt;</a></td></tr>
<tr class="memitem:a418ce3a32db18417d9783f7d094c2945 inherit pub_methods_classug_1_1_i_linear_iterator"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_i_linear_iterator.html#a418ce3a32db18417d9783f7d094c2945">config_string</a> () const</td></tr>
<tr class="separator:a418ce3a32db18417d9783f7d094c2945 inherit pub_methods_classug_1_1_i_linear_iterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa437a6b8395a5ced9f88a4fed5b1bd77 inherit pub_methods_classug_1_1_i_linear_iterator"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="classug_1_1_i_damping.html">IDamping</a>&lt; X, Y &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_i_linear_iterator.html#aa437a6b8395a5ced9f88a4fed5b1bd77">damping</a> ()</td></tr>
<tr class="memdesc:aa437a6b8395a5ced9f88a4fed5b1bd77 inherit pub_methods_classug_1_1_i_linear_iterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the scaling  <a href="classug_1_1_i_linear_iterator.html#aa437a6b8395a5ced9f88a4fed5b1bd77">More...</a><br /></td></tr>
<tr class="separator:aa437a6b8395a5ced9f88a4fed5b1bd77 inherit pub_methods_classug_1_1_i_linear_iterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefc546bf97351373f54619ab9b5b8a46 inherit pub_methods_classug_1_1_i_linear_iterator"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_i_linear_iterator.html#aefc546bf97351373f54619ab9b5b8a46">ILinearIterator</a> ()</td></tr>
<tr class="memdesc:aefc546bf97351373f54619ab9b5b8a46 inherit pub_methods_classug_1_1_i_linear_iterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor  <a href="classug_1_1_i_linear_iterator.html#aefc546bf97351373f54619ab9b5b8a46">More...</a><br /></td></tr>
<tr class="separator:aefc546bf97351373f54619ab9b5b8a46 inherit pub_methods_classug_1_1_i_linear_iterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea663dfc186d01de17e335a6e42a57ff inherit pub_methods_classug_1_1_i_linear_iterator"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_i_linear_iterator.html#aea663dfc186d01de17e335a6e42a57ff">ILinearIterator</a> (const <a class="el" href="classug_1_1_i_linear_iterator.html">ILinearIterator</a>&lt; X, Y &gt; &amp;parent)</td></tr>
<tr class="memdesc:aea663dfc186d01de17e335a6e42a57ff inherit pub_methods_classug_1_1_i_linear_iterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy constructor  <a href="classug_1_1_i_linear_iterator.html#aea663dfc186d01de17e335a6e42a57ff">More...</a><br /></td></tr>
<tr class="separator:aea663dfc186d01de17e335a6e42a57ff inherit pub_methods_classug_1_1_i_linear_iterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1deaa4063fddd6a5b2a409730e81befb inherit pub_methods_classug_1_1_i_linear_iterator"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_i_linear_iterator.html#a1deaa4063fddd6a5b2a409730e81befb">set_damp</a> (<a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a> factor)</td></tr>
<tr class="memdesc:a1deaa4063fddd6a5b2a409730e81befb inherit pub_methods_classug_1_1_i_linear_iterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the damping to a constant factor  <a href="classug_1_1_i_linear_iterator.html#a1deaa4063fddd6a5b2a409730e81befb">More...</a><br /></td></tr>
<tr class="separator:a1deaa4063fddd6a5b2a409730e81befb inherit pub_methods_classug_1_1_i_linear_iterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2801c0b3a3a7844da204768578aa4e60 inherit pub_methods_classug_1_1_i_linear_iterator"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_i_linear_iterator.html#a2801c0b3a3a7844da204768578aa4e60">set_damp</a> (<a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="classug_1_1_i_damping.html">IDamping</a>&lt; X, Y &gt; &gt; spScaling)</td></tr>
<tr class="memdesc:a2801c0b3a3a7844da204768578aa4e60 inherit pub_methods_classug_1_1_i_linear_iterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets a scaling for the correction  <a href="classug_1_1_i_linear_iterator.html#a2801c0b3a3a7844da204768578aa4e60">More...</a><br /></td></tr>
<tr class="separator:a2801c0b3a3a7844da204768578aa4e60 inherit pub_methods_classug_1_1_i_linear_iterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7171232f6c9c7d9cdf2e4284b7a37b67 inherit pub_methods_classug_1_1_i_linear_iterator"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_i_linear_iterator.html#a7171232f6c9c7d9cdf2e4284b7a37b67">~ILinearIterator</a> ()</td></tr>
<tr class="memdesc:a7171232f6c9c7d9cdf2e4284b7a37b67 inherit pub_methods_classug_1_1_i_linear_iterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">virtual destructor  <a href="classug_1_1_i_linear_iterator.html#a7171232f6c9c7d9cdf2e4284b7a37b67">More...</a><br /></td></tr>
<tr class="separator:a7171232f6c9c7d9cdf2e4284b7a37b67 inherit pub_methods_classug_1_1_i_linear_iterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ae4e5cc1ae6b7e5ffe5bec77276beff95"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="classug_1_1_i_linear_iterator.html">ILinearIterator</a>&lt; X, Y &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_combined_linear_iterator.html#ae4e5cc1ae6b7e5ffe5bec77276beff95">m_vIterator</a></td></tr>
<tr class="separator:ae4e5cc1ae6b7e5ffe5bec77276beff95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classug_1_1_i_linear_iterator"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classug_1_1_i_linear_iterator')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classug_1_1_i_linear_iterator.html">ug::ILinearIterator&lt; X, Y &gt;</a></td></tr>
<tr class="memitem:a061ffcb25819046dd8bfba3626049208 inherit pro_attribs_classug_1_1_i_linear_iterator"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="classug_1_1_i_damping.html">IDamping</a>&lt; X, Y &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_i_linear_iterator.html#a061ffcb25819046dd8bfba3626049208">m_spDamping</a></td></tr>
<tr class="memdesc:a061ffcb25819046dd8bfba3626049208 inherit pro_attribs_classug_1_1_i_linear_iterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">the scaling  <a href="classug_1_1_i_linear_iterator.html#a061ffcb25819046dd8bfba3626049208">More...</a><br /></td></tr>
<tr class="separator:a061ffcb25819046dd8bfba3626049208 inherit pro_attribs_classug_1_1_i_linear_iterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classug_1_1_i_linear_iterator"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classug_1_1_i_linear_iterator')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classug_1_1_i_linear_iterator.html">ug::ILinearIterator&lt; X, Y &gt;</a></td></tr>
<tr class="memitem:a7a54a9eabc77a3121f5526febb25d825 inherit pub_types_classug_1_1_i_linear_iterator"><td class="memItemLeft" align="right" valign="top">typedef Y&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_i_linear_iterator.html#a7a54a9eabc77a3121f5526febb25d825">codomain_function_type</a></td></tr>
<tr class="memdesc:a7a54a9eabc77a3121f5526febb25d825 inherit pub_types_classug_1_1_i_linear_iterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Range space.  <a href="classug_1_1_i_linear_iterator.html#a7a54a9eabc77a3121f5526febb25d825">More...</a><br /></td></tr>
<tr class="separator:a7a54a9eabc77a3121f5526febb25d825 inherit pub_types_classug_1_1_i_linear_iterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a8964b8c1e183414871acf84083cb3e inherit pub_types_classug_1_1_i_linear_iterator"><td class="memItemLeft" align="right" valign="top">typedef X&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_i_linear_iterator.html#a8a8964b8c1e183414871acf84083cb3e">domain_function_type</a></td></tr>
<tr class="memdesc:a8a8964b8c1e183414871acf84083cb3e inherit pub_types_classug_1_1_i_linear_iterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Domain space.  <a href="classug_1_1_i_linear_iterator.html#a8a8964b8c1e183414871acf84083cb3e">More...</a><br /></td></tr>
<tr class="separator:a8a8964b8c1e183414871acf84083cb3e inherit pub_types_classug_1_1_i_linear_iterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename X, typename Y&gt;<br />
class ug::CombinedLinearIterator&lt; X, Y &gt;</h3>

<p>Base class for ILinearIterators build from other ILinearIterators </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a80cbdafb290dd8507d815cf58ebf57b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80cbdafb290dd8507d815cf58ebf57b4">&#9670;&nbsp;</a></span>CombinedLinearIterator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename X , typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classug_1_1_combined_linear_iterator.html">ug::CombinedLinearIterator</a>&lt; X, Y &gt;::<a class="el" href="classug_1_1_combined_linear_iterator.html">CombinedLinearIterator</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abef59a687ca8623e6aaa380f254fb66f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abef59a687ca8623e6aaa380f254fb66f">&#9670;&nbsp;</a></span>CombinedLinearIterator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename X , typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classug_1_1_combined_linear_iterator.html">ug::CombinedLinearIterator</a>&lt; X, Y &gt;::<a class="el" href="classug_1_1_combined_linear_iterator.html">CombinedLinearIterator</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="classug_1_1_i_linear_iterator.html">ILinearIterator</a>&lt; X, Y &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vIterator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad10284a45c81b8774a5636574dd6e145"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad10284a45c81b8774a5636574dd6e145">&#9670;&nbsp;</a></span>add_iterator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename X , typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classug_1_1_combined_linear_iterator.html">ug::CombinedLinearIterator</a>&lt; X, Y &gt;::add_iterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="classug_1_1_i_linear_iterator.html">ILinearIterator</a>&lt; X, Y &gt; &gt;&#160;</td>
          <td class="paramname"><em>I</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="classug_1_1_combined_linear_iterator.html#ae4e5cc1ae6b7e5ffe5bec77276beff95">ug::CombinedLinearIterator&lt; X, Y &gt;::m_vIterator</a>.</p>

</div>
</div>
<a id="ac844dd9544de013d684e2173ab9927fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac844dd9544de013d684e2173ab9927fe">&#9670;&nbsp;</a></span>add_iterator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename X , typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classug_1_1_combined_linear_iterator.html">ug::CombinedLinearIterator</a>&lt; X, Y &gt;::add_iterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="classug_1_1_i_linear_iterator.html">ILinearIterator</a>&lt; X, Y &gt; &gt;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="classug_1_1_combined_linear_iterator.html#ae4e5cc1ae6b7e5ffe5bec77276beff95">ug::CombinedLinearIterator&lt; X, Y &gt;::m_vIterator</a>.</p>

</div>
</div>
<a id="ac0bf2c6d4b73442b61d8d454bbc54ba8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0bf2c6d4b73442b61d8d454bbc54ba8">&#9670;&nbsp;</a></span>apply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename X , typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classug_1_1_combined_linear_iterator.html">ug::CombinedLinearIterator</a>&lt; X, Y &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">Y &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compute new correction c = B*d </p>
<p>This method applies the iterator operator, i.e. c = B*d. The domain function d remains unchanged. Note, that this method can always be implemented by creating a copy of d and calling apply_update_defect with this copy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>defect </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">c</td><td>correction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool success flag </dd></dl>

<p>Implements <a class="el" href="classug_1_1_i_linear_iterator.html#a293e586f2b9bc1affab1aed75b89387c">ug::ILinearIterator&lt; X, Y &gt;</a>.</p>

<p>Implemented in <a class="el" href="classug_1_1_linear_iterator_sum.html#ab11fbafeb33fd03c109f943f46fef7d3">ug::LinearIteratorSum&lt; X, Y &gt;</a>, and <a class="el" href="classug_1_1_linear_iterator_product.html#a02e86028179573d375634aea90584070">ug::LinearIteratorProduct&lt; X, Y &gt;</a>.</p>

</div>
</div>
<a id="aca0c9d196afaff556b68a058fa1c8b54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca0c9d196afaff556b68a058fa1c8b54">&#9670;&nbsp;</a></span>apply_update_defect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename X , typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classug_1_1_combined_linear_iterator.html">ug::CombinedLinearIterator</a>&lt; X, Y &gt;::apply_update_defect </td>
          <td>(</td>
          <td class="paramtype">Y &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compute new correction c = B*d and update defect d := d - A*c </p>
<p>This method applies the inverse operator, i.e. c = B*d. The domain function d is changed in the way, that the defect d := d - A*c is returned in the function. This is always useful, when the iterating algorithm can (or must) update the defect during computation (this is e.g. the case for the geometric multigrid method). Note, that this method can always be implemented by calling apply and then computing d := d - A*c.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d</td><td>defect </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>correction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool success flag </dd></dl>

<p>Implements <a class="el" href="classug_1_1_i_linear_iterator.html#a0c0ffc2bfb32edb2cef566b14d815556">ug::ILinearIterator&lt; X, Y &gt;</a>.</p>

<p>Implemented in <a class="el" href="classug_1_1_linear_iterator_sum.html#affdb1ffe1dbf88a3112dd3611c307726">ug::LinearIteratorSum&lt; X, Y &gt;</a>, and <a class="el" href="classug_1_1_linear_iterator_product.html#a5847b63a9e2be7aa55ed40ddfed5a3bf">ug::LinearIteratorProduct&lt; X, Y &gt;</a>.</p>

</div>
</div>
<a id="a4547c174ac9b318fc0b1bc6f5b6aefae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4547c174ac9b318fc0b1bc6f5b6aefae">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename X , typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt;<a class="el" href="classug_1_1_i_linear_iterator.html">ILinearIterator</a>&lt;X,Y&gt; &gt; <a class="el" href="classug_1_1_combined_linear_iterator.html">ug::CombinedLinearIterator</a>&lt; X, Y &gt;::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>clone </p>

<p>Implements <a class="el" href="classug_1_1_i_linear_iterator.html#acc249ee1efa7994db8e732772728d5c1">ug::ILinearIterator&lt; X, Y &gt;</a>.</p>

<p>Implemented in <a class="el" href="classug_1_1_linear_iterator_sum.html#a9947ec800340a64726ade66e6017d9f5">ug::LinearIteratorSum&lt; X, Y &gt;</a>, and <a class="el" href="classug_1_1_linear_iterator_product.html#af3b1a2fa3e0618496b037370d3b8acaa">ug::LinearIteratorProduct&lt; X, Y &gt;</a>.</p>

</div>
</div>
<a id="a6d015d5c3251e5beb3c43696d2ea1eb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d015d5c3251e5beb3c43696d2ea1eb2">&#9670;&nbsp;</a></span>init() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename X , typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classug_1_1_combined_linear_iterator.html">ug::CombinedLinearIterator</a>&lt; X, Y &gt;::init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="classug_1_1_i_linear_operator.html">ILinearOperator</a>&lt; Y, X &gt; &gt;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Y &amp;&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>initialize for operator J(u) and linearization point u </p>
<p>This method passes the linear operator J(u) that should be used as underlying by this iterator. As second argument the linearization point is passed. This is needed e.g. for the geometric multigrid method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">J</td><td>linearized operator to use as underlying </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">u</td><td>linearization point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool success flag </dd></dl>

<p>Implements <a class="el" href="classug_1_1_i_linear_iterator.html#a974eed8cfc9e2bc0b6bbc64a44b4ce8a">ug::ILinearIterator&lt; X, Y &gt;</a>.</p>

<p>Implemented in <a class="el" href="classug_1_1_linear_iterator_sum.html#ab6f2ee3c6302cd76e2863fcee4d77cda">ug::LinearIteratorSum&lt; X, Y &gt;</a>, and <a class="el" href="classug_1_1_linear_iterator_product.html#a9598cd49ec7a121743a9fc0ba90dc383">ug::LinearIteratorProduct&lt; X, Y &gt;</a>.</p>

</div>
</div>
<a id="a68467cd6da4e97c58ff6bceb95092a26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68467cd6da4e97c58ff6bceb95092a26">&#9670;&nbsp;</a></span>init() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename X , typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classug_1_1_combined_linear_iterator.html">ug::CombinedLinearIterator</a>&lt; X, Y &gt;::init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="classug_1_1_i_linear_operator.html">ILinearOperator</a>&lt; Y, X &gt; &gt;&#160;</td>
          <td class="paramname"><em>L</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>initialize for linear operator L </p>
<p>This method passes the operator L that used as underlying by this operator. In addition some preparation step can be made.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">L</td><td>linear operator to use as underlying </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool success flag </dd></dl>

<p>Implements <a class="el" href="classug_1_1_i_linear_iterator.html#a306fe0f0062f16fe7000c88bf4ffddc3">ug::ILinearIterator&lt; X, Y &gt;</a>.</p>

<p>Implemented in <a class="el" href="classug_1_1_linear_iterator_sum.html#a2d8cce028db95eb4c9d1228e5de72f8e">ug::LinearIteratorSum&lt; X, Y &gt;</a>, and <a class="el" href="classug_1_1_linear_iterator_product.html#a8d53e7fbe6458c9432a8939766136f2d">ug::LinearIteratorProduct&lt; X, Y &gt;</a>.</p>

</div>
</div>
<a id="a59dcda0da2d46c07b74633f9e8c16102"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59dcda0da2d46c07b74633f9e8c16102">&#9670;&nbsp;</a></span>name()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename X , typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* <a class="el" href="classug_1_1_combined_linear_iterator.html">ug::CombinedLinearIterator</a>&lt; X, Y &gt;::name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the name of iterator </p>
<p>This method returns the name of the iterator operator. This function is typically needed, when the iterator operator is used inside of another operator and some debug output should be printed</p>
<dl class="section return"><dt>Returns</dt><dd>const char* name of inverse operator </dd></dl>

<p>Implements <a class="el" href="classug_1_1_i_linear_iterator.html#ade314890710f60784c7f9c57597f6842">ug::ILinearIterator&lt; X, Y &gt;</a>.</p>

<p>Implemented in <a class="el" href="classug_1_1_linear_iterator_sum.html#a87589b42e41ba3f2bc1703e72cc17704">ug::LinearIteratorSum&lt; X, Y &gt;</a>, and <a class="el" href="classug_1_1_linear_iterator_product.html#a331642d77347b520f0aad7e60a931f7b">ug::LinearIteratorProduct&lt; X, Y &gt;</a>.</p>

</div>
</div>
<a id="ae600111ba69302310c468c67f0a7bc45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae600111ba69302310c468c67f0a7bc45">&#9670;&nbsp;</a></span>supports_parallel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename X , typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classug_1_1_combined_linear_iterator.html">ug::CombinedLinearIterator</a>&lt; X, Y &gt;::supports_parallel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns if parallel solving is supported </p>

<p>Implements <a class="el" href="classug_1_1_i_linear_iterator.html#a0b857bd37bb750ab867343e799fc2d48">ug::ILinearIterator&lt; X, Y &gt;</a>.</p>

<p class="reference">References <a class="el" href="classug_1_1_combined_linear_iterator.html#ae4e5cc1ae6b7e5ffe5bec77276beff95">ug::CombinedLinearIterator&lt; X, Y &gt;::m_vIterator</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ae4e5cc1ae6b7e5ffe5bec77276beff95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4e5cc1ae6b7e5ffe5bec77276beff95">&#9670;&nbsp;</a></span>m_vIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename X , typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt;<a class="el" href="classug_1_1_i_linear_iterator.html">ILinearIterator</a>&lt;X,Y&gt; &gt; &gt; <a class="el" href="classug_1_1_combined_linear_iterator.html">ug::CombinedLinearIterator</a>&lt; X, Y &gt;::m_vIterator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="classug_1_1_combined_linear_iterator.html#ad10284a45c81b8774a5636574dd6e145">ug::CombinedLinearIterator&lt; X, Y &gt;::add_iterator()</a>, and <a class="el" href="classug_1_1_combined_linear_iterator.html#ae600111ba69302310c468c67f0a7bc45">ug::CombinedLinearIterator&lt; X, Y &gt;::supports_parallel()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>ugbase/lib_algebra/operator/preconditioner/<a class="el" href="iterator__product_8h_source.html">iterator_product.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceug.html">ug</a></li><li class="navelem"><a class="el" href="classug_1_1_combined_linear_iterator.html">CombinedLinearIterator</a></li>
    <li class="footer">Generated on Mon Apr 3 2023 01:00:41 for ug4 by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
