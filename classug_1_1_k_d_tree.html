<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ug4: ug::KDTree&lt; point_t, data_t, real_t &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ug4
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classug_1_1_k_d_tree.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classug_1_1_k_d_tree-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ug::KDTree&lt; point_t, data_t, real_t &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="kd__tree_8h_source.html">kd_tree.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_k_d_tree_1_1_element.html">Element</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="classug_1_1_k_d_tree_1_1_element.html" title="An Element represents a point with an associated data value.">Element</a> represents a point with an associated data value.  <a href="classug_1_1_k_d_tree_1_1_element.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structug_1_1_k_d_tree_1_1_node.html">Node</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3c8e3e03820206996554bcade62c4d80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_k_d_tree.html#a3c8e3e03820206996554bcade62c4d80">add_element</a> (const point_t &amp;point, const data_t &amp;data, bool delayInsertion=false)</td></tr>
<tr class="memdesc:a3c8e3e03820206996554bcade62c4d80"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds an element to the tree.  <a href="classug_1_1_k_d_tree.html#a3c8e3e03820206996554bcade62c4d80">More...</a><br /></td></tr>
<tr class="separator:a3c8e3e03820206996554bcade62c4d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bf5c8818c843265c74ad3a2df6a09fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classug_1_1_k_d_tree_1_1_element.html">Element</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_k_d_tree.html#a1bf5c8818c843265c74ad3a2df6a09fa">closest_element</a> (const point_t &amp;point) const</td></tr>
<tr class="memdesc:a1bf5c8818c843265c74ad3a2df6a09fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds the closest tree-element to a given point in space  <a href="classug_1_1_k_d_tree.html#a1bf5c8818c843265c74ad3a2df6a09fa">More...</a><br /></td></tr>
<tr class="separator:a1bf5c8818c843265c74ad3a2df6a09fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82df228ae635b5a23bf31264f8c32127"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_k_d_tree.html#a82df228ae635b5a23bf31264f8c32127">closest_elements</a> (vector&lt; <a class="el" href="classug_1_1_k_d_tree_1_1_element.html">Element</a> &gt; &amp;elemsOut, const point_t &amp;point, size_t n) const</td></tr>
<tr class="memdesc:a82df228ae635b5a23bf31264f8c32127"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the n closest tree-elements to a given point in space  <a href="classug_1_1_k_d_tree.html#a82df228ae635b5a23bf31264f8c32127">More...</a><br /></td></tr>
<tr class="separator:a82df228ae635b5a23bf31264f8c32127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b87c45ce270ba12951b6f5924186699"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_k_d_tree.html#a4b87c45ce270ba12951b6f5924186699">empty</a> () const</td></tr>
<tr class="memdesc:a4b87c45ce270ba12951b6f5924186699"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if the tree is empty  <a href="classug_1_1_k_d_tree.html#a4b87c45ce270ba12951b6f5924186699">More...</a><br /></td></tr>
<tr class="separator:a4b87c45ce270ba12951b6f5924186699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21cb724cedb7114836b361b887bf7c99"><td class="memItemLeft" align="right" valign="top">real_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_k_d_tree.html#a21cb724cedb7114836b361b887bf7c99">estimate_balance_quality</a> ()</td></tr>
<tr class="memdesc:a21cb724cedb7114836b361b887bf7c99"><td class="mdescLeft">&#160;</td><td class="mdescRight">estimates the balance quality of the tree in the range [0, 1].  <a href="classug_1_1_k_d_tree.html#a21cb724cedb7114836b361b887bf7c99">More...</a><br /></td></tr>
<tr class="separator:a21cb724cedb7114836b361b887bf7c99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01aba0e3a62472f03de8b44c5fe04427"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_k_d_tree.html#a01aba0e3a62472f03de8b44c5fe04427">num_delayed_elements</a> () const</td></tr>
<tr class="memdesc:a01aba0e3a62472f03de8b44c5fe04427"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the number of elements which are scheduled for delayed insertion  <a href="classug_1_1_k_d_tree.html#a01aba0e3a62472f03de8b44c5fe04427">More...</a><br /></td></tr>
<tr class="separator:a01aba0e3a62472f03de8b44c5fe04427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b8d50202a2d66975fc24a2d2fbc8580"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_k_d_tree.html#a5b8d50202a2d66975fc24a2d2fbc8580">rebalance</a> ()</td></tr>
<tr class="memdesc:a5b8d50202a2d66975fc24a2d2fbc8580"><td class="mdescLeft">&#160;</td><td class="mdescRight">rebalances the whole tree  <a href="classug_1_1_k_d_tree.html#a5b8d50202a2d66975fc24a2d2fbc8580">More...</a><br /></td></tr>
<tr class="separator:a5b8d50202a2d66975fc24a2d2fbc8580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43e78b57945e2cac939b1b7be006769"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_k_d_tree.html#ad43e78b57945e2cac939b1b7be006769">set_desc</a> (const <a class="el" href="structug_1_1_k_d_tree_desc.html">KDTreeDesc</a> &amp;desc)</td></tr>
<tr class="memdesc:ad43e78b57945e2cac939b1b7be006769"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the balancing-parameters of the tree. Triggers a rebalance if a value changed.  <a href="classug_1_1_k_d_tree.html#ad43e78b57945e2cac939b1b7be006769">More...</a><br /></td></tr>
<tr class="separator:ad43e78b57945e2cac939b1b7be006769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63170fd6a4d9bf72b1854ed71b829aec"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_k_d_tree.html#a63170fd6a4d9bf72b1854ed71b829aec">size</a> () const</td></tr>
<tr class="memdesc:a63170fd6a4d9bf72b1854ed71b829aec"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the number of elements in the tree  <a href="classug_1_1_k_d_tree.html#a63170fd6a4d9bf72b1854ed71b829aec">More...</a><br /></td></tr>
<tr class="separator:a63170fd6a4d9bf72b1854ed71b829aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a9059bdf5e1c9ecd559f1a8faa9f49059"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_k_d_tree.html#a9059bdf5e1c9ecd559f1a8faa9f49059">find_leaf_node</a> (const point_t &amp;point)</td></tr>
<tr class="memdesc:a9059bdf5e1c9ecd559f1a8faa9f49059"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns an index to the leaf-node which contains the given point  <a href="classug_1_1_k_d_tree.html#a9059bdf5e1c9ecd559f1a8faa9f49059">More...</a><br /></td></tr>
<tr class="separator:a9059bdf5e1c9ecd559f1a8faa9f49059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70cae3b7be2c208bdd71cd645627d34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_k_d_tree.html#af70cae3b7be2c208bdd71cd645627d34">split_leaf_node</a> (<a class="el" href="structug_1_1_k_d_tree_1_1_node.html">Node</a> &amp;node)</td></tr>
<tr class="memdesc:af70cae3b7be2c208bdd71cd645627d34"><td class="mdescLeft">&#160;</td><td class="mdescRight">splits a node into two child nodes and assigns elements to those children.  <a href="classug_1_1_k_d_tree.html#af70cae3b7be2c208bdd71cd645627d34">More...</a><br /></td></tr>
<tr class="separator:af70cae3b7be2c208bdd71cd645627d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a7b50ef201cc8892d4922d4a389c319da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structug_1_1_k_d_tree_desc.html">KDTreeDesc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_k_d_tree.html#a7b50ef201cc8892d4922d4a389c319da">m_desc</a></td></tr>
<tr class="separator:a7b50ef201cc8892d4922d4a389c319da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aa279c1dc6ea0ceef800909d0f6dcad"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classug_1_1_k_d_tree_1_1_element.html">Element</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_k_d_tree.html#a2aa279c1dc6ea0ceef800909d0f6dcad">m_elements</a></td></tr>
<tr class="separator:a2aa279c1dc6ea0ceef800909d0f6dcad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad320dc0128a6196222865b13b570ea3f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structug_1_1_k_d_tree_1_1_node.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_k_d_tree.html#ad320dc0128a6196222865b13b570ea3f">m_nodes</a></td></tr>
<tr class="memdesc:ad320dc0128a6196222865b13b570ea3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">m_nodes[0] is always considered to be the root node.  <a href="classug_1_1_k_d_tree.html#ad320dc0128a6196222865b13b570ea3f">More...</a><br /></td></tr>
<tr class="separator:ad320dc0128a6196222865b13b570ea3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79c15b6d0f005f04d87fdc6508d9ee75"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_k_d_tree.html#a79c15b6d0f005f04d87fdc6508d9ee75">m_numDelayedElements</a></td></tr>
<tr class="separator:a79c15b6d0f005f04d87fdc6508d9ee75"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class point_t, class data_t, class real_t = float&gt;<br />
class ug::KDTree&lt; point_t, data_t, real_t &gt;</h3>

<p>JUST AN EARLY MOCKUP - no implementation is yet provided... A <a class="el" href="classug_1_1_k_d_tree.html">KDTree</a> is a space-partitioning tree which </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a3c8e3e03820206996554bcade62c4d80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c8e3e03820206996554bcade62c4d80">&#9670;&nbsp;</a></span>add_element()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class point_t , class data_t , class real_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classug_1_1_k_d_tree.html">ug::KDTree</a>&lt; point_t, data_t, real_t &gt;::add_element </td>
          <td>(</td>
          <td class="paramtype">const point_t &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const data_t &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>delayInsertion</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>adds an element to the tree. </p>
<p>If 'delayInsertion' is disabled (disabled by default), elements are inserted into their corresponding nodes on the fly. If the node's splitThreshold is surpassed, the elements of that node will be sorted into new child nodes automatically. Note that this may result in an unbalanced tree. You may call rebalance to reorder elements to receive a balanced tree. Alternatively you may add_element with 'delayInsertion = true'. All those elements will be collected and won't be inserted into the tree until rebalance is called. </p>

</div>
</div>
<a id="a1bf5c8818c843265c74ad3a2df6a09fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bf5c8818c843265c74ad3a2df6a09fa">&#9670;&nbsp;</a></span>closest_element()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class point_t , class data_t , class real_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classug_1_1_k_d_tree_1_1_element.html">Element</a> <a class="el" href="classug_1_1_k_d_tree.html">ug::KDTree</a>&lt; point_t, data_t, real_t &gt;::closest_element </td>
          <td>(</td>
          <td class="paramtype">const point_t &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds the closest tree-element to a given point in space </p>
<dl class="section note"><dt>Note</dt><dd>If the tree is empty, an std::runtime_error will be thrown. </dd>
<dd>
The method call </dd></dl>

</div>
</div>
<a id="a82df228ae635b5a23bf31264f8c32127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82df228ae635b5a23bf31264f8c32127">&#9670;&nbsp;</a></span>closest_elements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class point_t , class data_t , class real_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classug_1_1_k_d_tree.html">ug::KDTree</a>&lt; point_t, data_t, real_t &gt;::closest_elements </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="classug_1_1_k_d_tree_1_1_element.html">Element</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>elemsOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const point_t &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the n closest tree-elements to a given point in space </p>
<dl class="section note"><dt>Note</dt><dd>when the method is done, elemsOut will have the size min(KDTree::size(), n). </dd></dl>

</div>
</div>
<a id="a4b87c45ce270ba12951b6f5924186699"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b87c45ce270ba12951b6f5924186699">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class point_t , class data_t , class real_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classug_1_1_k_d_tree.html">ug::KDTree</a>&lt; point_t, data_t, real_t &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns true if the tree is empty </p>

</div>
</div>
<a id="a21cb724cedb7114836b361b887bf7c99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21cb724cedb7114836b361b887bf7c99">&#9670;&nbsp;</a></span>estimate_balance_quality()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class point_t , class data_t , class real_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">real_t <a class="el" href="classug_1_1_k_d_tree.html">ug::KDTree</a>&lt; point_t, data_t, real_t &gt;::estimate_balance_quality </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>estimates the balance quality of the tree in the range [0, 1]. </p>
<p>The returned value represents the ratio to the smallest leaf (lowest level and smallest number of elements) to the maximum number of elements, that a node on the same level and its children have. </p>

</div>
</div>
<a id="a9059bdf5e1c9ecd559f1a8faa9f49059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9059bdf5e1c9ecd559f1a8faa9f49059">&#9670;&nbsp;</a></span>find_leaf_node()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class point_t , class data_t , class real_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classug_1_1_k_d_tree.html">ug::KDTree</a>&lt; point_t, data_t, real_t &gt;::find_leaf_node </td>
          <td>(</td>
          <td class="paramtype">const point_t &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns an index to the leaf-node which contains the given point </p>

</div>
</div>
<a id="a01aba0e3a62472f03de8b44c5fe04427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01aba0e3a62472f03de8b44c5fe04427">&#9670;&nbsp;</a></span>num_delayed_elements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class point_t , class data_t , class real_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classug_1_1_k_d_tree.html">ug::KDTree</a>&lt; point_t, data_t, real_t &gt;::num_delayed_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the number of elements which are scheduled for delayed insertion </p>
<dl class="section note"><dt>Note</dt><dd>delayed elements are inserted on a call to rebalance. </dd></dl>

</div>
</div>
<a id="a5b8d50202a2d66975fc24a2d2fbc8580"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b8d50202a2d66975fc24a2d2fbc8580">&#9670;&nbsp;</a></span>rebalance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class point_t , class data_t , class real_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classug_1_1_k_d_tree.html">ug::KDTree</a>&lt; point_t, data_t, real_t &gt;::rebalance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>rebalances the whole tree </p>

</div>
</div>
<a id="ad43e78b57945e2cac939b1b7be006769"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad43e78b57945e2cac939b1b7be006769">&#9670;&nbsp;</a></span>set_desc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class point_t , class data_t , class real_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classug_1_1_k_d_tree.html">ug::KDTree</a>&lt; point_t, data_t, real_t &gt;::set_desc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structug_1_1_k_d_tree_desc.html">KDTreeDesc</a> &amp;&#160;</td>
          <td class="paramname"><em>desc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sets the balancing-parameters of the tree. Triggers a rebalance if a value changed. </p>

</div>
</div>
<a id="a63170fd6a4d9bf72b1854ed71b829aec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63170fd6a4d9bf72b1854ed71b829aec">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class point_t , class data_t , class real_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classug_1_1_k_d_tree.html">ug::KDTree</a>&lt; point_t, data_t, real_t &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the number of elements in the tree </p>

</div>
</div>
<a id="af70cae3b7be2c208bdd71cd645627d34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af70cae3b7be2c208bdd71cd645627d34">&#9670;&nbsp;</a></span>split_leaf_node()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class point_t , class data_t , class real_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classug_1_1_k_d_tree.html">ug::KDTree</a>&lt; point_t, data_t, real_t &gt;::split_leaf_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structug_1_1_k_d_tree_1_1_node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>splits a node into two child nodes and assigns elements to those children. </p>
<p>If the node-threshold of a child node is surpassed, then the child will be splitted recursively. Make sure that the given node is a leaf node and thus hasn't got children. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a7b50ef201cc8892d4922d4a389c319da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b50ef201cc8892d4922d4a389c319da">&#9670;&nbsp;</a></span>m_desc</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class point_t , class data_t , class real_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structug_1_1_k_d_tree_desc.html">KDTreeDesc</a> <a class="el" href="classug_1_1_k_d_tree.html">ug::KDTree</a>&lt; point_t, data_t, real_t &gt;::m_desc</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2aa279c1dc6ea0ceef800909d0f6dcad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aa279c1dc6ea0ceef800909d0f6dcad">&#9670;&nbsp;</a></span>m_elements</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class point_t , class data_t , class real_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classug_1_1_k_d_tree_1_1_element.html">Element</a>&gt; <a class="el" href="classug_1_1_k_d_tree.html">ug::KDTree</a>&lt; point_t, data_t, real_t &gt;::m_elements</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad320dc0128a6196222865b13b570ea3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad320dc0128a6196222865b13b570ea3f">&#9670;&nbsp;</a></span>m_nodes</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class point_t , class data_t , class real_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structug_1_1_k_d_tree_1_1_node.html">Node</a>&gt; <a class="el" href="classug_1_1_k_d_tree.html">ug::KDTree</a>&lt; point_t, data_t, real_t &gt;::m_nodes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>m_nodes[0] is always considered to be the root node. </p>

</div>
</div>
<a id="a79c15b6d0f005f04d87fdc6508d9ee75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79c15b6d0f005f04d87fdc6508d9ee75">&#9670;&nbsp;</a></span>m_numDelayedElements</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class point_t , class data_t , class real_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classug_1_1_k_d_tree.html">ug::KDTree</a>&lt; point_t, data_t, real_t &gt;::m_numDelayedElements</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>ugbase/common/space_partitioning/<a class="el" href="kd__tree_8h_source.html">kd_tree.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceug.html">ug</a></li><li class="navelem"><a class="el" href="classug_1_1_k_d_tree.html">KDTree</a></li>
    <li class="footer">Generated on Mon Apr 17 2023 01:01:41 for ug4 by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
