<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ug4: edge util</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ug4
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__lib__grid__algorithms__edge__util.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">edge util<div class="ingroups"><a class="el" href="group__lib__grid.html">lib_grid</a> &raquo; <a class="el" href="group__lib__grid__algorithms.html">algorithms</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>contains methods to manipulate edges  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga4bb56348bfa70c7a5760f20a6bc2963b"><td class="memTemplParams" colspan="2">template&lt;class TAAPosVRT &gt; </td></tr>
<tr class="memitem:ga4bb56348bfa70c7a5760f20a6bc2963b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__edge__util.html#ga4bb56348bfa70c7a5760f20a6bc2963b">ug::CalculateAverageEdgeLength</a> (<a class="el" href="classug_1_1_grid.html">Grid</a> &amp;grid, TAAPosVRT &amp;aaPos)</td></tr>
<tr class="memdesc:ga4bb56348bfa70c7a5760f20a6bc2963b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the average length of edges in the given grid.  <a href="group__lib__grid__algorithms__edge__util.html#ga4bb56348bfa70c7a5760f20a6bc2963b">More...</a><br /></td></tr>
<tr class="separator:ga4bb56348bfa70c7a5760f20a6bc2963b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13347b068653f9addb2fc2ccf1aba4f1"><td class="memTemplParams" colspan="2">template&lt;class TVertexPositionAttachmentAccessor &gt; </td></tr>
<tr class="memitem:ga13347b068653f9addb2fc2ccf1aba4f1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> TVertexPositionAttachmentAccessor::ValueType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__edge__util.html#ga13347b068653f9addb2fc2ccf1aba4f1">ug::CalculateCenter</a> (const <a class="el" href="classug_1_1_edge.html">Edge</a> *e, TVertexPositionAttachmentAccessor &amp;aaPosVRT)</td></tr>
<tr class="memdesc:ga13347b068653f9addb2fc2ccf1aba4f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the center of an edge.  <a href="group__lib__grid__algorithms__edge__util.html#ga13347b068653f9addb2fc2ccf1aba4f1">More...</a><br /></td></tr>
<tr class="separator:ga13347b068653f9addb2fc2ccf1aba4f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga352532e6dd0af093674471d36257479e"><td class="memTemplParams" colspan="2">template&lt;class TAAPosVRT , class TAAWeightVRT &gt; </td></tr>
<tr class="memitem:ga352532e6dd0af093674471d36257479e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> TAAPosVRT::ValueType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__edge__util.html#ga352532e6dd0af093674471d36257479e">ug::CalculateCenter</a> (const <a class="el" href="classug_1_1_edge_vertices.html">EdgeVertices</a> *e, TAAPosVRT &amp;aaPos, TAAWeightVRT &amp;aaWeight)</td></tr>
<tr class="memdesc:ga352532e6dd0af093674471d36257479e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the weighted center of the vertices of the given edge  <a href="group__lib__grid__algorithms__edge__util.html#ga352532e6dd0af093674471d36257479e">More...</a><br /></td></tr>
<tr class="separator:ga352532e6dd0af093674471d36257479e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47d8d9dc1634d72a7500de9fe2e1f7a3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__edge__util.html#ga47d8d9dc1634d72a7500de9fe2e1f7a3">ug::CalculateNormal</a> (<a class="el" href="group__vectors.html#ga894cdb8af74f7a563a94fb49c220fdcd">vector3</a> &amp;vNormOut, <a class="el" href="classug_1_1_grid.html">Grid</a> &amp;grid, <a class="el" href="classug_1_1_edge.html">Edge</a> *e, <a class="el" href="classug_1_1_grid_1_1_attachment_accessor.html">Grid::AttachmentAccessor</a>&lt; <a class="el" href="classug_1_1_vertex.html">Vertex</a>, <a class="el" href="namespaceug.html#a780dd3524b97269f891365fd3c3b895a">APosition</a> &gt; &amp;aaPos, <a class="el" href="classug_1_1_grid_1_1_attachment_accessor.html">Grid::AttachmentAccessor</a>&lt; <a class="el" href="classug_1_1_face.html">Face</a>, <a class="el" href="namespaceug.html#a971c52fec411990d2bfb6ee27dbb0232">ANormal</a> &gt; *paaNormFACE=NULL)</td></tr>
<tr class="memdesc:ga47d8d9dc1634d72a7500de9fe2e1f7a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the normal of the given edge.  <a href="group__lib__grid__algorithms__edge__util.html#ga47d8d9dc1634d72a7500de9fe2e1f7a3">More...</a><br /></td></tr>
<tr class="separator:ga47d8d9dc1634d72a7500de9fe2e1f7a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1a37eb30f8e26ad848d0aa2f79a81d1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__edge__util.html#gae1a37eb30f8e26ad848d0aa2f79a81d1">ug::CalculateNormalNoNormalize</a> (<a class="el" href="group__vectors.html#ga894cdb8af74f7a563a94fb49c220fdcd">vector3</a> &amp;vNormOut, <a class="el" href="classug_1_1_grid.html">Grid</a> &amp;grid, <a class="el" href="classug_1_1_edge.html">Edge</a> *e, <a class="el" href="classug_1_1_grid_1_1_vertex_attachment_accessor.html">Grid::VertexAttachmentAccessor</a>&lt; <a class="el" href="namespaceug.html#a780dd3524b97269f891365fd3c3b895a">APosition</a> &gt; &amp;aaPos, <a class="el" href="classug_1_1_grid_1_1_face_attachment_accessor.html">Grid::FaceAttachmentAccessor</a>&lt; <a class="el" href="namespaceug.html#a971c52fec411990d2bfb6ee27dbb0232">ANormal</a> &gt; *paaNormFACE=NULL)</td></tr>
<tr class="memdesc:gae1a37eb30f8e26ad848d0aa2f79a81d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the normal of the given edge.  <a href="group__lib__grid__algorithms__edge__util.html#gae1a37eb30f8e26ad848d0aa2f79a81d1">More...</a><br /></td></tr>
<tr class="separator:gae1a37eb30f8e26ad848d0aa2f79a81d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c12f2972755f9635e2834b0d954ead2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__edge__util.html#ga2c12f2972755f9635e2834b0d954ead2">ug::CollapseEdge</a> (<a class="el" href="classug_1_1_grid.html">Grid</a> &amp;grid, <a class="el" href="classug_1_1_edge.html">Edge</a> *e, <a class="el" href="classug_1_1_vertex.html">Vertex</a> *newVrt)</td></tr>
<tr class="memdesc:ga2c12f2972755f9635e2834b0d954ead2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collapses the specified edge performs local grid restructuring.  <a href="group__lib__grid__algorithms__edge__util.html#ga2c12f2972755f9635e2834b0d954ead2">More...</a><br /></td></tr>
<tr class="separator:ga2c12f2972755f9635e2834b0d954ead2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafca790d4845369d2f52a21fe80685aa0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__edge__util.html#gafca790d4845369d2f52a21fe80685aa0">ug::CompareVertices</a> (const <a class="el" href="classug_1_1_edge_vertices.html">EdgeVertices</a> *ev1, const <a class="el" href="classug_1_1_edge_vertices.html">EdgeVertices</a> *ev2)</td></tr>
<tr class="memdesc:gafca790d4845369d2f52a21fe80685aa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether ev1 and ev2 contain the same vertices.  <a href="group__lib__grid__algorithms__edge__util.html#gafca790d4845369d2f52a21fe80685aa0">More...</a><br /></td></tr>
<tr class="separator:gafca790d4845369d2f52a21fe80685aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed91ccbc1b4b95c2ef09c3f79aabd6ab"><td class="memTemplParams" colspan="2">template&lt;class vector_t , class TAAPos &gt; </td></tr>
<tr class="memitem:gaed91ccbc1b4b95c2ef09c3f79aabd6ab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__edge__util.html#gaed91ccbc1b4b95c2ef09c3f79aabd6ab">ug::ContainsPoint</a> (const <a class="el" href="classug_1_1_edge_vertices.html">EdgeVertices</a> *e, const vector_t &amp;<a class="elRef" href="../plugins/_biogas_8lua.html#a57f1028d958bb73c4e3c64e2077342fc">p</a>, TAAPos aaPos)</td></tr>
<tr class="memdesc:gaed91ccbc1b4b95c2ef09c3f79aabd6ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given point lies on the given edge.  <a href="group__lib__grid__algorithms__edge__util.html#gaed91ccbc1b4b95c2ef09c3f79aabd6ab">More...</a><br /></td></tr>
<tr class="separator:gaed91ccbc1b4b95c2ef09c3f79aabd6ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga510e2902b9bf9775fcd178289e616cec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__edge__util.html#ga510e2902b9bf9775fcd178289e616cec">ug::CreateEdgeSplitGeometry</a> (<a class="el" href="classug_1_1_grid.html">Grid</a> &amp;destGrid, <a class="el" href="classug_1_1_grid.html">Grid</a> &amp;srcGrid, <a class="el" href="classug_1_1_edge.html">Edge</a> *e, <a class="el" href="classug_1_1_vertex.html">Vertex</a> *newVertex, <a class="el" href="namespaceug.html#a52072c4f65a25351aa2f5f0d6285722b">AVertex</a> *paAssociatedVertices=NULL)</td></tr>
<tr class="memdesc:ga510e2902b9bf9775fcd178289e616cec"><td class="mdescLeft">&#160;</td><td class="mdescRight">given an edge and a vertex (the split-vertex) this method constructs the split-geometry.  <a href="group__lib__grid__algorithms__edge__util.html#ga510e2902b9bf9775fcd178289e616cec">More...</a><br /></td></tr>
<tr class="separator:ga510e2902b9bf9775fcd178289e616cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d08da8a4c117456ba10f1e2809ffee7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__edge__util.html#ga8d08da8a4c117456ba10f1e2809ffee7">ug::CutEdgesWithPlane</a> (<a class="el" href="classug_1_1_selector.html">Selector</a> &amp;sel, const <a class="el" href="group__vectors.html#ga894cdb8af74f7a563a94fb49c220fdcd">vector3</a> &amp;<a class="elRef" href="../plugins/_biogas_8lua.html#a57f1028d958bb73c4e3c64e2077342fc">p</a>, const <a class="el" href="group__vectors.html#ga894cdb8af74f7a563a94fb49c220fdcd">vector3</a> &amp;n, <a class="el" href="namespaceug.html#a780dd3524b97269f891365fd3c3b895a">APosition</a> &amp;aPos=<a class="el" href="namespaceug.html#aab0e1fda11d3738fd1e7197eece81576">aPosition</a>)</td></tr>
<tr class="memdesc:ga8d08da8a4c117456ba10f1e2809ffee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">refines all edges in sel which cut the given plane.  <a href="group__lib__grid__algorithms__edge__util.html#ga8d08da8a4c117456ba10f1e2809ffee7">More...</a><br /></td></tr>
<tr class="separator:ga8d08da8a4c117456ba10f1e2809ffee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f7b8169cfae5eb50fc502401c9d8fde"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__edge__util.html#ga9f7b8169cfae5eb50fc502401c9d8fde">ug::EdgeCollapseIsValid</a> (<a class="el" href="classug_1_1_grid.html">Grid</a> &amp;grid, <a class="el" href="classug_1_1_edge.html">Edge</a> *e)</td></tr>
<tr class="memdesc:ga9f7b8169cfae5eb50fc502401c9d8fde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an edge-collapse would invalidate the current topology.  <a href="group__lib__grid__algorithms__edge__util.html#ga9f7b8169cfae5eb50fc502401c9d8fde">More...</a><br /></td></tr>
<tr class="separator:ga9f7b8169cfae5eb50fc502401c9d8fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cce38c830ab3f7e4257d0e62f690868"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__edge__util.html#ga0cce38c830ab3f7e4257d0e62f690868">ug::EdgeContains</a> (<a class="el" href="classug_1_1_edge_vertices.html">EdgeVertices</a> *e, <a class="el" href="classug_1_1_vertex.html">Vertex</a> *vrt)</td></tr>
<tr class="separator:ga0cce38c830ab3f7e4257d0e62f690868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4fb5bde4a2e3622e87abeab48c06b12"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__edge__util.html#gaf4fb5bde4a2e3622e87abeab48c06b12">ug::EdgeContains</a> (<a class="el" href="classug_1_1_edge_vertices.html">EdgeVertices</a> *e, <a class="el" href="classug_1_1_vertex.html">Vertex</a> *vrt1, <a class="el" href="classug_1_1_vertex.html">Vertex</a> *vrt2)</td></tr>
<tr class="separator:gaf4fb5bde4a2e3622e87abeab48c06b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae641a616a9dade33b7435c7e1f98fe0d"><td class="memTemplParams" colspan="2">template&lt;class TAAPosVRT &gt; </td></tr>
<tr class="memitem:gae641a616a9dade33b7435c7e1f98fe0d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> <a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__edge__util.html#gae641a616a9dade33b7435c7e1f98fe0d">ug::EdgeLength</a> (const <a class="el" href="classug_1_1_edge_vertices.html">EdgeVertices</a> *e, TAAPosVRT &amp;aaPos)</td></tr>
<tr class="memdesc:gae641a616a9dade33b7435c7e1f98fe0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the length of the given edge.  <a href="group__lib__grid__algorithms__edge__util.html#gae641a616a9dade33b7435c7e1f98fe0d">More...</a><br /></td></tr>
<tr class="separator:gae641a616a9dade33b7435c7e1f98fe0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ac3258a67343fc5e0dec267bb84d33d"><td class="memTemplParams" colspan="2">template&lt;class TAAPosVRT &gt; </td></tr>
<tr class="memitem:ga9ac3258a67343fc5e0dec267bb84d33d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> <a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__edge__util.html#ga9ac3258a67343fc5e0dec267bb84d33d">ug::EdgeLengthSq</a> (const <a class="el" href="classug_1_1_edge_vertices.html">EdgeVertices</a> *e, TAAPosVRT &amp;aaPos)</td></tr>
<tr class="memdesc:ga9ac3258a67343fc5e0dec267bb84d33d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the squared length of the given edge.  <a href="group__lib__grid__algorithms__edge__util.html#ga9ac3258a67343fc5e0dec267bb84d33d">More...</a><br /></td></tr>
<tr class="separator:ga9ac3258a67343fc5e0dec267bb84d33d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b6139da5c102d916b7e919b8f5ad501"><td class="memTemplParams" colspan="2">template&lt;class TEdgeIterator , class TAAPosVRT &gt; </td></tr>
<tr class="memitem:ga5b6139da5c102d916b7e919b8f5ad501"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> <a class="el" href="classug_1_1_edge.html">Edge</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__edge__util.html#ga5b6139da5c102d916b7e919b8f5ad501">ug::FindShortestEdge</a> (TEdgeIterator edgesBegin, TEdgeIterator edgesEnd, TAAPosVRT &amp;aaPos)</td></tr>
<tr class="memdesc:ga5b6139da5c102d916b7e919b8f5ad501"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the shortest edge in a list of edges.  <a href="group__lib__grid__algorithms__edge__util.html#ga5b6139da5c102d916b7e919b8f5ad501">More...</a><br /></td></tr>
<tr class="separator:ga5b6139da5c102d916b7e919b8f5ad501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab71f0105ef482356bab57a65bc535624"><td class="memTemplParams" colspan="2">template&lt;class TEdgeIterator &gt; </td></tr>
<tr class="memitem:gab71f0105ef482356bab57a65bc535624"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__edge__util.html#gab71f0105ef482356bab57a65bc535624">ug::FixEdgeOrientation</a> (<a class="el" href="classug_1_1_grid.html">Grid</a> &amp;grid, TEdgeIterator edgesBegin, TEdgeIterator edgesEnd)</td></tr>
<tr class="memdesc:gab71f0105ef482356bab57a65bc535624"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates uniform orientation of neighboured edges.  <a href="group__lib__grid__algorithms__edge__util.html#gab71f0105ef482356bab57a65bc535624">More...</a><br /></td></tr>
<tr class="separator:gab71f0105ef482356bab57a65bc535624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6530a13a5990c960cfd2f1f066e0be8c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__edge__util.html#ga6530a13a5990c960cfd2f1f066e0be8c">ug::GetAssociatedFaces</a> (<a class="el" href="classug_1_1_face.html">Face</a> **facesOut, <a class="el" href="classug_1_1_grid.html">Grid</a> &amp;grid, <a class="el" href="classug_1_1_edge.html">Edge</a> *e, int maxNumFaces)</td></tr>
<tr class="memdesc:ga6530a13a5990c960cfd2f1f066e0be8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">writes associated faces of e to facesOut.  <a href="group__lib__grid__algorithms__edge__util.html#ga6530a13a5990c960cfd2f1f066e0be8c">More...</a><br /></td></tr>
<tr class="separator:ga6530a13a5990c960cfd2f1f066e0be8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8adcbaa5a7de0382231d8d2a058a362"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classug_1_1_edge.html">Edge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__edge__util.html#gac8adcbaa5a7de0382231d8d2a058a362">ug::GetConnectingEdge</a> (<a class="el" href="classug_1_1_grid.html">Grid</a> &amp;grid, <a class="el" href="classug_1_1_face.html">Face</a> *f1, <a class="el" href="classug_1_1_face.html">Face</a> *f2)</td></tr>
<tr class="separator:gac8adcbaa5a7de0382231d8d2a058a362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1630d8ea9135b8305a86bdece82d93f0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__edge__util.html#ga1630d8ea9135b8305a86bdece82d93f0">ug::GetEdgeIndex</a> (<a class="el" href="classug_1_1_face.html">Face</a> *f, <a class="el" href="classug_1_1_edge.html">Edge</a> *e)</td></tr>
<tr class="memdesc:ga1630d8ea9135b8305a86bdece82d93f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the index at which edge e is found in the given object  <a href="group__lib__grid__algorithms__edge__util.html#ga1630d8ea9135b8305a86bdece82d93f0">More...</a><br /></td></tr>
<tr class="separator:ga1630d8ea9135b8305a86bdece82d93f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c5fb5c0a5f5a045c6a3a6fa54efd4c0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__edge__util.html#ga7c5fb5c0a5f5a045c6a3a6fa54efd4c0">ug::GetEdgeIndex</a> (<a class="el" href="classug_1_1_volume.html">Volume</a> *vol, <a class="el" href="classug_1_1_edge.html">Edge</a> *e)</td></tr>
<tr class="memdesc:ga7c5fb5c0a5f5a045c6a3a6fa54efd4c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the index at which edge e is found in the given object  <a href="group__lib__grid__algorithms__edge__util.html#ga7c5fb5c0a5f5a045c6a3a6fa54efd4c0">More...</a><br /></td></tr>
<tr class="separator:ga7c5fb5c0a5f5a045c6a3a6fa54efd4c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga346c8f5ab191aa2d3b10f2932871b37f"><td class="memTemplParams" colspan="2">template&lt;class face_iter_t &gt; </td></tr>
<tr class="memitem:ga346c8f5ab191aa2d3b10f2932871b37f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__edge__util.html#ga346c8f5ab191aa2d3b10f2932871b37f">ug::GetInnerEdgesOfFaceSoup</a> (std::vector&lt; <a class="el" href="classug_1_1_edge.html">Edge</a> * &gt; &amp;edgesOut, <a class="el" href="classug_1_1_grid.html">Grid</a> &amp;g, face_iter_t facesBegin, face_iter_t facesEnd)</td></tr>
<tr class="separator:ga346c8f5ab191aa2d3b10f2932871b37f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5dbcb9d97d82202a72209f0ee92eacc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classug_1_1_vertex.html">Vertex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__edge__util.html#ga5dbcb9d97d82202a72209f0ee92eacc0">ug::GetVertex</a> (<a class="el" href="classug_1_1_edge.html">Edge</a> *e, size_t i)</td></tr>
<tr class="memdesc:ga5dbcb9d97d82202a72209f0ee92eacc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the i'th vertex of an edge  <a href="group__lib__grid__algorithms__edge__util.html#ga5dbcb9d97d82202a72209f0ee92eacc0">More...</a><br /></td></tr>
<tr class="separator:ga5dbcb9d97d82202a72209f0ee92eacc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0565ea76771097bfbd142f02cea7adb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__edge__util.html#gac0565ea76771097bfbd142f02cea7adb">ug::IsBoundaryEdge</a> (<a class="el" href="classug_1_1_grid.html">Grid</a> &amp;grid, <a class="el" href="classug_1_1_edge.html">Edge</a> *e, <a class="el" href="structug_1_1_grid_1_1traits.html#a1bd114991c12becc6ca48862967dd9f2">Grid::face_traits::callback</a> funcIsSurfFace)</td></tr>
<tr class="memdesc:gac0565ea76771097bfbd142f02cea7adb"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if the edge is connected to exactly one surface face.  <a href="group__lib__grid__algorithms__edge__util.html#gac0565ea76771097bfbd142f02cea7adb">More...</a><br /></td></tr>
<tr class="separator:gac0565ea76771097bfbd142f02cea7adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bf1afd38411b7139354752323bbd9d4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__edge__util.html#ga5bf1afd38411b7139354752323bbd9d4">ug::IsBoundaryEdge2D</a> (<a class="el" href="classug_1_1_grid.html">Grid</a> &amp;grid, <a class="el" href="classug_1_1_edge.html">Edge</a> *e)</td></tr>
<tr class="memdesc:ga5bf1afd38411b7139354752323bbd9d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns whether an edge lies on the boundary of a 2D grid.  <a href="group__lib__grid__algorithms__edge__util.html#ga5bf1afd38411b7139354752323bbd9d4">More...</a><br /></td></tr>
<tr class="separator:ga5bf1afd38411b7139354752323bbd9d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca999ef2fe108897bf5f89f81493ca48"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__edge__util.html#gaca999ef2fe108897bf5f89f81493ca48">ug::IsBoundaryEdge3D</a> (<a class="el" href="classug_1_1_grid.html">Grid</a> &amp;grid, <a class="el" href="classug_1_1_edge.html">Edge</a> *e)</td></tr>
<tr class="memdesc:gaca999ef2fe108897bf5f89f81493ca48"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns whether an edge lies on the boundary of a 3D grid.  <a href="group__lib__grid__algorithms__edge__util.html#gaca999ef2fe108897bf5f89f81493ca48">More...</a><br /></td></tr>
<tr class="separator:gaca999ef2fe108897bf5f89f81493ca48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga200f74c7905c6e950f95ede32dc3c8df"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__edge__util.html#ga200f74c7905c6e950f95ede32dc3c8df">ug::LiesOnBoundary</a> (<a class="el" href="classug_1_1_grid.html">Grid</a> &amp;grid, <a class="el" href="classug_1_1_edge.html">Edge</a> *e)</td></tr>
<tr class="memdesc:ga200f74c7905c6e950f95ede32dc3c8df"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true, if the edge lies on a 2d or 3d boundary  <a href="group__lib__grid__algorithms__edge__util.html#ga200f74c7905c6e950f95ede32dc3c8df">More...</a><br /></td></tr>
<tr class="separator:ga200f74c7905c6e950f95ede32dc3c8df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga397492a903ffbec777ca5dda0d5be44b"><td class="memTemplParams" colspan="2">template&lt;class EdgeIterator , class TAAPos &gt; </td></tr>
<tr class="memitem:ga397492a903ffbec777ca5dda0d5be44b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__edge__util.html#ga397492a903ffbec777ca5dda0d5be44b">ug::MinimizeEdgeLength_SwapsOnly</a> (<a class="el" href="classug_1_1_grid.html">Grid</a> &amp;grid, <a class="el" href="namespaceug.html#a499d06e0979bcf1e0eec2d93e1cb44ce">EdgeIterator</a> edgesBegin, <a class="el" href="namespaceug.html#a499d06e0979bcf1e0eec2d93e1cb44ce">EdgeIterator</a> edgesEnd, TAAPos &amp;aaPos)</td></tr>
<tr class="memdesc:ga397492a903ffbec777ca5dda0d5be44b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms the given edge-set so that the sum of the length the edges is minimized.  <a href="group__lib__grid__algorithms__edge__util.html#ga397492a903ffbec777ca5dda0d5be44b">More...</a><br /></td></tr>
<tr class="separator:ga397492a903ffbec777ca5dda0d5be44b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44b3d0df416364eaf38104507a6104e7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__edge__util.html#ga44b3d0df416364eaf38104507a6104e7">ug::NumAssociatedFaces</a> (<a class="el" href="classug_1_1_grid.html">Grid</a> &amp;grid, <a class="el" href="classug_1_1_edge.html">Edge</a> *e)</td></tr>
<tr class="memdesc:ga44b3d0df416364eaf38104507a6104e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the number of associated faces of the given edge  <a href="group__lib__grid__algorithms__edge__util.html#ga44b3d0df416364eaf38104507a6104e7">More...</a><br /></td></tr>
<tr class="separator:ga44b3d0df416364eaf38104507a6104e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d1698fc476713187db8d989b4e29580"><td class="memTemplParams" colspan="2">template&lt;class TVertex &gt; </td></tr>
<tr class="memitem:ga5d1698fc476713187db8d989b4e29580"><td class="memTemplItemLeft" align="right" valign="top">TVertex *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__edge__util.html#ga5d1698fc476713187db8d989b4e29580">ug::SplitEdge</a> (<a class="el" href="classug_1_1_grid.html">Grid</a> &amp;destGrid, <a class="el" href="classug_1_1_grid.html">Grid</a> &amp;srcGrid, <a class="el" href="classug_1_1_edge.html">Edge</a> *e, <a class="el" href="namespaceug.html#a52072c4f65a25351aa2f5f0d6285722b">AVertex</a> *paAssociatedVertices=NULL, bool bConservative=false)</td></tr>
<tr class="memdesc:ga5d1698fc476713187db8d989b4e29580"><td class="mdescLeft">&#160;</td><td class="mdescRight">inserts new triangles and one new vertex by splitting the specified edge.  <a href="group__lib__grid__algorithms__edge__util.html#ga5d1698fc476713187db8d989b4e29580">More...</a><br /></td></tr>
<tr class="separator:ga5d1698fc476713187db8d989b4e29580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1dacf3dfd8313a5816f7544e441c685c"><td class="memTemplParams" colspan="2">template&lt;class TVertex &gt; </td></tr>
<tr class="memitem:ga1dacf3dfd8313a5816f7544e441c685c"><td class="memTemplItemLeft" align="right" valign="top">TVertex *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__edge__util.html#ga1dacf3dfd8313a5816f7544e441c685c">ug::SplitEdge</a> (<a class="el" href="classug_1_1_grid.html">Grid</a> &amp;grid, <a class="el" href="classug_1_1_edge.html">Edge</a> *e, bool bConservative=false)</td></tr>
<tr class="memdesc:ga1dacf3dfd8313a5816f7544e441c685c"><td class="mdescLeft">&#160;</td><td class="mdescRight">inserts new triangles and one new vertex by splitting the specified edge.  <a href="group__lib__grid__algorithms__edge__util.html#ga1dacf3dfd8313a5816f7544e441c685c">More...</a><br /></td></tr>
<tr class="separator:ga1dacf3dfd8313a5816f7544e441c685c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga169e3367d738bbc1f3ccf16abcb62d15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classug_1_1_edge.html">Edge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__edge__util.html#ga169e3367d738bbc1f3ccf16abcb62d15">ug::SwapEdge</a> (<a class="el" href="classug_1_1_grid.html">Grid</a> &amp;grid, <a class="el" href="classug_1_1_edge.html">Edge</a> *e)</td></tr>
<tr class="memdesc:ga169e3367d738bbc1f3ccf16abcb62d15"><td class="mdescLeft">&#160;</td><td class="mdescRight">swaps e and thus reconnects its two adjacent triangles.  <a href="group__lib__grid__algorithms__edge__util.html#ga169e3367d738bbc1f3ccf16abcb62d15">More...</a><br /></td></tr>
<tr class="separator:ga169e3367d738bbc1f3ccf16abcb62d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e1d8942c72eeed23cb74ad52711e3f1"><td class="memTemplParams" colspan="2">template&lt;class TEdgeIterator &gt; </td></tr>
<tr class="memitem:ga7e1d8942c72eeed23cb74ad52711e3f1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__edge__util.html#ga7e1d8942c72eeed23cb74ad52711e3f1">ug::AdjustEdgeOrientationToFaceOrientation</a> (<a class="el" href="classug_1_1_grid.html">Grid</a> &amp;grid, TEdgeIterator edgesBegin, TEdgeIterator edgesEnd)</td></tr>
<tr class="memdesc:ga7e1d8942c72eeed23cb74ad52711e3f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Orientates boundary edges in the given edge set to the orientation of associated faces.  <a href="group__lib__grid__algorithms__edge__util.html#ga7e1d8942c72eeed23cb74ad52711e3f1">More...</a><br /></td></tr>
<tr class="separator:ga7e1d8942c72eeed23cb74ad52711e3f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4db6283daf3248ee63b01cedfe70b830"><td class="memTemplParams" colspan="2">template&lt;class TEdgeIterator &gt; </td></tr>
<tr class="memitem:ga4db6283daf3248ee63b01cedfe70b830"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__edge__util.html#ga4db6283daf3248ee63b01cedfe70b830">ug::AdjustEdgeOrientationToFaceOrientation</a> (<a class="el" href="classug_1_1_grid.html">Grid</a> &amp;grid, TEdgeIterator edgesBegin, TEdgeIterator edgesEnd, <a class="el" href="structug_1_1_grid_1_1traits.html#a1bd114991c12becc6ca48862967dd9f2">Grid::face_traits::callback</a> considerFace)</td></tr>
<tr class="memdesc:ga4db6283daf3248ee63b01cedfe70b830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Orientates boundary edges in the given edge set to the orientation of associated faces.  <a href="group__lib__grid__algorithms__edge__util.html#ga4db6283daf3248ee63b01cedfe70b830">More...</a><br /></td></tr>
<tr class="separator:ga4db6283daf3248ee63b01cedfe70b830"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>contains methods to manipulate edges </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga7e1d8942c72eeed23cb74ad52711e3f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e1d8942c72eeed23cb74ad52711e3f1">&#9670;&nbsp;</a></span>AdjustEdgeOrientationToFaceOrientation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TEdgeIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> void ug::AdjustEdgeOrientationToFaceOrientation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid.html">Grid</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TEdgeIterator&#160;</td>
          <td class="paramname"><em>edgesBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TEdgeIterator&#160;</td>
          <td class="paramname"><em>edgesEnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Orientates boundary edges in the given edge set to the orientation of associated faces. </p>
<p>The orientation of boundary edges will match the orientation of associated faces, after this algorithm terminates.</p>
<p>One may optionally specify a callback defines whether a face should be considered during oriantation adjustment. This can e.g. be used if an interior interface has to be oriented. One could select the faces on one side of the interface, select their associated edges (e.g. using CloseSelection) and then call</p>
<div class="fragment"><div class="line">AdjustEdgeOrientationToFaceOrientation(</div>
<div class="line">    grid,</div>
<div class="line">    sel.begin&lt;Edge&gt;(),</div>
<div class="line">    sel.end&lt;Edge&gt;(),</div>
<div class="line">    IsSelected(sel));</div>
</div><!-- fragment --><p>where 'sel' is an instance of the <a class="el" href="classug_1_1_selector.html" title="specialization of ISelector for a grid of class Grid.">Selector</a> class containing the selection performed above. </p>

<p class="reference">References <a class="el" href="namespaceug.html#ad3a9c81a5448666d75346e675adb7f5f">ug::EdgeOrientationMatches()</a>, <a class="el" href="classug_1_1_grid.html#a94546f0aa0a88b0fe61497ee993cf6b7">ug::Grid::flip_orientation()</a>, and <a class="el" href="group__lib__grid__algorithms__edge__util.html#ga6530a13a5990c960cfd2f1f066e0be8c">ug::GetAssociatedFaces()</a>.</p>

</div>
</div>
<a id="ga4db6283daf3248ee63b01cedfe70b830"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4db6283daf3248ee63b01cedfe70b830">&#9670;&nbsp;</a></span>AdjustEdgeOrientationToFaceOrientation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TEdgeIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> void ug::AdjustEdgeOrientationToFaceOrientation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid.html">Grid</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TEdgeIterator&#160;</td>
          <td class="paramname"><em>edgesBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TEdgeIterator&#160;</td>
          <td class="paramname"><em>edgesEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structug_1_1_grid_1_1traits.html#a1bd114991c12becc6ca48862967dd9f2">Grid::face_traits::callback</a>&#160;</td>
          <td class="paramname"><em>considerFace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Orientates boundary edges in the given edge set to the orientation of associated faces. </p>
<p>The orientation of boundary edges will match the orientation of associated faces, after this algorithm terminates.</p>
<p>One may optionally specify a callback defines whether a face should be considered during oriantation adjustment. This can e.g. be used if an interior interface has to be oriented. One could select the faces on one side of the interface, select their associated edges (e.g. using CloseSelection) and then call</p>
<div class="fragment"><div class="line">AdjustEdgeOrientationToFaceOrientation(</div>
<div class="line">    grid,</div>
<div class="line">    sel.begin&lt;Edge&gt;(),</div>
<div class="line">    sel.end&lt;Edge&gt;(),</div>
<div class="line">    IsSelected(sel));</div>
</div><!-- fragment --><p>where 'sel' is an instance of the <a class="el" href="classug_1_1_selector.html" title="specialization of ISelector for a grid of class Grid.">Selector</a> class containing the selection performed above. </p>

<p class="reference">References <a class="el" href="classug_1_1_grid.html#acfb4b5a6a7a0d46df0bdd25bbe55e74b">ug::Grid::associated_elements()</a>, <a class="el" href="namespaceug.html#ad3a9c81a5448666d75346e675adb7f5f">ug::EdgeOrientationMatches()</a>, <a class="el" href="classug_1_1_grid.html#a94546f0aa0a88b0fe61497ee993cf6b7">ug::Grid::flip_orientation()</a>, and <a class="el" href="classug_1_1_pointer_const_array.html#a4f421ad36ddde79f62d80a4f1a633dc0">ug::PointerConstArray&lt; TPtr &gt;::size()</a>.</p>

</div>
</div>
<a id="ga4bb56348bfa70c7a5760f20a6bc2963b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4bb56348bfa70c7a5760f20a6bc2963b">&#9670;&nbsp;</a></span>CalculateAverageEdgeLength()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TAAPosVRT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a> ug::CalculateAverageEdgeLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid.html">Grid</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TAAPosVRT &amp;&#160;</td>
          <td class="paramname"><em>aaPos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the average length of edges in the given grid. </p>
<dl class="section note"><dt>Note</dt><dd>The method works properly, but is not necessarily optimized for speed </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">grid</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classug_1_1_grid.html#ac61deaa5a86f28e8e78fa481467f5d45">ug::Grid::begin()</a>, <a class="el" href="group__lib__grid__algorithms__edge__util.html#gae641a616a9dade33b7435c7e1f98fe0d">ug::EdgeLength()</a>, <a class="el" href="classug_1_1_grid.html#aecec2b9e3e45241347497a58de7aa13a">ug::Grid::end()</a>, and <a class="el" href="classug_1_1_grid.html#ad6ab1515b0c210c91a7262e59d9da2d7">ug::Grid::num_edges()</a>.</p>

</div>
</div>
<a id="ga13347b068653f9addb2fc2ccf1aba4f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga13347b068653f9addb2fc2ccf1aba4f1">&#9670;&nbsp;</a></span>CalculateCenter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TVertexPositionAttachmentAccessor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> TVertexPositionAttachmentAccessor::ValueType ug::CalculateCenter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classug_1_1_edge.html">Edge</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TVertexPositionAttachmentAccessor &amp;&#160;</td>
          <td class="paramname"><em>aaPosVRT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the center of an edge. </p>

<p class="reference">References <a class="el" href="group__vectors.html#ga945c247d94409091fd35fdbbcb5032c2">ug::VecAdd()</a>, <a class="el" href="group__vectors.html#gaa0cd3e6bb61c8e341541f8cf3065ec6d">ug::VecScale()</a>, <a class="el" href="group__vectors.html#ga37c542a5b243f331a1d8bb74d331ba4e">ug::VecSet()</a>, and <a class="el" href="classug_1_1_edge_vertices.html#a0f2ec2644877a1354489544f43c71206">ug::EdgeVertices::vertex()</a>.</p>

</div>
</div>
<a id="ga352532e6dd0af093674471d36257479e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga352532e6dd0af093674471d36257479e">&#9670;&nbsp;</a></span>CalculateCenter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TAAPosVRT , class TAAWeightVRT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> TAAPosVRT::ValueType ug::CalculateCenter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classug_1_1_edge_vertices.html">EdgeVertices</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TAAPosVRT &amp;&#160;</td>
          <td class="paramname"><em>aaPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TAAWeightVRT &amp;&#160;</td>
          <td class="paramname"><em>aaWeight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the weighted center of the vertices of the given edge </p>
<p>TAAWeightVRT has to be an attachment to the vertices of the grid in which e is contained, with ValueType number (or compatible). </p>

<p class="reference">References <a class="el" href="group__vectors.html#gaa0cd3e6bb61c8e341541f8cf3065ec6d">ug::VecScale()</a>, <a class="el" href="group__vectors.html#ga385f702a22b3b6236e783b2bc014f87f">ug::VecScaleAdd()</a>, <a class="el" href="group__vectors.html#ga37c542a5b243f331a1d8bb74d331ba4e">ug::VecSet()</a>, and <a class="el" href="classug_1_1_edge_vertices.html#a0f2ec2644877a1354489544f43c71206">ug::EdgeVertices::vertex()</a>.</p>

</div>
</div>
<a id="ga47d8d9dc1634d72a7500de9fe2e1f7a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47d8d9dc1634d72a7500de9fe2e1f7a3">&#9670;&nbsp;</a></span>CalculateNormal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> int ug::CalculateNormal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__vectors.html#ga894cdb8af74f7a563a94fb49c220fdcd">vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>vNormOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid.html">Grid</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_edge.html">Edge</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid_1_1_attachment_accessor.html">Grid::AttachmentAccessor</a>&lt; <a class="el" href="classug_1_1_vertex.html">Vertex</a>, <a class="el" href="namespaceug.html#a780dd3524b97269f891365fd3c3b895a">APosition</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>aaPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid_1_1_attachment_accessor.html">Grid::AttachmentAccessor</a>&lt; <a class="el" href="classug_1_1_face.html">Face</a>, <a class="el" href="namespaceug.html#a971c52fec411990d2bfb6ee27dbb0232">ANormal</a> &gt; *&#160;</td>
          <td class="paramname"><em>paaNormFACE</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the normal of the given edge. </p>
<p>This method indirectly uses <a class="el" href="classug_1_1_grid.html#a886c89b50e8f2980bfcdf74e65b23683" title="marks the object. Calls are only valid between calls to Grid::begin_marking and Grid::end_marking.">ug::Grid::mark</a>.</p>
<p>The normal is calculated as the normized sum of associated face normals. If there are no associated faces, it is assumed, that the edge lies in the xy plane. Its normal will be calculated to the right.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vNormOut</td><td>normal </td></tr>
    <tr><td class="paramname">grid</td><td><a class="el" href="classug_1_1_grid.html" title="Manages the elements of a grid and their interconnection.">Grid</a> </td></tr>
    <tr><td class="paramname">e</td><td><a class="el" href="classug_1_1_regular_edge.html" title="Edges connect two vertices.">RegularEdge</a> </td></tr>
    <tr><td class="paramname">aaPos</td><td>vertec attachment accessor </td></tr>
    <tr><td class="paramname">paaNormFACE</td><td>An optional parameter that allows to specify an accessor for precalculated face normals.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of faces that are associated with the edge. </dd></dl>

<p class="reference">References <a class="el" href="group__lib__grid__algorithms__edge__util.html#gae1a37eb30f8e26ad848d0aa2f79a81d1">ug::CalculateNormalNoNormalize()</a>, <a class="el" href="group__lib__grid__algorithms__edge__util.html#ga6530a13a5990c960cfd2f1f066e0be8c">ug::GetAssociatedFaces()</a>, <a class="el" href="group__vectors.html#ga945c247d94409091fd35fdbbcb5032c2">ug::VecAdd()</a>, <a class="el" href="group__vectors.html#ga53ae2dda87330ab64fb2a5901606b3e4">ug::VecNormalize()</a>, <a class="el" href="group__vectors.html#ga5c7eda5aeb4cd0d53ce04f682d0a0058">ug::VecSubtract()</a>, and <a class="el" href="classug_1_1_edge_vertices.html#a0f2ec2644877a1354489544f43c71206">ug::EdgeVertices::vertex()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__lib__grid__algorithms__vertex__util.html#ga4c2796a9f87efa8c0cb25f5d8f8e3458">ug::CalculateBoundaryVertexNormal3D()</a>, <a class="el" href="namespaceug.html#ad4308003b1bcbd1af40626d00447bb88">ug::CalculateCreaseNormal()</a>, <a class="el" href="group__lib__grid__algorithms__volume__util.html#gae457b93f51876fc26f1b422d46e8e889">ug::CalculateHexahedronAspectRatio()</a>, <a class="el" href="namespaceug.html#a7a3973b82a0e1cb86deffe76d66c32ad">ug::CalculateMinCurvature()</a>, <a class="el" href="group__lib__grid__algorithms__volume__util.html#ga439e8124095ed0540b516dfaff7959bf">ug::CalculateMinVolumeHeight()</a>, <a class="el" href="namespaceug.html#a79ac852fb9134f96a5fa7ea89e33d477">ug::CalculateNormal()</a>, <a class="el" href="group__lib__grid__algorithms__normal__calculation.html#ga1af4728ce7b74e34cf9371baf3f8a0b1">ug::CalculateOuterNormal()</a>, <a class="el" href="group__lib__grid__algorithms__volume__util.html#ga7593bdd93fe16436972e95d38b3d2134">ug::CalculatePyramidAspectRatio()</a>, <a class="el" href="group__lib__grid__algorithms__vertex__util.html#ga8c98c2d1d058d59c32717dd75d97055c">ug::CalculateVertexNormal()</a>, <a class="el" href="group__lib__grid__algorithms__vertex__util.html#gabe72050ecf543aeda3950e6bd039e402">ug::CalculateVertexNormals()</a>, <a class="el" href="namespaceug.html#a1945715f3a56b2bfa9e5c041c8787a03">ug::CheckOrientation()</a>, <a class="el" href="namespaceug.html#ae501c74c587a838b6ac54c2508603cdc">ug::MarkCreaseEdges()</a>, <a class="el" href="group__lib__grid__algorithms__edge__util.html#ga397492a903ffbec777ca5dda0d5be44b">ug::MinimizeEdgeLength_SwapsOnly()</a>, <a class="el" href="group__lib__grid__algorithms__face__util.html#ga9ed3a8995006d786f63e318b7f6c358f">ug::PointFaceTest()</a>, <a class="el" href="classug_1_1_cluster_element_stacks.html#a78fc4afe4d99c5e92166c3c4c6c48481">ug::ClusterElementStacks&lt; elem_t, vector_t &gt;::post_process()</a>, <a class="el" href="namespaceug.html#ad9b0103faf0eb6055d28275af533bcf8">ug::QualityGridGeneration()</a>, <a class="el" href="namespaceug.html#abf6e3fa70c040969ac87797ab121a9ac">ug::ResolveTriangleIntersections()</a>, <a class="el" href="namespaceug.html#a5d02c001317ea98280382921614e1a8f">ug::ResolveVertexFaceIntersection()</a>, <a class="el" href="namespaceug.html#a7c0bf5a7eeb839aac8c2674886425595">ug::SaveGridToSTL()</a>, <a class="el" href="group__lib__grid__algorithms__selection__util.html#ga196e9956b54046cb9c9eb0e7fb35756b">ug::SelectCreaseEdges()</a>, <a class="el" href="group__lib__grid__algorithms__selection__util.html#gab092504c1ee2d0d4df3318ff2c2ed5b5">ug::SelectLinkedFlatAndDegeneratedFaces()</a>, <a class="el" href="group__lib__grid__algorithms__selection__util.html#gaac300df1c0fb7b0931fa6847727afeae">ug::SelectLinkedFlatFaces()</a>, <a class="el" href="group__lib__grid__algorithms__selection__util.html#gaddeb745d2f782ee3727f8129d0281a08">ug::SelectSmoothEdgePath()</a>, <a class="el" href="group__lib__grid__algorithms__subset__util.html#ga5b76231c8d53b10ec852d19b7fe66266">ug::SeparateFaceSubsetsByNormal()</a>, <a class="el" href="namespaceug.html#a03b5034c53ef9ac66cae605a197c0c39">ug::TangentialSmooth()</a>, <a class="el" href="namespaceug.html#aaaa47e9178f8df1070cf483fc629fea8">ug::TangentialSmoothSimple()</a>, and <a class="el" href="namespaceug.html#a2c1b8ee1c15c3e6f5d83acb1ceaf7d6e">ug::TrySplit()</a>.</p>

</div>
</div>
<a id="gae1a37eb30f8e26ad848d0aa2f79a81d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1a37eb30f8e26ad848d0aa2f79a81d1">&#9670;&nbsp;</a></span>CalculateNormalNoNormalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> int ug::CalculateNormalNoNormalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__vectors.html#ga894cdb8af74f7a563a94fb49c220fdcd">vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>vNormOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid.html">Grid</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_edge.html">Edge</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid_1_1_vertex_attachment_accessor.html">Grid::VertexAttachmentAccessor</a>&lt; <a class="el" href="namespaceug.html#a780dd3524b97269f891365fd3c3b895a">APosition</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>aaPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid_1_1_face_attachment_accessor.html">Grid::FaceAttachmentAccessor</a>&lt; <a class="el" href="namespaceug.html#a971c52fec411990d2bfb6ee27dbb0232">ANormal</a> &gt; *&#160;</td>
          <td class="paramname"><em>paaNormFACE</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the normal of the given edge. </p>
<p>This method indirectly uses <a class="el" href="classug_1_1_grid.html#a886c89b50e8f2980bfcdf74e65b23683" title="marks the object. Calls are only valid between calls to Grid::begin_marking and Grid::end_marking.">ug::Grid::mark</a>.</p>
<p>The normal is calculated as the normized sum of associated face normals. If there are no associated faces, it is assumed, that the edge lies in the xy plane. Its normal will be calculated to the right.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vNormOut</td><td>normal </td></tr>
    <tr><td class="paramname">grid</td><td><a class="el" href="classug_1_1_grid.html" title="Manages the elements of a grid and their interconnection.">Grid</a> </td></tr>
    <tr><td class="paramname">e</td><td><a class="el" href="classug_1_1_regular_edge.html" title="Edges connect two vertices.">RegularEdge</a> </td></tr>
    <tr><td class="paramname">aaPos</td><td>vertec attachment accessor </td></tr>
    <tr><td class="paramname">paaNormFACE</td><td>An optional parameter that allows to specify an accessor for precalculated face normals.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of faces that are associated with the edge. </dd></dl>

<p class="reference">References <a class="el" href="group__lib__grid__algorithms__edge__util.html#ga6530a13a5990c960cfd2f1f066e0be8c">ug::GetAssociatedFaces()</a>, <a class="el" href="group__vectors.html#ga945c247d94409091fd35fdbbcb5032c2">ug::VecAdd()</a>, <a class="el" href="group__vectors.html#ga53ae2dda87330ab64fb2a5901606b3e4">ug::VecNormalize()</a>, <a class="el" href="group__vectors.html#gaa0cd3e6bb61c8e341541f8cf3065ec6d">ug::VecScale()</a>, <a class="el" href="group__vectors.html#ga5c7eda5aeb4cd0d53ce04f682d0a0058">ug::VecSubtract()</a>, and <a class="el" href="classug_1_1_edge_vertices.html#a0f2ec2644877a1354489544f43c71206">ug::EdgeVertices::vertex()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__lib__grid__algorithms__edge__util.html#ga47d8d9dc1634d72a7500de9fe2e1f7a3">ug::CalculateNormal()</a>, and <a class="el" href="group__lib__grid__algorithms__volume__util.html#gae7afd0751a91503c97c0d834bd7baa74">ug::ContainsPoint()</a>.</p>

</div>
</div>
<a id="ga2c12f2972755f9635e2834b0d954ead2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c12f2972755f9635e2834b0d954ead2">&#9670;&nbsp;</a></span>CollapseEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> bool ug::CollapseEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid.html">Grid</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_edge.html">Edge</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>newVrt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collapses the specified edge performs local grid restructuring. </p>
<p>The edge e will be replaced by newVrt. Before calling this method you should check if an edge-collapse won't destroy the topology of your grid. You can do this by calling EdgeCollapseIsValid. During an edge-collapse all adjacent faces will be deleted or replaced by new ones. Same for volumes. Several edges will be deleted as well. </p>

<p class="reference">References <a class="el" href="classug_1_1_grid.html#acfb4b5a6a7a0d46df0bdd25bbe55e74b">ug::Grid::associated_elements()</a>, <a class="el" href="classug_1_1_face.html#aff1f964149d62f524538cef7b26db97c">ug::Face::collapse_edge()</a>, <a class="el" href="classug_1_1_volume.html#adba622320b9fd1f610ddfbe8e26281bf">ug::Volume::collapse_edge()</a>, <a class="el" href="vec__for__each_8h.html#a040ee4034c034ed8df1c07a5a5dfcfcd">end_for</a>, <a class="el" href="classug_1_1_grid.html#a94e7d19731e2d384bd0dc1b70a173cfc">ug::Grid::erase()</a>, <a class="el" href="vec__for__each_8h.html#a00d70846fbfaa5f03ee590ad29a4170c">for_each_in_vec</a>, <a class="el" href="classug_1_1_grid.html#a631569f60d18f00177e8cf24e5b3e3ff">ug::Grid::get_edge()</a>, <a class="el" href="classug_1_1_grid.html#a6970549d629877a26e896ed00f309210">ug::Grid::get_face()</a>, <a class="el" href="group__lib__grid__algorithms__vertex__util.html#gaee1128b8bc4a8fed99814b0126b9b454">ug::GetConnectedVertex()</a>, <a class="el" href="group__lib__grid__algorithms__edge__util.html#ga7c5fb5c0a5f5a045c6a3a6fa54efd4c0">ug::GetEdgeIndex()</a>, <a class="el" href="group__lib__grid__algorithms__vertex__util.html#ga0d4ce919a5c578ed819e67058723d332">ug::GetSharedVertex()</a>, <a class="el" href="classug_1_1_face.html#ab2a35640fa0837cabc630c7287cd4340">ug::Face::num_edges()</a>, <a class="el" href="classug_1_1_grid.html#a998c99dbae3769c7168dfc27a9411833">ug::Grid::num_faces()</a>, <a class="el" href="classug_1_1_volume_vertices.html#aceb9eb86aed97692ec38612e87c74dda">ug::VolumeVertices::num_vertices()</a>, <a class="el" href="classug_1_1_grid.html#a70dcd73e1a869fc9b3970c6645a587d0">ug::Grid::num_volumes()</a>, <a class="el" href="classug_1_1_grid.html#ac045932a053db8e94eef57bf7853c61f">ug::Grid::objects_will_be_merged()</a>, <a class="el" href="classug_1_1_grid.html#a38c1bb17559ef69f1ecca0c5f1bb9822">ug::Grid::register_element()</a>, <a class="el" href="classug_1_1_grid.html#ad4564831883c7e94be2ee8b446a97da5">ug::Grid::replace_vertex()</a>, <a class="el" href="classug_1_1_pointer_const_array.html#a4f421ad36ddde79f62d80a4f1a633dc0">ug::PointerConstArray&lt; TPtr &gt;::size()</a>, <a class="el" href="namespaceboost.html#aadf83b7df21b3edff92a05274c0d9eac">boost::target()</a>, and <a class="el" href="classug_1_1_edge_vertices.html#a0f2ec2644877a1354489544f43c71206">ug::EdgeVertices::vertex()</a>.</p>

<p class="reference">Referenced by <a class="el" href="namespaceug.html#abb57fe303e730ac026ce71e231e5119f">ug::TryCollapse()</a>.</p>

</div>
</div>
<a id="gafca790d4845369d2f52a21fe80685aa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafca790d4845369d2f52a21fe80685aa0">&#9670;&nbsp;</a></span>CompareVertices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ug::CompareVertices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classug_1_1_edge_vertices.html">EdgeVertices</a> *&#160;</td>
          <td class="paramname"><em>ev1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classug_1_1_edge_vertices.html">EdgeVertices</a> *&#160;</td>
          <td class="paramname"><em>ev2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether ev1 and ev2 contain the same vertices. </p>
<p>Can be used to compare <a class="el" href="classug_1_1_edge.html" title="Base-class for edges.">Edge</a> with <a class="el" href="classug_1_1_edge.html" title="Base-class for edges.">Edge</a>, <a class="el" href="classug_1_1_edge_descriptor.html" title="Can be used to store information about an edge and to construct an edge.">EdgeDescriptor</a> with <a class="el" href="classug_1_1_edge_descriptor.html" title="Can be used to store information about an edge and to construct an edge.">EdgeDescriptor</a> or <a class="el" href="classug_1_1_edge.html" title="Base-class for edges.">Edge</a> with <a class="el" href="classug_1_1_edge_descriptor.html" title="Can be used to store information about an edge and to construct an edge.">EdgeDescriptor</a>. </p>

<p class="reference">References <a class="el" href="classug_1_1_edge_vertices.html#a0f2ec2644877a1354489544f43c71206">ug::EdgeVertices::vertex()</a>.</p>

</div>
</div>
<a id="gaed91ccbc1b4b95c2ef09c3f79aabd6ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed91ccbc1b4b95c2ef09c3f79aabd6ab">&#9670;&nbsp;</a></span>ContainsPoint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class vector_t , class TAAPos &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> bool ug::ContainsPoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classug_1_1_edge_vertices.html">EdgeVertices</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_t &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TAAPos&#160;</td>
          <td class="paramname"><em>aaPos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given point lies on the given edge. </p>
<dl class="section note"><dt>Note</dt><dd>The method only works properly, if the point and the edge are located on a line parallel to the x-axis. </dd></dl>

<p class="reference">References <a class="elRef" href="../plugins/_biogas_8lua.html#a57f1028d958bb73c4e3c64e2077342fc">p</a>, <a class="el" href="namespaceug.html#a33c1491a216aec0f5a603a9a3dd6f758">ug::SMALL</a>, and <a class="el" href="classug_1_1_edge_vertices.html#a0f2ec2644877a1354489544f43c71206">ug::EdgeVertices::vertex()</a>.</p>

<p class="reference">Referenced by <a class="el" href="structug_1_1lg__ntree__traits__base.html#a825c18c8708d130ac156e76115daa2c2">ug::lg_ntree_traits_base&lt; tree_dim, world_dim, elem_t_, common_data_t_ &gt;::contains_point()</a>, <a class="el" href="classug_1_1_f_v_point_source_or_sink.html#a0f62e5bfc0c7c4fba58587188df1b0cb">ug::FVPointSourceOrSink&lt; dim, TData &gt;::corresponds_to()</a>, <a class="el" href="classug_1_1_f_v_line_source_or_sink.html#ac65c6558728abfe747c53f0676be3390">ug::FVLineSourceOrSink&lt; dim, TData &gt;::corresponds_to()</a>, <a class="el" href="group__refinement__bridge.html#ga529ef75374b032ec8fbbf00862b9997c">ug::MarkForAdaption_ElementsContainingPoint()</a>, <a class="el" href="group__refinement__bridge.html#ga74eb659b949e6286a606a1e0accdcff1">ug::MarkForRefinement_ContainsSurfaceNode()</a>, and <a class="el" href="group__lib__grid__algorithms__selection__util.html#ga51e9480950b7c07be13b9854259703fd">ug::SelectRegion()</a>.</p>

</div>
</div>
<a id="ga510e2902b9bf9775fcd178289e616cec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga510e2902b9bf9775fcd178289e616cec">&#9670;&nbsp;</a></span>CreateEdgeSplitGeometry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> bool ug::CreateEdgeSplitGeometry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid.html">Grid</a> &amp;&#160;</td>
          <td class="paramname"><em>destGrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid.html">Grid</a> &amp;&#160;</td>
          <td class="paramname"><em>srcGrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_edge.html">Edge</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>newVertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceug.html#a52072c4f65a25351aa2f5f0d6285722b">AVertex</a> *&#160;</td>
          <td class="paramname"><em>paAssociatedVertices</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>given an edge and a vertex (the split-vertex) this method constructs the split-geometry. </p>
<p>The new triangles are copied to destGrid. e has to be a member of srcGrid. The old edge (e) will not be deleted. paAssociatedVertices has to be specified if destGrid and srcGrid do not match. If destGrid and srcGrid do match, paAssociatedVertices may be specified optionally. paAssociatedVertices has to be a vertex-attachment of srcGrid, that stores for each vertex in srcGrid the associated vertex of destGrid. NULL indicates that no associated vertex exists in destGrid. New ones will be automatically constructed in this case by cloning the associated ones in srcGrid. </p>

<p class="reference">References <a class="el" href="classug_1_1_grid_1_1_attachment_accessor.html#ae4af482c7fa4d26fe8eb23c536360ee7">ug::Grid::AttachmentAccessor&lt; TElem, TAttachment &gt;::access()</a>, <a class="el" href="classug_1_1_grid.html#a42a6e7e6633d442471cd09e3b7528639">ug::Grid::attach_to_vertices_dv()</a>, <a class="el" href="group__lib__grid__algorithms__neighborhood__util.html#gae78d5b92ef32b1bd35364affde2ca69e">ug::CollectFaces()</a>, <a class="el" href="group__lib__grid__algorithms__neighborhood__util.html#ga03bd7e264a1a23ea14e7774a146d59ec">ug::CollectVolumes()</a>, <a class="el" href="classug_1_1_grid.html#adfae2fb22706392c881d20f696e97ba9">ug::Grid::create()</a>, <a class="el" href="classug_1_1_grid.html#a08bdbe8721c2428711596264bd073335">ug::Grid::create_by_cloning()</a>, <a class="el" href="classug_1_1_face.html#a963461af5db1cc17facc56cbb94b5a6a">ug::Face::create_faces_by_edge_split()</a>, <a class="el" href="classug_1_1_grid.html#a631569f60d18f00177e8cf24e5b3e3ff">ug::Grid::get_edge()</a>, <a class="el" href="group__lib__grid__algorithms__edge__util.html#ga7c5fb5c0a5f5a045c6a3a6fa54efd4c0">ug::GetEdgeIndex()</a>, <a class="el" href="classug_1_1_grid.html#ace5ab805d91e2051d93f4d54d24fa605">ug::Grid::has_vertex_attachment()</a>, <a class="el" href="classug_1_1_grid.html#a544579dbb0f7a011880b43c8302934dc">ug::Grid::num()</a>, <a class="el" href="classug_1_1_volume.html#a50974c2fdcde809442f0de077319531b">ug::Volume::num_edges()</a>, <a class="el" href="classug_1_1_face_vertices.html#a91c22d6b5fcc4c90e359685aafe2aa19">ug::FaceVertices::num_vertices()</a>, <a class="el" href="classug_1_1_volume_vertices.html#aceb9eb86aed97692ec38612e87c74dda">ug::VolumeVertices::num_vertices()</a>, <a class="el" href="classug_1_1_grid.html#ab2a6971378be03fc965fe3c96c450183">ug::Grid::pass_on_values()</a>, <a class="el" href="classug_1_1_volume.html#ad5ebf3bf21bc267baf2ca25b8c6c746d">ug::Volume::refine()</a>, <a class="el" href="classug_1_1_grid.html#a38c1bb17559ef69f1ecca0c5f1bb9822">ug::Grid::register_element()</a>, <a class="el" href="classug_1_1_edge_vertices.html#a0f2ec2644877a1354489544f43c71206">ug::EdgeVertices::vertex()</a>, <a class="el" href="classug_1_1_face_vertices.html#a8f18cc58d9b6142a2d3728cfe55159d1">ug::FaceVertices::vertex()</a>, and <a class="el" href="classug_1_1_volume_vertices.html#a3ba78eccd3b42fb57565d072de0e99e7">ug::VolumeVertices::vertex()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__lib__grid__algorithms__edge__util.html#ga5d1698fc476713187db8d989b4e29580">ug::SplitEdge()</a>.</p>

</div>
</div>
<a id="ga8d08da8a4c117456ba10f1e2809ffee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d08da8a4c117456ba10f1e2809ffee7">&#9670;&nbsp;</a></span>CutEdgesWithPlane()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> bool ug::CutEdgesWithPlane </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_selector.html">Selector</a> &amp;&#160;</td>
          <td class="paramname"><em>sel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__vectors.html#ga894cdb8af74f7a563a94fb49c220fdcd">vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__vectors.html#ga894cdb8af74f7a563a94fb49c220fdcd">vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceug.html#a780dd3524b97269f891365fd3c3b895a">APosition</a> &amp;&#160;</td>
          <td class="paramname"><em>aPos</em> = <code><a class="el" href="namespaceug.html#aab0e1fda11d3738fd1e7197eece81576">aPosition</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>refines all edges in sel which cut the given plane. </p>
<p>New vertices are inserted on the plane. When the method is done, sel will contain all refined elements. </p>

<p class="reference">References <a class="el" href="classug_1_1_selector.html#ac80a1ce32174b412113b1367d1475d07">ug::Selector::begin()</a>, <a class="el" href="classug_1_1_selector.html#a4c9de9f499200372a79af3d59680c2f1">ug::Selector::clear()</a>, <a class="el" href="classug_1_1_i_selector.html#accd4b0825807c76a6a2f11aea53f6d13">ug::ISelector::deselect()</a>, <a class="el" href="group__ugbase__mathutil.html#gadbfb99780de12aa58f4049f5e07d76fb">ug::DistancePointToPlane()</a>, <a class="el" href="classug_1_1_selector.html#a0fba1e8b8589d695f1253a576a8f5d02">ug::Selector::end()</a>, <a class="el" href="classug_1_1_i_selector.html#a331d94c5fb29966f18a3f24625be0ea5">ug::ISelector::grid()</a>, <a class="el" href="classug_1_1_grid.html#ace5ab805d91e2051d93f4d54d24fa605">ug::Grid::has_vertex_attachment()</a>, <a class="el" href="classug_1_1_i_selector.html#a114fe907dd506fb701eaadaa713e24d7">ug::ISelector::is_selected()</a>, <a class="el" href="namespaceug.html#aa0139da1e55db11bc2ef1beb6e38cc3a">ug::MakeGeometry3d()</a>, <a class="elRef" href="../plugins/_biogas_8lua.html#a57f1028d958bb73c4e3c64e2077342fc">p</a>, <a class="el" href="group__ugbase__mathutil.html#ga32fbbd5b0ca51331127cfa63fc643d63">ug::RayPlaneIntersection()</a>, <a class="elRef" href="../plugins/group__promesh.html#ga745841fa8e641710400c2777c59e42b8">Refine()</a>, <a class="el" href="namespaceug.html#a33c1491a216aec0f5a603a9a3dd6f758">ug::SMALL</a>, <a class="el" href="group__ugbase__common.html#ga849480b16e1d7c49266a92cd5db63942">UG_LOG</a>, <a class="el" href="group__vectors.html#ga5c7eda5aeb4cd0d53ce04f682d0a0058">ug::VecSubtract()</a>, and <a class="el" href="classug_1_1_edge_vertices.html#a0f2ec2644877a1354489544f43c71206">ug::EdgeVertices::vertex()</a>.</p>

</div>
</div>
<a id="ga9f7b8169cfae5eb50fc502401c9d8fde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f7b8169cfae5eb50fc502401c9d8fde">&#9670;&nbsp;</a></span>EdgeCollapseIsValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> bool ug::EdgeCollapseIsValid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid.html">Grid</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_edge.html">Edge</a> *&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if an edge-collapse would invalidate the current topology. </p>
<p>returns true if the topology would not be affected by the collapse. returns false if the topology would be affected. </p>

<p class="reference">References <a class="el" href="group__lib__grid__algorithms__neighborhood__util.html#gae78d5b92ef32b1bd35364affde2ca69e">ug::CollectFaces()</a>, <a class="el" href="group__lib__grid__algorithms__neighborhood__util.html#gada8aee34f6f23920bac25802273647e1">ug::CollectNeighbors()</a>, <a class="el" href="group__lib__grid__algorithms__face__util.html#ga27555c9331930a1204c71b39aed50c5f">ug::CompareVertices()</a>, <a class="el" href="classug_1_1_face_descriptor.html#adea79f793190321746f6953e994f5a5f">ug::FaceDescriptor::set_vertex()</a>, and <a class="el" href="classug_1_1_edge_vertices.html#a0f2ec2644877a1354489544f43c71206">ug::EdgeVertices::vertex()</a>.</p>

<p class="reference">Referenced by <a class="el" href="namespaceug.html#a805486111a1d81df475536251c7a6688">ug::TryCollapse()</a>.</p>

</div>
</div>
<a id="ga0cce38c830ab3f7e4257d0e62f690868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0cce38c830ab3f7e4257d0e62f690868">&#9670;&nbsp;</a></span>EdgeContains() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ug::EdgeContains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_edge_vertices.html">EdgeVertices</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>vrt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>returns true if the given edge contains the given vertex </p>

<p class="reference">References <a class="el" href="classug_1_1_edge_vertices.html#a0f2ec2644877a1354489544f43c71206">ug::EdgeVertices::vertex()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__lib__grid__algorithms__vertex__util.html#gae5e8fa8b773f83df4f63e0f75968bf6f">ug::CalculateBoundaryVertexNormal2D()</a>, <a class="el" href="namespaceug.html#ad732eae1983c8c3187337d1fb690d429">ug::CalculateCreaseNormal()</a>, <a class="el" href="group__lib__grid__algorithms__vertex__util.html#ga5221e89301cf0272f1a19cfe2ba9bab3">ug::CollectSurfaceNeighborsSorted()</a>, <a class="el" href="group__lib__grid__algorithms__vertex__util.html#ga3462fadc3d0f59d6a4177d60e647a2e8">ug::GetConnectedEdge()</a>, <a class="el" href="namespaceug.html#a698b8191763c1d54aa5543db5a50dd8a">ug::ProjectVerticesToCloseEdges()</a>, <a class="el" href="namespaceug.html#ad9b0103faf0eb6055d28275af533bcf8">ug::QualityGridGeneration()</a>, <a class="el" href="namespaceug.html#a66fe4246082c39400c8c25bdaf531dc2">ug::ResolveEdgeEdgeIntersection()</a>, <a class="el" href="namespaceug.html#abd58f586cf30c647da872c5b4fb93ecf">ug::ResolveVertexEdgeIntersection()</a>, <a class="el" href="group__lib__grid__algorithms__selection__util.html#gae74e88e4c32326bebcab322baa9416bf">ug::SelectShortPolychains()</a>, and <a class="el" href="namespaceug.html#a805486111a1d81df475536251c7a6688">ug::TryCollapse()</a>.</p>

</div>
</div>
<a id="gaf4fb5bde4a2e3622e87abeab48c06b12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4fb5bde4a2e3622e87abeab48c06b12">&#9670;&nbsp;</a></span>EdgeContains() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ug::EdgeContains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_edge_vertices.html">EdgeVertices</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>vrt1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>vrt2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>returns true if the given edge contains the given vertices </p>

<p class="reference">References <a class="el" href="classug_1_1_edge_vertices.html#a0f2ec2644877a1354489544f43c71206">ug::EdgeVertices::vertex()</a>.</p>

</div>
</div>
<a id="gae641a616a9dade33b7435c7e1f98fe0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae641a616a9dade33b7435c7e1f98fe0d">&#9670;&nbsp;</a></span>EdgeLength()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TAAPosVRT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> <a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a> ug::EdgeLength </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classug_1_1_edge_vertices.html">EdgeVertices</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TAAPosVRT &amp;&#160;</td>
          <td class="paramname"><em>aaPos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the length of the given edge. </p>
<p>The specified accessor has to access a <a class="el" href="classug_1_1_math_vector.html" title="a mathematical Vector with N entries.">MathVector</a> compatible type in the vertices of the underlying grid. </p>

<p class="reference">References <a class="el" href="group__vectors.html#ga92e42e49d0d212e50fc214803cf06e78">ug::VecDistance()</a>, and <a class="el" href="classug_1_1_edge_vertices.html#a0f2ec2644877a1354489544f43c71206">ug::EdgeVertices::vertex()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classug_1_1_fractured_media_refiner.html#a55a77856c20851eb4482b644c53286d7">ug::FracturedMediaRefiner&lt; TGrid, TAPosition &gt;::aspect_ratio()</a>, <a class="el" href="namespaceug.html#ac1709b8c75763105d4723cbb2c4bd60a">ug::CalculateAspectRatio()</a>, <a class="el" href="group__lib__grid__algorithms__edge__util.html#ga4bb56348bfa70c7a5760f20a6bc2963b">ug::CalculateAverageEdgeLength()</a>, <a class="el" href="group__lib__grid__algorithms__volume__util.html#gaf31820d91f65e3dd5680a7d6e4652dea">ug::CalculateTetrahedronAspectRatio()</a>, <a class="el" href="group__lib__grid__algorithms__volume__calculation.html#ga6fed646b68ed38f15cdfedfcdeddaea4">ug::CalculateVolume()</a>, <a class="el" href="classug_1_1_fractured_media_refiner.html#a7c963b9282b4db1f54c93bdffa5dbe51">ug::FracturedMediaRefiner&lt; TGrid, TAPosition &gt;::collect_objects_for_refine()</a>, <a class="el" href="group__lib__grid__algorithms__volume__util.html#gae7afd0751a91503c97c0d834bd7baa74">ug::ContainsPoint()</a>, <a class="el" href="namespaceug.html#af5c32ece8ebe92182c0150208f16cb5a">ug::PrintElementEdgeRatios()</a>, and <a class="el" href="group__lib__grid__algorithms__selection__util.html#gae74e88e4c32326bebcab322baa9416bf">ug::SelectShortPolychains()</a>.</p>

</div>
</div>
<a id="ga9ac3258a67343fc5e0dec267bb84d33d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ac3258a67343fc5e0dec267bb84d33d">&#9670;&nbsp;</a></span>EdgeLengthSq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TAAPosVRT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> <a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a> ug::EdgeLengthSq </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classug_1_1_edge_vertices.html">EdgeVertices</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TAAPosVRT &amp;&#160;</td>
          <td class="paramname"><em>aaPos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the squared length of the given edge. </p>
<p>The specified accessor has to access a <a class="el" href="classug_1_1_math_vector.html" title="a mathematical Vector with N entries.">MathVector</a> compatible type in the vertices of the underlying grid. </p>

<p class="reference">References <a class="el" href="group__vectors.html#ga7da70ab2d2c942a82b582f1cc7888069">ug::VecDistanceSq()</a>, and <a class="el" href="classug_1_1_edge_vertices.html#a0f2ec2644877a1354489544f43c71206">ug::EdgeVertices::vertex()</a>.</p>

<p class="reference">Referenced by <a class="el" href="namespaceug.html#a344f7c1a6d8b21860c5510e697c80d33">ug::FindLongestEdge()</a>, <a class="el" href="group__lib__grid__algorithms__edge__util.html#ga5b6139da5c102d916b7e919b8f5ad501">ug::FindShortestEdge()</a>, <a class="el" href="group__domain__bridge.html#gaffaaec5db9baa32b6ec12b0fbc8c6493">ug::GetMaxEdgeLength()</a>, <a class="el" href="group__refinement__bridge.html#ga914e0ae696b7298934f79bda9336ace1">ug::MarkAnisotropic_LongEdges()</a>, <a class="el" href="namespaceug.html#af62d2fc0fa82ee14b70b14d6ccc32ee9">ug::MarkForAnisotropicRefinement()</a>, <a class="el" href="group__refinement__bridge.html#ga37c9d51b22b5bb97416a5db83c193ed5">ug::MarkForRefinement_AnisotropicDirection()</a>, <a class="el" href="group__refinement__bridge.html#ga924981e96e0eebe688e57ffe0416c341">ug::MarkForRefinement_CloseToSurface()</a>, <a class="el" href="group__lib__grid__algorithms__edge__util.html#ga397492a903ffbec777ca5dda0d5be44b">ug::MinimizeEdgeLength_SwapsOnly()</a>, <a class="el" href="namespaceug.html#ad9b0103faf0eb6055d28275af533bcf8">ug::QualityGridGeneration()</a>, and <a class="el" href="group__lib__grid__algorithms__selection__util.html#gab092504c1ee2d0d4df3318ff2c2ed5b5">ug::SelectLinkedFlatAndDegeneratedFaces()</a>.</p>

</div>
</div>
<a id="ga5b6139da5c102d916b7e919b8f5ad501"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b6139da5c102d916b7e919b8f5ad501">&#9670;&nbsp;</a></span>FindShortestEdge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TEdgeIterator , class TAAPosVRT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> <a class="el" href="classug_1_1_edge.html">Edge</a>* ug::FindShortestEdge </td>
          <td>(</td>
          <td class="paramtype">TEdgeIterator&#160;</td>
          <td class="paramname"><em>edgesBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TEdgeIterator&#160;</td>
          <td class="paramname"><em>edgesEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TAAPosVRT &amp;&#160;</td>
          <td class="paramname"><em>aaPos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the shortest edge in a list of edges. </p>
<p>TEdgeIterator has to point to values of type Edge* and has to be an stl-iterator compatible iterator. TAAPosVRT has to be an attachment accessor which provides a position value (vector1, vector2, vector3, ...) for the vertices of the edge. If the specified list is empty, NULL is returned. If multiple shortest edges exist, the first one is returned. </p>

<p class="reference">References <a class="el" href="group__lib__grid__algorithms__edge__util.html#ga9ac3258a67343fc5e0dec267bb84d33d">ug::EdgeLengthSq()</a>.</p>

</div>
</div>
<a id="gab71f0105ef482356bab57a65bc535624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab71f0105ef482356bab57a65bc535624">&#9670;&nbsp;</a></span>FixEdgeOrientation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TEdgeIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> void ug::FixEdgeOrientation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid.html">Grid</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TEdgeIterator&#160;</td>
          <td class="paramname"><em>edgesBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TEdgeIterator&#160;</td>
          <td class="paramname"><em>edgesEnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates uniform orientation of neighboured edges. </p>
<p>This algorithm uses <a class="el" href="classug_1_1_grid.html#a886c89b50e8f2980bfcdf74e65b23683" title="marks the object. Calls are only valid between calls to Grid::begin_marking and Grid::end_marking.">Grid::mark</a></p>
<p>swaps orientation of edges so that all neighboured edges share the same.</p>
<p>Value type of TEdgeIterator has to be compatible with Edge*.</p>
<p>Note that all edges between edgesBegin and edgesEnd have to be members of the specified grid.</p>
<p>The orientation can only be successfully fixed, if vertices between the given edges share at most 2 edges between edgesBegin and edgesEnd. </p>

<p class="reference">References <a class="el" href="classug_1_1_grid.html#a12abfbc3c3ea8447b9297cc67d37d39a">ug::Grid::associated_edges_begin()</a>, <a class="el" href="classug_1_1_grid.html#a578b44c6af08b6614f3df6aac3be8080">ug::Grid::associated_edges_end()</a>, <a class="el" href="classug_1_1_grid.html#a9d45fe5cb040ee7e1be8f683f257790d">ug::Grid::begin_marking()</a>, <a class="el" href="classug_1_1_grid.html#a0dfadffbcf794fe5136b4a8ba4a86959">ug::Grid::end_marking()</a>, <a class="el" href="classug_1_1_grid.html#a94546f0aa0a88b0fe61497ee993cf6b7">ug::Grid::flip_orientation()</a>, <a class="el" href="group__lib__grid__algorithms__vertex__util.html#gaaf616966d82226b6c9af1b072d2e482c">ug::GetVertexIndex()</a>, <a class="el" href="classug_1_1_grid.html#a448f44e49cf1facf5346d9ca8b449337">ug::Grid::is_marked()</a>, <a class="el" href="classug_1_1_grid.html#a886c89b50e8f2980bfcdf74e65b23683">ug::Grid::mark()</a>, <a class="el" href="classug_1_1_grid.html#a44009e78ca60a380555d11bec9263c2c">ug::Grid::unmark()</a>, and <a class="el" href="classug_1_1_edge_vertices.html#a0f2ec2644877a1354489544f43c71206">ug::EdgeVertices::vertex()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__lib__grid__algorithms__subset__util.html#ga4b12d84a76fc1c24fefbff33413a8948">ug::AdjustSubsetsForLgmNg()</a>.</p>

</div>
</div>
<a id="ga6530a13a5990c960cfd2f1f066e0be8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6530a13a5990c960cfd2f1f066e0be8c">&#9670;&nbsp;</a></span>GetAssociatedFaces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> int ug::GetAssociatedFaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_face.html">Face</a> **&#160;</td>
          <td class="paramname"><em>facesOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid.html">Grid</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_edge.html">Edge</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxNumFaces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>writes associated faces of e to facesOut. </p>
<p>Associated faces of e are written to facesOut. facesOut has to be an array of size maxNumFaces. If there are more then maxNumFaces associated faces, they are not written to facesOut.</p>
<p>The method returns the number of total number of associated faces. </p>

<p class="reference">References <a class="el" href="classug_1_1_grid.html#a106cc182d347f7dcbb80cb166b9cba4e">ug::Grid::associated_faces_begin()</a>, <a class="el" href="classug_1_1_grid.html#ab9a41c2c814038390f068d76a4792af3">ug::Grid::associated_faces_end()</a>, <a class="el" href="group__lib__grid.html#gga3191186b24de51adb225ea234971df0ea41e559550a6eb4b85b9a02e4fcca8e5c">ug::EDGEOPT_STORE_ASSOCIATED_FACES</a>, <a class="el" href="classug_1_1_face_vertices.html#a91c22d6b5fcc4c90e359685aafe2aa19">ug::FaceVertices::num_vertices()</a>, <a class="el" href="classug_1_1_grid.html#a1a52ff3974dd27f9cce544226c43586c">ug::Grid::option_is_enabled()</a>, <a class="el" href="classug_1_1_edge_vertices.html#a0f2ec2644877a1354489544f43c71206">ug::EdgeVertices::vertex()</a>, and <a class="el" href="classug_1_1_face_vertices.html#a8f18cc58d9b6142a2d3728cfe55159d1">ug::FaceVertices::vertex()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__lib__grid__algorithms__edge__util.html#ga7e1d8942c72eeed23cb74ad52711e3f1">ug::AdjustEdgeOrientationToFaceOrientation()</a>, <a class="el" href="group__lib__grid__algorithms__edge__util.html#ga47d8d9dc1634d72a7500de9fe2e1f7a3">ug::CalculateNormal()</a>, <a class="el" href="group__lib__grid__algorithms__edge__util.html#gae1a37eb30f8e26ad848d0aa2f79a81d1">ug::CalculateNormalNoNormalize()</a>, <a class="el" href="group__lib__grid__algorithms__vertex__util.html#ga5221e89301cf0272f1a19cfe2ba9bab3">ug::CollectSurfaceNeighborsSorted()</a>, <a class="el" href="classug_1_1_delaunay_info.html#a0c7aa0b1f44d37ed3f3767f12420b54c">ug::DelaunayInfo&lt; TAAPos &gt;::init_marks()</a>, <a class="el" href="namespaceug.html#a1f9980d74102b0d13df6658e3d76cd45">ug::MakeDelaunay()</a>, <a class="el" href="namespaceug.html#ae501c74c587a838b6ac54c2508603cdc">ug::MarkCreaseEdges()</a>, <a class="el" href="group__lib__grid__algorithms__edge__util.html#ga397492a903ffbec777ca5dda0d5be44b">ug::MinimizeEdgeLength_SwapsOnly()</a>, <a class="el" href="namespaceug.html#ad9b0103faf0eb6055d28275af533bcf8">ug::QualityGridGeneration()</a>, <a class="el" href="group__lib__grid__algorithms__selection__util.html#ga196e9956b54046cb9c9eb0e7fb35756b">ug::SelectCreaseEdges()</a>, <a class="el" href="group__lib__grid__algorithms__edge__util.html#ga169e3367d738bbc1f3ccf16abcb62d15">ug::SwapEdge()</a>, and <a class="el" href="namespaceug.html#a69c278429b11b102a864fff5fe5ef8c6">ug::TrySwap()</a>.</p>

</div>
</div>
<a id="gac8adcbaa5a7de0382231d8d2a058a362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8adcbaa5a7de0382231d8d2a058a362">&#9670;&nbsp;</a></span>GetConnectingEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> <a class="el" href="classug_1_1_edge.html">Edge</a> * ug::GetConnectingEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid.html">Grid</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_face.html">Face</a> *&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_face.html">Face</a> *&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>returns the first edge found which is shared by both faces or NULL if no such edge exists. </p>

<p class="reference">References <a class="el" href="classug_1_1_grid.html#acfb4b5a6a7a0d46df0bdd25bbe55e74b">ug::Grid::associated_elements()</a>, and <a class="el" href="classug_1_1_pointer_const_array.html#a4f421ad36ddde79f62d80a4f1a633dc0">ug::PointerConstArray&lt; TPtr &gt;::size()</a>.</p>

<p class="reference">Referenced by <a class="el" href="namespaceug.html#a8ff8a352f8a8ca629bb6db200b22f099">ug::CreateQuadrilateral_NoRegistration()</a>, and <a class="el" href="namespaceug.html#a53a5b3a3819ee58afd75f9ef82c27829">ug::ReplaceByQuadrilateral()</a>.</p>

</div>
</div>
<a id="ga1630d8ea9135b8305a86bdece82d93f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1630d8ea9135b8305a86bdece82d93f0">&#9670;&nbsp;</a></span>GetEdgeIndex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> int ug::GetEdgeIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_face.html">Face</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_edge.html">Edge</a> *&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the index at which edge e is found in the given object </p>
<p>returns -1 if the edge was not found. </p>

<p class="reference">References <a class="el" href="group__lib__grid__algorithms__face__util.html#ga27555c9331930a1204c71b39aed50c5f">ug::CompareVertices()</a>, <a class="el" href="classug_1_1_face.html#a58d3b73e59ed266bdb6558c759ec0d51">ug::Face::edge_desc()</a>, and <a class="el" href="classug_1_1_face.html#ab2a35640fa0837cabc630c7287cd4340">ug::Face::num_edges()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classug_1_1_hanging_node_refiner_base.html#aeec7f03c6905a87e02f7bed0411b597b">ug::HangingNodeRefinerBase&lt; TSelector &gt;::assign_hnode_marks()</a>, <a class="el" href="namespaceug.html#a670fd9a1468187d3d1f34b1c711d0ac9">ug::CalculateSmoothManifoldPosInParentLevelButterflyScheme()</a>, and <a class="el" href="classug_1_1_i_refiner.html#afca9c7b29b5d5e50d8b84ec8791d4f7e">ug::IRefiner::get_local_edge_mark()</a>.</p>

</div>
</div>
<a id="ga7c5fb5c0a5f5a045c6a3a6fa54efd4c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c5fb5c0a5f5a045c6a3a6fa54efd4c0">&#9670;&nbsp;</a></span>GetEdgeIndex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> int ug::GetEdgeIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_volume.html">Volume</a> *&#160;</td>
          <td class="paramname"><em>vol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_edge.html">Edge</a> *&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the index at which edge e is found in the given object </p>
<p>returns -1 if the edge was not found. </p>

<p class="reference">References <a class="el" href="group__lib__grid__algorithms__face__util.html#ga27555c9331930a1204c71b39aed50c5f">ug::CompareVertices()</a>, <a class="el" href="classug_1_1_volume.html#a7a9828fb55b6a4d45f682653d2f07c40">ug::Volume::edge_desc()</a>, and <a class="el" href="classug_1_1_volume.html#a50974c2fdcde809442f0de077319531b">ug::Volume::num_edges()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__lib__grid__algorithms__edge__util.html#ga2c12f2972755f9635e2834b0d954ead2">ug::CollapseEdge()</a>, and <a class="el" href="group__lib__grid__algorithms__edge__util.html#ga510e2902b9bf9775fcd178289e616cec">ug::CreateEdgeSplitGeometry()</a>.</p>

</div>
</div>
<a id="ga346c8f5ab191aa2d3b10f2932871b37f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga346c8f5ab191aa2d3b10f2932871b37f">&#9670;&nbsp;</a></span>GetInnerEdgesOfFaceSoup()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class face_iter_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ug::GetInnerEdgesOfFaceSoup </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classug_1_1_edge.html">Edge</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>edgesOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid.html">Grid</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">face_iter_t&#160;</td>
          <td class="paramname"><em>facesBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">face_iter_t&#160;</td>
          <td class="paramname"><em>facesEnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>pushes all edges which are connected to at least 2 faces from the specified sequence to edgesOut </p>

<p class="reference">References <a class="el" href="classug_1_1_grid.html#acfb4b5a6a7a0d46df0bdd25bbe55e74b">ug::Grid::associated_elements()</a>, and <a class="el" href="classug_1_1_pointer_const_array.html#a4f421ad36ddde79f62d80a4f1a633dc0">ug::PointerConstArray&lt; TPtr &gt;::size()</a>.</p>

<p class="reference">Referenced by <a class="el" href="namespaceug.html#ad960ba8900bcaf8732d3414354f0c6e9">ug::ReplaceByQuadrilaterals_FaceBased()</a>, and <a class="el" href="namespaceug.html#a1c3102c0323715bdf96d8e52e95fff51">ug::ReplaceByQuadrilaterals_FaceBasedNoSort()</a>.</p>

</div>
</div>
<a id="ga5dbcb9d97d82202a72209f0ee92eacc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5dbcb9d97d82202a72209f0ee92eacc0">&#9670;&nbsp;</a></span>GetVertex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classug_1_1_vertex.html">Vertex</a> * ug::GetVertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_edge.html">Edge</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the i'th vertex of an edge </p>
<p>This function simply returns the i'th vertex of an edge </p>

<p class="reference">References <a class="el" href="namespaceboost.html#a9a0147028d720cc8409c818ede288560">boost::num_vertices()</a>, <a class="el" href="group__ugbase__common.html#ga0b928ef153b78f1b5e025638cf28f841">UG_ASSERT</a>, and <a class="el" href="classug_1_1_edge_vertices.html#a0f2ec2644877a1354489544f43c71206">ug::EdgeVertices::vertex()</a>.</p>

</div>
</div>
<a id="gac0565ea76771097bfbd142f02cea7adb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0565ea76771097bfbd142f02cea7adb">&#9670;&nbsp;</a></span>IsBoundaryEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> bool ug::IsBoundaryEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid.html">Grid</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_edge.html">Edge</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structug_1_1_grid_1_1traits.html#a1bd114991c12becc6ca48862967dd9f2">Grid::face_traits::callback</a>&#160;</td>
          <td class="paramname"><em>funcIsSurfFace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns true if the edge is connected to exactly one surface face. </p>
<p>If the given callback returns true for a given face, then the face is considered to be part of a surface. If exactly one of the faces adjacent to the given edge is part of a surface, then the edge is considered to be a boundary edge and true is returned. Take a look at existing standard callbacks, if you want to use this method. </p>

<p class="reference">References <a class="el" href="classug_1_1_grid.html#a106cc182d347f7dcbb80cb166b9cba4e">ug::Grid::associated_faces_begin()</a>, <a class="el" href="classug_1_1_grid.html#ab9a41c2c814038390f068d76a4792af3">ug::Grid::associated_faces_end()</a>, <a class="el" href="group__lib__grid__algorithms__neighborhood__util.html#gae78d5b92ef32b1bd35364affde2ca69e">ug::CollectFaces()</a>, <a class="el" href="group__lib__grid.html#gga3191186b24de51adb225ea234971df0ea41e559550a6eb4b85b9a02e4fcca8e5c">ug::EDGEOPT_STORE_ASSOCIATED_FACES</a>, and <a class="el" href="classug_1_1_grid.html#a1a52ff3974dd27f9cce544226c43586c">ug::Grid::option_is_enabled()</a>.</p>

</div>
</div>
<a id="ga5bf1afd38411b7139354752323bbd9d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5bf1afd38411b7139354752323bbd9d4">&#9670;&nbsp;</a></span>IsBoundaryEdge2D()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> bool ug::IsBoundaryEdge2D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid.html">Grid</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_edge.html">Edge</a> *&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns whether an edge lies on the boundary of a 2D grid. </p>
<p>An edge is regarded as a boundary edge if it is adjacent to exactly one face. if EDGEOPT_STORE_ASSOCIATED_FACES is enabled, the algorithm will be faster. </p>

<p class="reference">References <a class="el" href="group__lib__grid__algorithms__edge__util.html#ga44b3d0df416364eaf38104507a6104e7">ug::NumAssociatedFaces()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__lib__grid__algorithms__subset__util.html#ga74d472fdbe503c6753783dec6195adce">ug::AssignInnerAndBoundarySubsets()</a>, <a class="el" href="group__lib__grid__algorithms__vertex__util.html#gae5e8fa8b773f83df4f63e0f75968bf6f">ug::CalculateBoundaryVertexNormal2D()</a>, <a class="el" href="group__lib__grid__algorithms__vertex__util.html#ga2027583d2c14c0b7ac9379df4c988ccf">ug::IsBoundaryVertex2D()</a>, <a class="el" href="group__lib__grid__algorithms__edge__util.html#ga200f74c7905c6e950f95ede32dc3c8df">ug::LiesOnBoundary()</a>, <a class="el" href="group__lib__grid__algorithms__refinement__subdivision.html#gaf938e924ef3fa6118391b370b2c3349f">ug::ProjectToLimitPLoop()</a>, <a class="el" href="group__lib__grid__algorithms__refinement__subdivision.html#gae0d3fd849c0dbdf64f258be46c646354">ug::ProjectToLimitSubdivBoundary()</a>, <a class="el" href="group__lib__grid__algorithms__selection__util.html#ga196e9956b54046cb9c9eb0e7fb35756b">ug::SelectCreaseEdges()</a>, and <a class="el" href="namespaceug.html#a05cd8e208a02e98281f7d824acd9bd5f">ug::SlopeSmooth()</a>.</p>

</div>
</div>
<a id="gaca999ef2fe108897bf5f89f81493ca48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca999ef2fe108897bf5f89f81493ca48">&#9670;&nbsp;</a></span>IsBoundaryEdge3D()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> bool ug::IsBoundaryEdge3D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid.html">Grid</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_edge.html">Edge</a> *&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns whether an edge lies on the boundary of a 3D grid. </p>
<p>An edge is regarded as a boundary edge in 3d if it is adjacent to at least one boundary face. if EDGEOPT_STORE_ASSOCIATED_FACES is enabled, the algorithm will be faster.</p>
<p>Please Note: This algorithm requires the grid option VOLOPT_AUTOGENERATE_FACES. If it is not enabled, this algorithm will enable it. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000023">Todo:</a></b></dt><dd>This algorithm should work without VOLOPT_AUTOGENERATE_FACES, too. </dd></dl>

<p class="reference">References <a class="el" href="classug_1_1_grid.html#a106cc182d347f7dcbb80cb166b9cba4e">ug::Grid::associated_faces_begin()</a>, <a class="el" href="classug_1_1_grid.html#ab9a41c2c814038390f068d76a4792af3">ug::Grid::associated_faces_end()</a>, <a class="el" href="group__lib__grid__algorithms__neighborhood__util.html#gae78d5b92ef32b1bd35364affde2ca69e">ug::CollectFaces()</a>, <a class="el" href="group__lib__grid.html#gga3191186b24de51adb225ea234971df0ea41e559550a6eb4b85b9a02e4fcca8e5c">ug::EDGEOPT_STORE_ASSOCIATED_FACES</a>, <a class="el" href="classug_1_1_grid.html#ae94bdb2aa02392c63f9f15bde3d21328">ug::Grid::enable_options()</a>, <a class="el" href="group__lib__grid__algorithms__face__util.html#ga13333d7cf4577f562d1a92d1b3fc4c5e">ug::IsBoundaryFace3D()</a>, <a class="el" href="classug_1_1_grid.html#a1a52ff3974dd27f9cce544226c43586c">ug::Grid::option_is_enabled()</a>, <a class="el" href="group__ugbase__common.html#ga849480b16e1d7c49266a92cd5db63942">UG_LOG</a>, and <a class="el" href="group__lib__grid.html#gga1f929733097f2c587b05fa7c1f1f6502ae2c73031331562ca82b4a849a4f36874">ug::VOLOPT_AUTOGENERATE_FACES</a>.</p>

<p class="reference">Referenced by <a class="el" href="namespaceug.html#a57abf95963a57af5e27eccb2dcec0ec6">ug::DistributeExpansionMarks3D()</a>, <a class="el" href="group__lib__grid__algorithms__edge__util.html#ga200f74c7905c6e950f95ede32dc3c8df">ug::LiesOnBoundary()</a>, and <a class="el" href="group__lib__grid__algorithms__refinement__subdivision.html#gaf938e924ef3fa6118391b370b2c3349f">ug::ProjectToLimitPLoop()</a>.</p>

</div>
</div>
<a id="ga200f74c7905c6e950f95ede32dc3c8df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga200f74c7905c6e950f95ede32dc3c8df">&#9670;&nbsp;</a></span>LiesOnBoundary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> bool ug::LiesOnBoundary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid.html">Grid</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_edge.html">Edge</a> *&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns true, if the edge lies on a 2d or 3d boundary </p>

<p class="reference">References <a class="el" href="group__lib__grid__algorithms__edge__util.html#ga5bf1afd38411b7139354752323bbd9d4">ug::IsBoundaryEdge2D()</a>, <a class="el" href="group__lib__grid__algorithms__edge__util.html#gaca999ef2fe108897bf5f89f81493ca48">ug::IsBoundaryEdge3D()</a>, and <a class="el" href="classug_1_1_grid.html#a544579dbb0f7a011880b43c8302934dc">ug::Grid::num()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classug_1_1_is_on_boundary.html#afeab518a2242f45212df6a93c7ea0333">ug::IsOnBoundary::callback()</a>, <a class="el" href="classug_1_1_is_not_on_boundary.html#a88b1aed9133e28c06ac5f73d59b6fb74">ug::IsNotOnBoundary::callback()</a>, <a class="el" href="group__lib__grid__algorithms__selection__util.html#gaad1a00f532621a225fea7234a8d73b7f">ug::SelectBoundaryElements()</a>, <a class="el" href="group__lib__grid__algorithms__selection__util.html#ga865d633f82420d0241ed9978373ce34a">ug::SelectInnerElements()</a>, and <a class="el" href="namespaceug.html#a05cd8e208a02e98281f7d824acd9bd5f">ug::SlopeSmooth()</a>.</p>

</div>
</div>
<a id="ga397492a903ffbec777ca5dda0d5be44b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga397492a903ffbec777ca5dda0d5be44b">&#9670;&nbsp;</a></span>MinimizeEdgeLength_SwapsOnly()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class EdgeIterator , class TAAPos &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> void ug::MinimizeEdgeLength_SwapsOnly </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid.html">Grid</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceug.html#a499d06e0979bcf1e0eec2d93e1cb44ce">EdgeIterator</a>&#160;</td>
          <td class="paramname"><em>edgesBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceug.html#a499d06e0979bcf1e0eec2d93e1cb44ce">EdgeIterator</a>&#160;</td>
          <td class="paramname"><em>edgesEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TAAPos &amp;&#160;</td>
          <td class="paramname"><em>aaPos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms the given edge-set so that the sum of the length the edges is minimized. </p>
<p>Removes edges that connect the same two vertices as another edge. ** THIS ALGORITHM USES <a class="el" href="classug_1_1_grid.html#a886c89b50e8f2980bfcdf74e65b23683" title="marks the object. Calls are only valid between calls to Grid::begin_marking and Grid::end_marking.">Grid::mark</a>*&zwj;/ Currently only works for 3d position attachments.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000024">Todo:</a></b></dt><dd>add support for 2d position attachments. </dd></dl>

<p class="reference">References <a class="el" href="classug_1_1_grid.html#a5bfa7109653bb3a50d9d023e64011fc5">ug::Grid::attach_to_edges_dv()</a>, <a class="el" href="group__lib__grid__algorithms__edge__util.html#ga47d8d9dc1634d72a7500de9fe2e1f7a3">ug::CalculateNormal()</a>, <a class="el" href="group__lib__grid__algorithms__neighborhood__util.html#gaf82709887c879e120297650ef61c14ce">ug::CollectAssociated()</a>, <a class="el" href="classug_1_1_grid.html#aca6f564a5fb8ed77cce8996d397a7628">ug::Grid::detach_from_edges()</a>, <a class="el" href="group__lib__grid__algorithms__edge__util.html#ga9ac3258a67343fc5e0dec267bb84d33d">ug::EdgeLengthSq()</a>, <a class="el" href="group__lib__grid__algorithms__edge__util.html#ga6530a13a5990c960cfd2f1f066e0be8c">ug::GetAssociatedFaces()</a>, <a class="el" href="group__lib__grid__algorithms__vertex__util.html#gaee1128b8bc4a8fed99814b0126b9b454">ug::GetConnectedVertex()</a>, <a class="el" href="namespaceboost.html#a9a0147028d720cc8409c818ede288560">boost::num_vertices()</a>, <a class="el" href="classug_1_1_face_descriptor.html#a5671fc960e79a48bfcb85724e789b498">ug::FaceDescriptor::set_num_vertices()</a>, <a class="el" href="classug_1_1_face_descriptor.html#adea79f793190321746f6953e994f5a5f">ug::FaceDescriptor::set_vertex()</a>, <a class="el" href="group__lib__grid__algorithms__edge__util.html#ga169e3367d738bbc1f3ccf16abcb62d15">ug::SwapEdge()</a>, <a class="el" href="group__ugbase__common.html#ga0b928ef153b78f1b5e025638cf28f841">UG_ASSERT</a>, <a class="el" href="group__vectors.html#gae9174d47662deb0ba119e0e21f28ec71">ug::VecDot()</a>, <a class="el" href="classug_1_1_edge_vertices.html#a0f2ec2644877a1354489544f43c71206">ug::EdgeVertices::vertex()</a>, and <a class="el" href="group__lib__grid__algorithms__vertex__util.html#gab7c796988775ad24fd15c24087d8a81e">ug::VertexDistanceSq()</a>.</p>

</div>
</div>
<a id="ga44b3d0df416364eaf38104507a6104e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44b3d0df416364eaf38104507a6104e7">&#9670;&nbsp;</a></span>NumAssociatedFaces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> int ug::NumAssociatedFaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid.html">Grid</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_edge.html">Edge</a> *&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the number of associated faces of the given edge </p>
<p>This method uses <a class="el" href="classug_1_1_grid.html#a886c89b50e8f2980bfcdf74e65b23683" title="marks the object. Calls are only valid between calls to Grid::begin_marking and Grid::end_marking.">ug::Grid::mark</a>.</p>
<p>The method returns the number of total number of associated faces. </p>

<p class="reference">References <a class="el" href="classug_1_1_grid.html#a106cc182d347f7dcbb80cb166b9cba4e">ug::Grid::associated_faces_begin()</a>, <a class="el" href="classug_1_1_grid.html#ab9a41c2c814038390f068d76a4792af3">ug::Grid::associated_faces_end()</a>, <a class="el" href="classug_1_1_grid.html#a9d45fe5cb040ee7e1be8f683f257790d">ug::Grid::begin_marking()</a>, <a class="el" href="group__lib__grid.html#gga3191186b24de51adb225ea234971df0ea41e559550a6eb4b85b9a02e4fcca8e5c">ug::EDGEOPT_STORE_ASSOCIATED_FACES</a>, <a class="el" href="classug_1_1_grid.html#a0dfadffbcf794fe5136b4a8ba4a86959">ug::Grid::end_marking()</a>, <a class="el" href="classug_1_1_grid.html#a448f44e49cf1facf5346d9ca8b449337">ug::Grid::is_marked()</a>, <a class="el" href="classug_1_1_grid.html#a886c89b50e8f2980bfcdf74e65b23683">ug::Grid::mark()</a>, <a class="el" href="classug_1_1_face_vertices.html#a91c22d6b5fcc4c90e359685aafe2aa19">ug::FaceVertices::num_vertices()</a>, <a class="el" href="classug_1_1_grid.html#a1a52ff3974dd27f9cce544226c43586c">ug::Grid::option_is_enabled()</a>, <a class="el" href="classug_1_1_edge_vertices.html#a0f2ec2644877a1354489544f43c71206">ug::EdgeVertices::vertex()</a>, and <a class="el" href="classug_1_1_face_vertices.html#a8f18cc58d9b6142a2d3728cfe55159d1">ug::FaceVertices::vertex()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__lib__grid__algorithms__edge__util.html#ga5bf1afd38411b7139354752323bbd9d4">ug::IsBoundaryEdge2D()</a>, <a class="el" href="namespaceug.html#a500c334f1f91ba7c83e38cc61cbbfd10">ug::PerformTetrahedralization()</a>, and <a class="el" href="namespaceug.html#a5d02c001317ea98280382921614e1a8f">ug::ResolveVertexFaceIntersection()</a>.</p>

</div>
</div>
<a id="ga5d1698fc476713187db8d989b4e29580"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d1698fc476713187db8d989b4e29580">&#9670;&nbsp;</a></span>SplitEdge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TVertex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TVertex * ug::SplitEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid.html">Grid</a> &amp;&#160;</td>
          <td class="paramname"><em>destGrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid.html">Grid</a> &amp;&#160;</td>
          <td class="paramname"><em>srcGrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_edge.html">Edge</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceug.html#a52072c4f65a25351aa2f5f0d6285722b">AVertex</a> *&#160;</td>
          <td class="paramname"><em>paAssociatedVertices</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bConservative</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>inserts new triangles and one new vertex by splitting the specified edge. </p>
<p>returns the newly created vertex. The vertex that will be created will be of type TVertex. The new vertex and triangles are copied to destGrid. e has to be a member of srcGrid. If bConservative == false then SplitEdge will replace e and its adjacent geometry by the newly generated geometry. paAssociatedVertices has to be specified if destGrid and srcGrid do not match. If destGrid and srcGrid do match, paAssociatedVertices may be specified optionally. paAssociatedVertices has to be a vertex-attachment of srcGrid, that stores for each vertex in srcGrid the associated vertex of destGrid. NULL indicates that no associated vertex exists in destGrid. New ones will be automatically constructed in this case. </p>

<p class="reference">References <a class="el" href="group__lib__grid__algorithms__neighborhood__util.html#gae78d5b92ef32b1bd35364affde2ca69e">ug::CollectFaces()</a>, <a class="el" href="group__lib__grid__algorithms__neighborhood__util.html#ga03bd7e264a1a23ea14e7774a146d59ec">ug::CollectVolumes()</a>, <a class="el" href="classug_1_1_grid.html#adfae2fb22706392c881d20f696e97ba9">ug::Grid::create()</a>, <a class="el" href="group__lib__grid__algorithms__edge__util.html#ga510e2902b9bf9775fcd178289e616cec">ug::CreateEdgeSplitGeometry()</a>, <a class="el" href="classug_1_1_grid.html#a94e7d19731e2d384bd0dc1b70a173cfc">ug::Grid::erase()</a>, <a class="el" href="group__lib__grid.html#ggad5f5a639937a67f1018d12996992f6f3a91ebc7149fdaed37fc203643bb6e3994">ug::FACEOPT_AUTOGENERATE_EDGES</a>, <a class="el" href="classug_1_1_grid.html#a1a52ff3974dd27f9cce544226c43586c">ug::Grid::option_is_enabled()</a>, <a class="el" href="group__lib__grid.html#gga1f929733097f2c587b05fa7c1f1f6502a1941a6961b3865daf7d17742e3589cb9">ug::VOLOPT_AUTOGENERATE_EDGES</a>, and <a class="el" href="group__lib__grid.html#gga1f929733097f2c587b05fa7c1f1f6502ae2c73031331562ca82b4a849a4f36874">ug::VOLOPT_AUTOGENERATE_FACES</a>.</p>

</div>
</div>
<a id="ga1dacf3dfd8313a5816f7544e441c685c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1dacf3dfd8313a5816f7544e441c685c">&#9670;&nbsp;</a></span>SplitEdge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TVertex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TVertex * ug::SplitEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid.html">Grid</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_edge.html">Edge</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bConservative</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>inserts new triangles and one new vertex by splitting the specified edge. </p>
<p>returns the newly created vertex if everything went right, NULL if not. The vertex that will be created will be of type TVertex. If bConservative == false then SplitEdge will replace e and its adjacent geometry by the newly generated geometry. </p>

</div>
</div>
<a id="ga169e3367d738bbc1f3ccf16abcb62d15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga169e3367d738bbc1f3ccf16abcb62d15">&#9670;&nbsp;</a></span>SwapEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> <a class="el" href="classug_1_1_edge.html">Edge</a> * ug::SwapEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid.html">Grid</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_edge.html">Edge</a> *&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>swaps e and thus reconnects its two adjacent triangles. </p>
<p>A swap is only allowed if e has exactly 2 adjacent triangles. The method erases the old edge and triangles and constructs new ones. Old elements are passed as parents to the grids creation method.</p>
<p>The swapped edge is returned. </p>

<p class="reference">References <a class="el" href="classug_1_1_grid.html#a9d45fe5cb040ee7e1be8f683f257790d">ug::Grid::begin_marking()</a>, <a class="el" href="classug_1_1_grid.html#adfae2fb22706392c881d20f696e97ba9">ug::Grid::create()</a>, <a class="el" href="classug_1_1_grid.html#a08bdbe8721c2428711596264bd073335">ug::Grid::create_by_cloning()</a>, <a class="el" href="classug_1_1_grid.html#a0dfadffbcf794fe5136b4a8ba4a86959">ug::Grid::end_marking()</a>, <a class="el" href="classug_1_1_grid.html#a94e7d19731e2d384bd0dc1b70a173cfc">ug::Grid::erase()</a>, <a class="el" href="classug_1_1_grid.html#a631569f60d18f00177e8cf24e5b3e3ff">ug::Grid::get_edge()</a>, <a class="el" href="group__lib__grid__algorithms__edge__util.html#ga6530a13a5990c960cfd2f1f066e0be8c">ug::GetAssociatedFaces()</a>, <a class="el" href="classug_1_1_grid.html#a448f44e49cf1facf5346d9ca8b449337">ug::Grid::is_marked()</a>, <a class="el" href="classug_1_1_grid.html#a886c89b50e8f2980bfcdf74e65b23683">ug::Grid::mark()</a>, <a class="el" href="namespaceboost.html#a9a0147028d720cc8409c818ede288560">boost::num_vertices()</a>, <a class="el" href="group__ugbase__common.html#ga849480b16e1d7c49266a92cd5db63942">UG_LOG</a>, <a class="el" href="classug_1_1_edge_vertices.html#a0f2ec2644877a1354489544f43c71206">ug::EdgeVertices::vertex()</a>, and <a class="el" href="classug_1_1_face_vertices.html#a8f18cc58d9b6142a2d3728cfe55159d1">ug::FaceVertices::vertex()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__lib__grid__algorithms__edge__util.html#ga397492a903ffbec777ca5dda0d5be44b">ug::MinimizeEdgeLength_SwapsOnly()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Oct 9 2023 00:54:04 for ug4 by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
