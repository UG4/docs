<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ug4: Todo List</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ug4
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('todo.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Todo List </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="reflist">
<dt>Page <a class="el" href="page_u_g4_parallel_ju_queen_more.html">Detailed JuQueen Information</a>  </dt>
<dd><a class="anchor" id="_todo000002"></a>Maybe some notes about available "Tools" like the "call graph" would be nice. For the moment try yourself and/or see the TotalView docu (links below). </dd>
<dt>Page <a class="el" href="page_u_g4_doxygen_quickref.html">Doxygen Quick Reference</a>  </dt>
<dd><a class="anchor" id="_todo000001"></a>Extend the documentation. </dd>
<dt>Page <a class="el" href="page_u_g4_setup_u_g__v_r_l.html">How to build UG for VRL for Windows</a>  </dt>
<dd><a class="anchor" id="_todo000003"></a>Make this instructions more readable / structured <br  />
 </dd>
<dt>Class <a class="el" href="class_smart_ptr_3_01void_01_4.html">SmartPtr&lt; void &gt;</a>  </dt>
<dd><a class="anchor" id="_todo000008"></a>add to_smart_ptr_dynamic </dd>
<dt>Member <a class="el" href="namespacestl__reader.html#a2ff4c513e56a27ebf393bf2da265e7d9">stl_reader::ReadStlFile_BINARY</a>  (const char *filename, TNumberContainer &amp;coordsOut, TNumberContainer &amp;normalsOut, TIndexContainer &amp;trisOut, TIndexContainer &amp;solidRangesOut)</dt>
<dd><a class="anchor" id="_todo000048"></a>support systems with big endianess  </dd>
<dt>Class <a class="el" href="classug_1_1_adaptive_regular_refiner___multi_grid.html">ug::AdaptiveRegularRefiner_MultiGrid</a>  </dt>
<dd><a class="anchor" id="_todo000057"></a>The current implementation has a performance overhead, since currently all closure elements are removed prior to grid adaption. This should be reduced to only remove closure elements which are affected by adaption. One could therefore replace <a class="el" href="classug_1_1_selector.html" title="specialization of ISelector for a grid of class Grid.">Selector</a> by <a class="el" href="classug_1_1_bool_marker.html" title="Allows to mark elements.">BoolMarker</a> and adjust the collect_objects_for_refinement / coarsening routines to use callbacks when identifying valid refine / coarsen objects.  </dd>
<dt>Member <a class="el" href="classug_1_1_binary_stream.html#a67c7ad3c68aa32071aceb4c7bed67438">ug::BinaryStream::can_read_more</a>  ()</dt>
<dd><a class="anchor" id="_todo000006"></a>this method should be removed. The normal stream-methdos should be used instead (eof,...). However - those do not seem to work properly in the moment.  </dd>
<dt>Class <a class="el" href="classug_1_1_bool_marker.html">ug::BoolMarker</a>  </dt>
<dd><p class="startdd"><a class="anchor" id="_todo000061"></a>Allow to restrict marking to vertices, edges, faces or volumes </p>
<p class="interdd">Add is_marked, mark, unmark for <a class="el" href="classug_1_1_grid_object.html" title="The base class for all geometric objects, such as vertices, edges, faces, volumes,...">GridObject</a> </p>
<p class="enddd">Refactor to template &lt;class T&gt; Marker.  </p>
</dd>
<dt>Member <a class="el" href="classug_1_1bridge_1_1_exported_method.html#aae5be84645caea9a4d58ee439b51c530">ug::bridge::ExportedMethod::create_parameter_stack</a>  ()</dt>
<dd><a class="anchor" id="_todo000064"></a>: replace this method with a better integrated way.  </dd>
<dt>Member <a class="el" href="namespaceug.html#a1945715f3a56b2bfa9e5c041c8787a03">ug::CheckOrientation</a>  (<a class="el" href="classug_1_1_volume.html" title="Volumes are 3-dimensional objects.">Volume</a> *vol, TAAPosVRT &amp;aaPosVRT)</dt>
<dd><a class="anchor" id="_todo000027"></a>this method could be improved by adding specialised versions for the different volume types.  </dd>
<dt>Member <a class="el" href="group__lib__algebra__parallelization__util.html#gad7aff107c35514a47f19ce2ddb8586f1">ug::CommunicateConnections</a>  (std::vector&lt; std::vector&lt; int &gt; &gt; &amp;connectionsToProcsOut, std::vector&lt; std::vector&lt; int &gt; &gt; &amp;connectionsToSubDomsOut, IndexLayout &amp;masterLayout, IndexLayout &amp;slaveLayout, int highestReferencedIndex, <a class="el" href="classpcl_1_1_i_domain_decomposition_info.html">pcl::IDomainDecompositionInfo</a> &amp;ddinfo)</dt>
<dd><a class="anchor" id="_todo000013"></a>The method should probably automatically find the highestReferencedIndex, to avoid misuse.  </dd>
<dt>Member <a class="el" href="namespaceug.html#aad47ec080a1ca3cbfabffa8d653426d2">ug::CreateLayoutsFromDistInfos</a>  (<a class="el" href="classug_1_1_multi_grid.html">MultiGrid</a> &amp;mg, <a class="el" href="classug_1_1_grid_layout_map.html" title="lets you access layouts by type and key">GridLayoutMap</a> &amp;glm, <a class="el" href="classug_1_1_dist_info_supplier.html" title="Automatically attaches ADistInfo to all elements of a grid.">DistInfoSupplier</a> &amp;distInfos, AGeomObjID &amp;aGID)</dt>
<dd><a class="anchor" id="_todo000052"></a>Think about caching interfaces to speed up this method.  </dd>
<dt>Member <a class="el" href="group__lib__grid__algorithms__polychain__util.html#gaf931eaa7c43bd6777b19c2d8e624bc0f">ug::CreatePolyChain</a>  (std::vector&lt; Vertex * &gt; &amp;polyChainOut, <a class="el" href="classug_1_1_grid.html" title="Manages the elements of a grid and their interconnection.">Grid</a> &amp;grid, TEdgeIter edgesBegin, TEdgeIter edgesEnd)</dt>
<dd><a class="anchor" id="_todo000028"></a>add support for open chains.  </dd>
<dt>Member <a class="el" href="classug_1_1_delaunay_info.html#a0c7aa0b1f44d37ed3f3767f12420b54c">ug::DelaunayInfo&lt; TAAPos &gt;::init_marks</a>  (TIter trisBegin, TIter trisEnd, bool pushFlipCandidates)</dt>
<dd><a class="anchor" id="_todo000031"></a>think about adding a cleanup at the beginning of init_marks (costly)  </dd>
<dt>Member <a class="el" href="group__lib__grid__algorithms__serialization.html#gafbf4b8285d9e464502c0807bcfcdbd54">ug::DeserializeMultiGridElements</a>  (<a class="el" href="classug_1_1_multi_grid.html">MultiGrid</a> &amp;mg, <a class="el" href="classug_1_1_binary_buffer.html" title="A Buffer for binary data.">BinaryBuffer</a> &amp;in, std::vector&lt; Vertex * &gt; *pvVrts=NULL, std::vector&lt; Edge * &gt; *pvEdges=NULL, std::vector&lt; Face * &gt; *pvFaces=NULL, std::vector&lt; Volume * &gt; *pvVols=NULL, MultiElementAttachmentAccessor&lt; AGeomObjID &gt; *paaID=NULL)</dt>
<dd><a class="anchor" id="_todo000041"></a>add support for constrained/constraining faces  </dd>
<dt>Member <a class="el" href="group__lib__grid__algorithms__selection__util.html#ga9af566cc2d5fa64e02e35507a9f918f9">ug::ExtendSelection</a>  (TSelector &amp;sel, size_t extSize, <a class="el" href="classug_1_1_i_selector.html#ad6a357e415d93d79798c415f3aeb1a71">ISelector::status_t</a> status=<a class="el" href="classug_1_1_i_selector.html#aae11223942f45486a7a7cc15078d3311a851d0b56336261b9bc3fa08a5c7531db">ISelector::SELECTED</a>)</dt>
<dd><a class="anchor" id="_todo000037"></a>: Performance can be improved. See implementation.  </dd>
<dt>Member <a class="el" href="group__lib__grid__algorithms__selection__util.html#gaac50cb8106ea84388389da555fcc24a0">ug::ExtendSelectionInDirection</a>  (TSelector &amp;sel, size_t extSize, const typename TAAPos::ValueType &amp;dir, number minAngle, number maxAngle, const TAAPos &amp;aaPos, <a class="el" href="classug_1_1_i_selector.html#ad6a357e415d93d79798c415f3aeb1a71">ISelector::status_t</a> status=<a class="el" href="classug_1_1_i_selector.html#aae11223942f45486a7a7cc15078d3311a851d0b56336261b9bc3fa08a5c7531db">ISelector::SELECTED</a>)</dt>
<dd><a class="anchor" id="_todo000038"></a>: Performance can be improved. See implementation.  </dd>
<dt>Member <a class="el" href="group__lib__grid__algorithms__extrusion.html#ga25e1021a6e0327aa259dab7a950c1a95">ug::ExtrudeCylinder</a>  (<a class="el" href="classug_1_1_grid.html" title="Manages the elements of a grid and their interconnection.">Grid</a> &amp;grid, SubsetHandler &amp;sh, <a class="el" href="classug_1_1_vertex.html" title="Base-class for all vertex-types.">Vertex</a> *vrt, const vector3 &amp;direction, number height, number radius, number rimSnapThreshold, Grid::VertexAttachmentAccessor&lt; APosition &gt; &amp;aaPos, int bottomSubInd=-1, int cylSubInd=-1, <a class="el" href="classug_1_1_selector.html" title="specialization of ISelector for a grid of class Grid.">Selector</a> *pSel=NULL)</dt>
<dd><a class="anchor" id="_todo000021"></a>: Add a parameter that allows to specify whether the source-faces of the extrusion shall be erased. </dd>
<dt>Member <a class="el" href="group__lib__grid__algorithms__extrusion.html#ga2a2fb643d0fc7129070de249b449c943">ug::ExtrudeCylinder</a>  (<a class="el" href="classug_1_1_grid.html" title="Manages the elements of a grid and their interconnection.">Grid</a> &amp;grid, <a class="el" href="classug_1_1_vertex.html" title="Base-class for all vertex-types.">Vertex</a> *vrt, const vector3 &amp;direction, number height, number radius, number rimSnapThreshold, Grid::VertexAttachmentAccessor&lt; APosition &gt; &amp;aaPos, <a class="el" href="classug_1_1_selector.html" title="specialization of ISelector for a grid of class Grid.">Selector</a> *pSel=NULL)</dt>
<dd><a class="anchor" id="_todo000022"></a>: Add a parameter that allows to specify whether the source-faces of the extrusion shall be erased. </dd>
<dt>Class <a class="el" href="classug_1_1_fractured_media_refiner.html">ug::FracturedMediaRefiner&lt; TGrid, TAPosition &gt;</a>  </dt>
<dd><p class="startdd"><a class="anchor" id="_todo000058"></a>Add support for degenerated volumes </p>
<p class="enddd">Use a IsDegenerated callback instead of thresholds  </p>
</dd>
<dt>Member <a class="el" href="classug_1_1_fractured_media_refiner.html#ab5e1b92060e7dd0a22f8b550b1f17812">ug::FracturedMediaRefiner&lt; TGrid, TAPosition &gt;::set_position_attachment</a>  (TAPosition &amp;aPos)</dt>
<dd><a class="anchor" id="_todo000059"></a>: replace this with a callback  </dd>
<dt>Member <a class="el" href="classug_1_1_f_v_line_source_or_sink.html#ac65c6558728abfe747c53f0676be3390">ug::FVLineSourceOrSink&lt; dim, TData &gt;::corresponds_to</a>  (TElem *elem, <a class="el" href="classug_1_1_grid.html" title="Manages the elements of a grid and their interconnection.">Grid</a> &amp;grid, TAAPos &amp;aaPos, const TFVGeom &amp;geo, size_t co, <a class="el" href="classug_1_1_math_vector.html">MathVector&lt; dim &gt;</a> &amp;ls, <a class="el" href="classug_1_1_math_vector.html">MathVector&lt; dim &gt;</a> &amp;le)</dt>
<dd><a class="anchor" id="_todo000019"></a>This function works only for there is only one scv per corner. This is not true for pyramids!  </dd>
<dt>Member <a class="el" href="classug_1_1_grid.html#a15a108aad2f35f1cdb55793639d6f93f">ug::Grid::copy_user_attachments</a>  (const TAttachmentPipe &amp;apSrc, TAttachmentPipe &amp;apDest, std::vector&lt; int &gt; &amp;srcDataIndices)</dt>
<dd><a class="anchor" id="_todo000050"></a>Copy behavior should be changed to all user-attachments.  </dd>
<dt>Member <a class="el" href="classug_1_1_grid.html#abcbddde35f152b9c918d99319f7eb00c">ug::Grid::erase</a>  (const GeomObjIter &amp;iterBegin, const GeomObjIter &amp;iterEnd)</dt>
<dd><a class="anchor" id="_todo000049"></a>: This erase method can cause problems if used with multi-grids.  </dd>
<dt>Class <a class="el" href="classug_1_1_grid_reader_u_g_x.html">ug::GridReaderUGX</a>  </dt>
<dd><a class="anchor" id="_todo000046"></a>: Improve performance by using in-situ stringstreams during element creation.  </dd>
<dt>Class <a class="el" href="classug_1_1_grid_reader_v_t_u.html">ug::GridReaderVTU</a>  </dt>
<dd><a class="anchor" id="_todo000047"></a>: Improve performance by using in-situ stringstreams during element creation.  </dd>
<dt>Class <a class="el" href="classug_1_1_hanging_node_refiner___multi_grid.html">ug::HangingNodeRefiner_MultiGrid</a>  </dt>
<dd><a class="anchor" id="_todo000060"></a>: Avoid the removal of refinement marks during coarsening and of coarsening marks during refinement. </dd>
<dt>Member <a class="el" href="group__lib__grid__parallelization.html#ga435886362f9d12bf7c7c1ba63c303c14">ug::hash_key&lt; GeomObjID &gt;</a>  (const GeomObjID &amp;key)</dt>
<dd><a class="anchor" id="_todo000053"></a>Check distribution quality.  </dd>
<dt>Member <a class="el" href="classug_1_1_heightfield.html#a8cf848f752ae2c61bc156a1be43c051b">ug::Heightfield::interpolate</a>  (number x, number y, int interpOrder) const</dt>
<dd><p class="startdd"><a class="anchor" id="_todo000026"></a>: add a method 'set_interpolation_method' to also support bilinear- or spline-interpolation</p>
<p class="enddd"></p>
</dd>
<dt>Member <a class="el" href="namespaceug.html#ab381625ea3610cd62253f7f635c1319b">ug::IntersectCloseEdges</a>  (<a class="el" href="classug_1_1_grid.html" title="Manages the elements of a grid and their interconnection.">Grid</a> &amp;grid, TObjectCollection &amp;elems, TAAPosVRT &amp;aaPos, number snapThreshold)</dt>
<dd><a class="anchor" id="_todo000036"></a>: speed up through octree (use MultiEdgeSplit)  </dd>
<dt>Member <a class="el" href="group__lib__grid__algorithms__edge__util.html#gaca999ef2fe108897bf5f89f81493ca48">ug::IsBoundaryEdge3D</a>  (<a class="el" href="classug_1_1_grid.html" title="Manages the elements of a grid and their interconnection.">Grid</a> &amp;grid, <a class="el" href="classug_1_1_edge.html" title="Base-class for edges.">Edge</a> *e)</dt>
<dd><a class="anchor" id="_todo000023"></a>This algorithm should work without VOLOPT_AUTOGENERATE_FACES, too.  </dd>
<dt>Member <a class="el" href="namespaceug.html#a3c100adeb72b6849f558078360b376f6">ug::MarkForAdaption_GradientJump</a>  (<a class="el" href="classug_1_1_i_refiner.html" title="The refiner interface allows to mark elements for refinement and to call refine.">IRefiner</a> &amp;refiner, <a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt; GridFunction&lt; TDomain, TAlgebra &gt; &gt; u, const char *cmp, number refFrac, int minLvl, int maxLvl, std::string jumpType)</dt>
<dd><a class="anchor" id="_todo000014"></a>: Add coarsenFrac and apply coarsen-marks, too.  </dd>
<dt>Member <a class="el" href="namespaceug.html#ad49a40cf0d6f047e2e7f7e05e2af8b2e">ug::MarkForAdaption_ResidualErrorP1Absolute</a>  (<a class="el" href="classug_1_1_i_refiner.html" title="The refiner interface allows to mark elements for refinement and to call refine.">IRefiner</a> &amp;refiner, <a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt; GridFunction&lt; TDomain, TAlgebra &gt; &gt; u, <a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt; UserData&lt; number, TDomain::dim &gt; &gt; f, const char *cmp, number time, number refTol, number coarsenTol, int maxLvl, int quadOrder, std::string quadType, bool refTopLvlOnly=false)</dt>
<dd><a class="anchor" id="_todo000015"></a>: Add coarsenFrac and apply coarsen-marks, too.  </dd>
<dt>Member <a class="el" href="namespaceug.html#a5bb8462fdfdf4813194f1159225163b5">ug::MarkForAdaption_ResidualErrorP1Relative</a>  (<a class="el" href="classug_1_1_i_refiner.html" title="The refiner interface allows to mark elements for refinement and to call refine.">IRefiner</a> &amp;refiner, <a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt; GridFunction&lt; TDomain, TAlgebra &gt; &gt; u, <a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt; UserData&lt; number, TDomain::dim &gt; &gt; f, const char *cmp, number time, number refFrac, int minLvl, int maxLvl, int quadOrder, std::string quadType)</dt>
<dd><a class="anchor" id="_todo000016"></a>: Add coarsenFrac and apply coarsen-marks, too.  </dd>
<dt>Member <a class="el" href="classug_1_1_matrix_i_o_mtx.html#a8805cbd9396163cf696a7bb72b67e082">ug::MatrixIOMtx::write_from</a>  (matrix_type &amp;matrix, std::string comment="%Generated with ug4.")</dt>
<dd><a class="anchor" id="_todo000011"></a>Implement validity check for the comment. </dd>
<dt>Member <a class="el" href="group__lib__grid__algorithms__edge__util.html#ga397492a903ffbec777ca5dda0d5be44b">ug::MinimizeEdgeLength_SwapsOnly</a>  (<a class="el" href="classug_1_1_grid.html" title="Manages the elements of a grid and their interconnection.">Grid</a> &amp;grid, EdgeIterator edgesBegin, EdgeIterator edgesEnd, TAAPos &amp;aaPos)</dt>
<dd><a class="anchor" id="_todo000024"></a>add support for 2d position attachments.  </dd>
<dt>Member <a class="el" href="classug_1_1_m_m_type_code.html#a31e2c56fc2880ad9cc8a6b2de9b93c27">ug::MMTypeCode::to_string</a>  ()</dt>
<dd><a class="anchor" id="_todo000012"></a>Display corresponding strings instead of internal numeric codes.  </dd>
<dt>Class <a class="el" href="classug_1_1_multiple_err_est_data.html">ug::MultipleErrEstData&lt; TDomain, TErrEstData &gt;</a>  </dt>
<dd><a class="anchor" id="_todo000020"></a>Maybe find a better way to deal with the orders of ErrEstData objects here and unknowns in the elem discs.  </dd>
<dt>Class <a class="el" href="classug_1_1node__tree_1_1_traverser___intersect_faces.html">ug::node_tree::Traverser_IntersectFaces</a>  </dt>
<dd><a class="anchor" id="_todo000004"></a>A list with local coordinates of intersections should be created during intersect_tri. This list should then be available to the user.  </dd>
<dt>Member <a class="el" href="classug_1_1ntree.html#a238849ae544eb8408cfd6549ae41a797">ug::ntree&lt; tree_dim, world_dim, TElem, TCommonData &gt;::add_element</a>  (const elem_t &amp;elem)</dt>
<dd><a class="anchor" id="_todo000005"></a>Allow optional on-the-fly insertion of elements.  </dd>
<dt>Member <a class="el" href="group__ugbase__common__types.html#ga801ef3296b01f22be5f7d35882747866">ug::operator&lt;&lt;</a>  (std::ostream &amp;os, const Table&lt; T &gt; &amp;table)</dt>
<dd><a class="anchor" id="_todo000010"></a>Support for line-breaks ('<br  />
' etc) and multi-line rows.  </dd>
<dt>Class <a class="el" href="classug_1_1_parallel_dual_graph.html">ug::ParallelDualGraph&lt; TGeomBaseObj, TIndexType, TConnectingObj &gt;</a>  </dt>
<dd><a class="anchor" id="_todo000055"></a>The current implementation has support for MultiGrids only. Support for flat grids should be added.  </dd>
<dt>Member <a class="el" href="classug_1_1_parallel_dual_graph.html#af3649ee9fabbfe0bd5106e418521b430">ug::ParallelDualGraph&lt; TGeomBaseObj, TIndexType, TConnectingObj &gt;::generate_graph</a>  (int level, <a class="el" href="classpcl_1_1_process_communicator.html">pcl::ProcessCommunicator</a> procCom=<a class="el" href="classpcl_1_1_process_communicator.html">pcl::ProcessCommunicator(pcl::PCD_WORLD)</a>)</dt>
<dd><a class="anchor" id="_todo000056"></a>add more generate_graph methods, e.g. for flat grids or complete hierarchies.  </dd>
<dt>Class <a class="el" href="classug_1_1_partition_map.html">ug::PartitionMap</a>  </dt>
<dd><a class="anchor" id="_todo000062"></a>a partition map should feature a constructor which takes a grid.  </dd>
<dt>Class <a class="el" href="classug_1_1_pointer_const_array.html">ug::PointerConstArray&lt; TPtr &gt;</a>  </dt>
<dd><p class="startdd"><a class="anchor" id="_todo000007"></a>: Add iterators </p>
<p class="enddd">: Implement analogous PointerArray with additional resize method, which allows to change existing entries.  </p>
</dd>
<dt>Member <a class="el" href="namespaceug.html#a964abee56de8bce8da10ecc48dd44fba">ug::RayElementIntersection</a>  (number &amp;sminOut, number &amp;smaxOut, const vector3 &amp;from, const vector3 &amp;dir, <a class="el" href="classug_1_1_face.html" title="Faces are 2-dimensional objects.">Face</a> *f, <a class="el" href="classug_1_1_grid.html" title="Manages the elements of a grid and their interconnection.">Grid</a> &amp;g, Grid::VertexAttachmentAccessor&lt; AVector3 &gt; aaPos, number sml=SMALL)</dt>
<dd><a class="anchor" id="_todo000030"></a>if a ray lies in the plane of a face, sminOut and smaxOut are currently not correctly computed (see note).  </dd>
<dt>Member <a class="el" href="namespaceug.html#afad13d928d3bf4f18cc1aa20ef99cde4">ug::RayElementIntersection</a>  (number &amp;sminOut, number &amp;smaxOut, const vector2 &amp;from, const vector2 &amp;dir, <a class="el" href="classug_1_1_edge.html" title="Base-class for edges.">Edge</a> *e, <a class="el" href="classug_1_1_grid.html" title="Manages the elements of a grid and their interconnection.">Grid</a> &amp;g, Grid::VertexAttachmentAccessor&lt; AVector2 &gt; aaPos, number sml=SMALL)</dt>
<dd><a class="anchor" id="_todo000029"></a>if a ray lies in the plane of an edge, sminOut and smaxOut are currently not correctly computed (see note).  </dd>
<dt>Member <a class="el" href="group__lib__grid__algorithms__vertex__util.html#ga0ef4b61a6c2f18a940efa1cf74d7e47d">ug::RemoveDoubles</a>  (<a class="el" href="classug_1_1_grid.html" title="Manages the elements of a grid and their interconnection.">Grid</a> &amp;grid, const TVrtIterator &amp;iterBegin, const TVrtIterator &amp;iterEnd, <a class="el" href="classug_1_1_attachment.html" title="A generic specialization of IAttachment.">Attachment</a>&lt; <a class="el" href="classug_1_1_math_vector.html">MathVector&lt; dim &gt;</a> &gt; &amp;aPos, number threshold)</dt>
<dd><p class="startdd"><a class="anchor" id="_todo000025"></a>remove container restrictions as described above.</p>
<p class="enddd"></p>
</dd>
<dt>Member <a class="el" href="namespaceug.html#ab49bd7b2589650c86c2e3c5354ab23a7">ug::ResolveEdgeFaceIntersection</a>  (<a class="el" href="classug_1_1_grid.html" title="Manages the elements of a grid and their interconnection.">Grid</a> &amp;grid, <a class="el" href="classug_1_1_edge.html" title="Base-class for edges.">Edge</a> *e, <a class="el" href="classug_1_1_face.html" title="Faces are 2-dimensional objects.">Face</a> *f, TAAPosVRT &amp;aaPos, number snapThreshold)</dt>
<dd><p class="startdd"><a class="anchor" id="_todo000033"></a>Instead of manually refining the face, an external function SplitFace should be used, which can take care of volume, too. </p>
<p class="enddd"><a class="anchor" id="_todo000035"></a>Instead of manually refining the face, an external function SplitFace should be used, which can take care of volume, too.  </p>
</dd>
<dt>Member <a class="el" href="namespaceug.html#a5d02c001317ea98280382921614e1a8f">ug::ResolveVertexFaceIntersection</a>  (<a class="el" href="classug_1_1_grid.html" title="Manages the elements of a grid and their interconnection.">Grid</a> &amp;grid, <a class="el" href="classug_1_1_vertex.html" title="Base-class for all vertex-types.">Vertex</a> *v, <a class="el" href="classug_1_1_face.html" title="Faces are 2-dimensional objects.">Face</a> *f, TAAPosVRT &amp;aaPos, number snapThreshold, std::vector&lt; Face * &gt; *pNewFacesOut)</dt>
<dd><p class="startdd"><a class="anchor" id="_todo000034"></a>Instead of manually refining the face, an external function SplitFace should be used, which can take care of volumes, too. </p>
<p class="enddd"><a class="anchor" id="_todo000032"></a>Instead of manually refining the face, an external function SplitFace should be used, which can take care of volumes, too.  </p>
</dd>
<dt>Member <a class="el" href="namespaceug.html#aab851406dc871522968893c0b2ccf639">ug::SaveGridHierarchyTransformed</a>  (<a class="el" href="classug_1_1_multi_grid.html">MultiGrid</a> &amp;mg, const char *filename, number offset)</dt>
<dd><a class="anchor" id="_todo000043"></a>: Support any type of position attachment  </dd>
<dt>Member <a class="el" href="namespaceug.html#a25b0a851fdfeaffcf5f84fb94898174f">ug::SaveGridHierarchyTransformed</a>  (<a class="el" href="classug_1_1_multi_grid.html">MultiGrid</a> &amp;mg, <a class="el" href="classug_1_1_i_subset_handler.html">ISubsetHandler</a> &amp;sh, const char *filename, number offset)</dt>
<dd><a class="anchor" id="_todo000042"></a>: Support any type of position attachment  </dd>
<dt>Member <a class="el" href="namespaceug.html#a3032d5bfd77b19843511d1476f9995da">ug::SaveParallelGridLayout</a>  (<a class="el" href="classug_1_1_multi_grid.html">MultiGrid</a> &amp;mg, const char *filename, number offset=0.1)</dt>
<dd><a class="anchor" id="_todo000044"></a>: Support any type of position attachment  </dd>
<dt>Member <a class="el" href="namespaceug.html#ae1c9350c9226b1777df490634f52c151">ug::SavePartitionMapToFile</a>  (<a class="el" href="classug_1_1_partition_map.html" title="Used to describe how a domain shall be distributed in a parallel environment.">PartitionMap</a> &amp;pm, const char *filename, TAPos &amp;aPos)</dt>
<dd><a class="anchor" id="_todo000063"></a>currently only the .ugx format is supported.  </dd>
<dt>Member <a class="el" href="namespaceug.html#a2089213fc5a9702293f66a18248a7817">ug::SaveSurfaceViewTransformed</a>  (<a class="el" href="classug_1_1_multi_grid.html">MultiGrid</a> &amp;mg, const <a class="el" href="classug_1_1_surface_view.html" title="Represents the surface view of a multi-grid hierarchy.">SurfaceView</a> &amp;sv, const char *filename, number offset=0.1)</dt>
<dd><a class="anchor" id="_todo000045"></a>: Support any type of position attachment  </dd>
<dt>Member <a class="el" href="group__lib__grid__algorithms__selection__util.html#gaddeb745d2f782ee3727f8129d0281a08">ug::SelectSmoothEdgePath</a>  (<a class="el" href="classug_1_1_selector.html" title="specialization of ISelector for a grid of class Grid.">Selector</a> &amp;sel, number thresholdDegree, number normalWeight, bool stopAtSelVrts=true, APosition &amp;aPos=aPosition)</dt>
<dd><a class="anchor" id="_todo000039"></a>: replace aPos by an template <a class="el" href="classug_1_1_attachment_accessor.html" title="Used to access data that has been attached to an attachment pipe.">AttachmentAccessor</a> TAAPosVrt.  </dd>
<dt>Member <a class="el" href="group__lib__grid__algorithms__serialization.html#gafa817ce1f4bb02def9a91be802cf05f2">ug::SerializeMultiGridElements</a>  (<a class="el" href="classug_1_1_multi_grid.html">MultiGrid</a> &amp;mg, <a class="el" href="classug_1_1_grid_object_collection.html" title="a helper class that holds a collection of possibly unconnected geometric-objects.">GridObjectCollection</a> goc, MultiElementAttachmentAccessor&lt; AInt &gt; &amp;aaInt, <a class="el" href="classug_1_1_binary_buffer.html" title="A Buffer for binary data.">BinaryBuffer</a> &amp;out, MultiElementAttachmentAccessor&lt; AGeomObjID &gt; *paaID=NULL)</dt>
<dd><p class="startdd"><a class="anchor" id="_todo000040"></a>add support for constrained/constraining faces </p>
<p class="enddd">use ConstVertexArrays instead of virtual functions ...-&gt;vertex(...)  </p>
</dd>
<dt>Member <a class="el" href="namespaceug_1_1shared__rules.html#a7ac2b679a4bd43aa6e8509c82ace36ca">ug::shared_rules::RecursiveRefine</a>  (int *newIndsOut, int *newEdgeVrts, const int faceVrtInds[][4], const int faceEdgeInds[][4], int numVrts, int numEdges, int numFaces)</dt>
<dd><a class="anchor" id="_todo000051"></a>add support for snap-vertices.  </dd>
<dt>Member <a class="el" href="classug_1_1_std_transfer.html#a99fc3a54af376349d344897082530bd6">ug::StdTransfer&lt; TDomain, TAlgebra &gt;::enable_p1_lagrange_optimization</a>  (bool enable)</dt>
<dd><a class="anchor" id="_todo000018"></a>The normal assembling strategy should be optimized in such a way that the p1-lagrange optimization is no longer required. This however involves something like a ref-type-hash for each element, which returns a unique number based on the types and order of children.  </dd>
<dt>Class <a class="el" href="classug_1_1_table.html">ug::Table&lt; T &gt;</a>  </dt>
<dd><a class="anchor" id="_todo000009"></a>different alignments for different columns / rows / fields  </dd>
<dt>Class <a class="el" href="classug_1_1_t_parallel_global_refiner.html">ug::TParallelGlobalRefiner&lt; TRefiner &gt;</a>  </dt>
<dd><a class="anchor" id="_todo000054"></a>This class would benefit from some comfort methods and a better documentation.  </dd>
<dt>Member <a class="el" href="namespaceug.html#a2d4dec0fa0bbb1238fa497557114439a">ug::vtk_export_ho</a>  (<a class="el" href="class_smart_ptr.html">SmartPtr&lt; TGridFunction &gt;</a> u, const std::vector&lt; std::string &gt; &amp;vFct, size_t order, <a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt; VTKOutput&lt; TGridFunction::domain_type::dim &gt; &gt; vtkOutput, const char *filename, size_t step, number time, const std::vector&lt; std::string &gt; &amp;vSubset)</dt>
<dd><a class="anchor" id="_todo000017"></a>The order parameter might be left out and determined automatically from the grid function. </dd>
</dl>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Apr 10 2023 01:00:05 for ug4 by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
