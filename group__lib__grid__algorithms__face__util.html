<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ug4: face util</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ug4
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__lib__grid__algorithms__face__util.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">face util<div class="ingroups"><a class="el" href="group__lib__grid.html">lib_grid</a> &raquo; <a class="el" href="group__lib__grid__algorithms.html">algorithms</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>contains methods to manipulate faces  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga9e37b000b12799c3d1852b4096330112"><td class="memTemplParams" colspan="2">template&lt;class TIterator &gt; </td></tr>
<tr class="memitem:ga9e37b000b12799c3d1852b4096330112"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> <a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__face__util.html#ga9e37b000b12799c3d1852b4096330112">ug::AreaFaceQuality</a> (TIterator facesBegin, TIterator facesEnd, <a class="el" href="classug_1_1_grid_1_1_vertex_attachment_accessor.html">Grid::VertexAttachmentAccessor</a>&lt; <a class="el" href="namespaceug.html#a780dd3524b97269f891365fd3c3b895a">APosition</a> &gt; &amp;aaPos)</td></tr>
<tr class="memdesc:ga9e37b000b12799c3d1852b4096330112"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a value between 0 (bad) and 1 (good) that describes the quality of the area.  <a href="group__lib__grid__algorithms__face__util.html#ga9e37b000b12799c3d1852b4096330112">More...</a><br /></td></tr>
<tr class="separator:ga9e37b000b12799c3d1852b4096330112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e9449fff40c3ebec3af35606dffd26d"><td class="memTemplParams" colspan="2">template&lt;class TAAPosVRT , class TAAWeightVRT &gt; </td></tr>
<tr class="memitem:ga0e9449fff40c3ebec3af35606dffd26d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> TAAPosVRT::ValueType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__face__util.html#ga0e9449fff40c3ebec3af35606dffd26d">ug::CalculateCenter</a> (const <a class="el" href="classug_1_1_face_vertices.html">FaceVertices</a> *f, TAAPosVRT &amp;aaPos, TAAWeightVRT &amp;aaWeight)</td></tr>
<tr class="memdesc:ga0e9449fff40c3ebec3af35606dffd26d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the weighted center of the vertices of the given face  <a href="group__lib__grid__algorithms__face__util.html#ga0e9449fff40c3ebec3af35606dffd26d">More...</a><br /></td></tr>
<tr class="separator:ga0e9449fff40c3ebec3af35606dffd26d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d4668290e6397c61e18291a9e2c0dff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__face__util.html#ga2d4668290e6397c61e18291a9e2c0dff">ug::CalculateFaceNormals</a> (<a class="el" href="classug_1_1_grid.html">Grid</a> &amp;grid, const <a class="el" href="namespaceug.html#a238c06e12b8d23c6fbdf6a9a6de07032">FaceIterator</a> &amp;facesBegin, const <a class="el" href="namespaceug.html#a238c06e12b8d23c6fbdf6a9a6de07032">FaceIterator</a> &amp;facesEnd, <a class="el" href="namespaceug.html#afa6d5df7a310aa9215f9c16eb80b18e7">AVector3</a> &amp;aPos, <a class="el" href="namespaceug.html#afa6d5df7a310aa9215f9c16eb80b18e7">AVector3</a> &amp;aNorm)</td></tr>
<tr class="memdesc:ga2d4668290e6397c61e18291a9e2c0dff"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculates the normal of each face. Presumes that all faces are flat.  <a href="group__lib__grid__algorithms__face__util.html#ga2d4668290e6397c61e18291a9e2c0dff">More...</a><br /></td></tr>
<tr class="separator:ga2d4668290e6397c61e18291a9e2c0dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ae4708519bbc75cd7dacf71d6807448"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__face__util.html#ga2ae4708519bbc75cd7dacf71d6807448">ug::CalculateNormal</a> (<a class="el" href="group__vectors.html#ga894cdb8af74f7a563a94fb49c220fdcd">vector3</a> &amp;vNormOut, const <a class="el" href="classug_1_1_face_vertices.html">FaceVertices</a> *face, <a class="el" href="classug_1_1_grid_1_1_attachment_accessor.html">Grid::AttachmentAccessor</a>&lt; <a class="el" href="classug_1_1_vertex.html">Vertex</a>, <a class="el" href="namespaceug.html#a780dd3524b97269f891365fd3c3b895a">APosition</a> &gt; &amp;aaPos)</td></tr>
<tr class="memdesc:ga2ae4708519bbc75cd7dacf71d6807448"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculates the normal of the given face  <a href="group__lib__grid__algorithms__face__util.html#ga2ae4708519bbc75cd7dacf71d6807448">More...</a><br /></td></tr>
<tr class="separator:ga2ae4708519bbc75cd7dacf71d6807448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga912030fd2018063c84edc5140381bd61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__face__util.html#ga912030fd2018063c84edc5140381bd61">ug::CalculateNormalNoNormalize</a> (<a class="el" href="group__vectors.html#ga894cdb8af74f7a563a94fb49c220fdcd">vector3</a> &amp;vNormOut, <a class="el" href="classug_1_1_face_vertices.html">FaceVertices</a> *face, <a class="el" href="classug_1_1_grid_1_1_attachment_accessor.html">Grid::AttachmentAccessor</a>&lt; <a class="el" href="classug_1_1_vertex.html">Vertex</a>, <a class="el" href="namespaceug.html#a780dd3524b97269f891365fd3c3b895a">APosition</a> &gt; &amp;aaPos)</td></tr>
<tr class="memdesc:ga912030fd2018063c84edc5140381bd61"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculates the normal of the given face  <a href="group__lib__grid__algorithms__face__util.html#ga912030fd2018063c84edc5140381bd61">More...</a><br /></td></tr>
<tr class="separator:ga912030fd2018063c84edc5140381bd61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27555c9331930a1204c71b39aed50c5f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__face__util.html#ga27555c9331930a1204c71b39aed50c5f">ug::CompareVertices</a> (const <a class="el" href="classug_1_1_face_vertices.html">FaceVertices</a> *fv1, const <a class="el" href="classug_1_1_face_vertices.html">FaceVertices</a> *fv2)</td></tr>
<tr class="memdesc:ga27555c9331930a1204c71b39aed50c5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether fv1 and fv2 contain the same vertices.  <a href="group__lib__grid__algorithms__face__util.html#ga27555c9331930a1204c71b39aed50c5f">More...</a><br /></td></tr>
<tr class="separator:ga27555c9331930a1204c71b39aed50c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ca083f629b95067b5b291dd57ba41e9"><td class="memTemplParams" colspan="2">template&lt;class vector_t , class TAAPos &gt; </td></tr>
<tr class="memitem:ga4ca083f629b95067b5b291dd57ba41e9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__face__util.html#ga4ca083f629b95067b5b291dd57ba41e9">ug::ContainsPoint</a> (const <a class="el" href="classug_1_1_face_vertices.html">FaceVertices</a> *f, const vector_t &amp;<a class="elRef" href="../plugins/_biogas_8lua.html#a57f1028d958bb73c4e3c64e2077342fc">p</a>, TAAPos aaPos)</td></tr>
<tr class="memdesc:ga4ca083f629b95067b5b291dd57ba41e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given point lies inside the given face.  <a href="group__lib__grid__algorithms__face__util.html#ga4ca083f629b95067b5b291dd57ba41e9">More...</a><br /></td></tr>
<tr class="separator:ga4ca083f629b95067b5b291dd57ba41e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a51f28ca75577853eaa0de3794980a0"><td class="memTemplParams" colspan="2">template&lt;class TAAPosVRT &gt; </td></tr>
<tr class="memitem:ga1a51f28ca75577853eaa0de3794980a0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> <a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__face__util.html#ga1a51f28ca75577853eaa0de3794980a0">ug::FaceArea</a> (<a class="el" href="classug_1_1_face_vertices.html">FaceVertices</a> *f, TAAPosVRT &amp;aaPos)</td></tr>
<tr class="memdesc:ga1a51f28ca75577853eaa0de3794980a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the area of a convex face.  <a href="group__lib__grid__algorithms__face__util.html#ga1a51f28ca75577853eaa0de3794980a0">More...</a><br /></td></tr>
<tr class="separator:ga1a51f28ca75577853eaa0de3794980a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf351c4d2400a56a6642ef92497f22bd"><td class="memTemplParams" colspan="2">template&lt;class TIterator , class TAAPosVRT &gt; </td></tr>
<tr class="memitem:gaaf351c4d2400a56a6642ef92497f22bd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> <a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__face__util.html#gaaf351c4d2400a56a6642ef92497f22bd">ug::FaceArea</a> (TIterator facesBegin, TIterator facesEnd, TAAPosVRT &amp;aaPos)</td></tr>
<tr class="memdesc:gaaf351c4d2400a56a6642ef92497f22bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the area sum of convex faces.  <a href="group__lib__grid__algorithms__face__util.html#gaaf351c4d2400a56a6642ef92497f22bd">More...</a><br /></td></tr>
<tr class="separator:gaaf351c4d2400a56a6642ef92497f22bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga749cd2682d933d3923aed6387b564d4d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__face__util.html#ga749cd2682d933d3923aed6387b564d4d">ug::FaceContains</a> (<a class="el" href="classug_1_1_face.html">Face</a> *f, <a class="el" href="classug_1_1_edge_vertices.html">EdgeVertices</a> *ev)</td></tr>
<tr class="memdesc:ga749cd2682d933d3923aed6387b564d4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if the given face contains the two given vertices  <a href="group__lib__grid__algorithms__face__util.html#ga749cd2682d933d3923aed6387b564d4d">More...</a><br /></td></tr>
<tr class="separator:ga749cd2682d933d3923aed6387b564d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24e7ebdd741a8bf9e9de43ec8b570b12"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__face__util.html#ga24e7ebdd741a8bf9e9de43ec8b570b12">ug::FaceContains</a> (<a class="el" href="classug_1_1_face_vertices.html">FaceVertices</a> *f, <a class="el" href="classug_1_1_vertex.html">Vertex</a> *v)</td></tr>
<tr class="memdesc:ga24e7ebdd741a8bf9e9de43ec8b570b12"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if the given face contains the given vertex  <a href="group__lib__grid__algorithms__face__util.html#ga24e7ebdd741a8bf9e9de43ec8b570b12">More...</a><br /></td></tr>
<tr class="separator:ga24e7ebdd741a8bf9e9de43ec8b570b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69c2b459338a1d7007d19daabba2df32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__face__util.html#ga69c2b459338a1d7007d19daabba2df32">ug::FaceQuality</a> (<a class="el" href="classug_1_1_face_vertices.html">FaceVertices</a> *f, <a class="el" href="classug_1_1_grid_1_1_vertex_attachment_accessor.html">Grid::VertexAttachmentAccessor</a>&lt; <a class="el" href="namespaceug.html#a780dd3524b97269f891365fd3c3b895a">APosition</a> &gt; aaPos)</td></tr>
<tr class="memdesc:ga69c2b459338a1d7007d19daabba2df32"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple measure for the quality of a face  <a href="group__lib__grid__algorithms__face__util.html#ga69c2b459338a1d7007d19daabba2df32">More...</a><br /></td></tr>
<tr class="separator:ga69c2b459338a1d7007d19daabba2df32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad08429cf628013edea965ef6acd036c7"><td class="memTemplParams" colspan="2">template&lt;class TIterator , class TAAPosVRT &gt; </td></tr>
<tr class="memitem:gad08429cf628013edea965ef6acd036c7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> <a class="el" href="classug_1_1_face.html">Face</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__face__util.html#gad08429cf628013edea965ef6acd036c7">ug::FindSmallestFace</a> (TIterator facesBegin, TIterator facesEnd, TAAPosVRT &amp;aaPos)</td></tr>
<tr class="memdesc:gad08429cf628013edea965ef6acd036c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the face with the smallest area.  <a href="group__lib__grid__algorithms__face__util.html#gad08429cf628013edea965ef6acd036c7">More...</a><br /></td></tr>
<tr class="separator:gad08429cf628013edea965ef6acd036c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad06618d95786eda8fbc7030319075608"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__face__util.html#gad06618d95786eda8fbc7030319075608">ug::GetFaceIndex</a> (<a class="el" href="classug_1_1_volume.html">Volume</a> *vol, <a class="el" href="classug_1_1_face.html">Face</a> *f)</td></tr>
<tr class="memdesc:gad06618d95786eda8fbc7030319075608"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the index at which face f is found in the given object  <a href="group__lib__grid__algorithms__face__util.html#gad06618d95786eda8fbc7030319075608">More...</a><br /></td></tr>
<tr class="separator:gad06618d95786eda8fbc7030319075608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cc5bf9ce5eff9eb09058c99938b6aa0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__face__util.html#ga8cc5bf9ce5eff9eb09058c99938b6aa0">ug::GetNeighbours</a> (std::vector&lt; <a class="el" href="classug_1_1_face.html">Face</a> * &gt; &amp;vFacesOut, <a class="el" href="classug_1_1_grid.html">Grid</a> &amp;grid, <a class="el" href="classug_1_1_face.html">Face</a> *f, int side, bool clearContainer=true)</td></tr>
<tr class="memdesc:ga8cc5bf9ce5eff9eb09058c99938b6aa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">collects neighbours of the given side of a face.  <a href="group__lib__grid__algorithms__face__util.html#ga8cc5bf9ce5eff9eb09058c99938b6aa0">More...</a><br /></td></tr>
<tr class="separator:ga8cc5bf9ce5eff9eb09058c99938b6aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b62fea37b09cfc002c1930766d5fdd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classug_1_1_vertex.html">Vertex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__face__util.html#ga9b62fea37b09cfc002c1930766d5fdd6">ug::GetVertex</a> (<a class="el" href="classug_1_1_face.html">Face</a> *f, size_t i)</td></tr>
<tr class="memdesc:ga9b62fea37b09cfc002c1930766d5fdd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the i'th vertex of a face  <a href="group__lib__grid__algorithms__face__util.html#ga9b62fea37b09cfc002c1930766d5fdd6">More...</a><br /></td></tr>
<tr class="separator:ga9b62fea37b09cfc002c1930766d5fdd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad75663712608cfcd1d1e432a0198593a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__face__util.html#gad75663712608cfcd1d1e432a0198593a">ug::InsertCenterVertex</a> (<a class="el" href="classug_1_1_grid.html">Grid</a> &amp;g, <a class="el" href="classug_1_1_face.html">Face</a> *f, <a class="el" href="classug_1_1_vertex.html">Vertex</a> *vrt, bool eraseOldFace)</td></tr>
<tr class="memdesc:gad75663712608cfcd1d1e432a0198593a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refines the face by connecting its sides with the new center.  <a href="group__lib__grid__algorithms__face__util.html#gad75663712608cfcd1d1e432a0198593a">More...</a><br /></td></tr>
<tr class="separator:gad75663712608cfcd1d1e432a0198593a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13333d7cf4577f562d1a92d1b3fc4c5e"><td class="memTemplParams" colspan="2">template&lt;class TFace &gt; </td></tr>
<tr class="memitem:ga13333d7cf4577f562d1a92d1b3fc4c5e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__face__util.html#ga13333d7cf4577f562d1a92d1b3fc4c5e">ug::IsBoundaryFace3D</a> (<a class="el" href="classug_1_1_grid.html">Grid</a> &amp;grid, TFace *f)</td></tr>
<tr class="memdesc:ga13333d7cf4577f562d1a92d1b3fc4c5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper for IsVolumeBoundaryFace.  <a href="group__lib__grid__algorithms__face__util.html#ga13333d7cf4577f562d1a92d1b3fc4c5e">More...</a><br /></td></tr>
<tr class="separator:ga13333d7cf4577f562d1a92d1b3fc4c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07103928668c01fbc9a92a670a9ba9e4"><td class="memTemplParams" colspan="2">template&lt;class TAAPosVRT &gt; </td></tr>
<tr class="memitem:ga07103928668c01fbc9a92a670a9ba9e4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__face__util.html#ga07103928668c01fbc9a92a670a9ba9e4">ug::IsDegenerated</a> (<a class="el" href="classug_1_1_face.html">Face</a> *f, TAAPosVRT &amp;aaPos, <a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a> threshold=<a class="el" href="namespaceug.html#a33c1491a216aec0f5a603a9a3dd6f758">SMALL</a>)</td></tr>
<tr class="memdesc:ga07103928668c01fbc9a92a670a9ba9e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if the given face is degenerated.  <a href="group__lib__grid__algorithms__face__util.html#ga07103928668c01fbc9a92a670a9ba9e4">More...</a><br /></td></tr>
<tr class="separator:ga07103928668c01fbc9a92a670a9ba9e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6612d9dd1c1ccd191d67a1a1e6718156"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__face__util.html#ga6612d9dd1c1ccd191d67a1a1e6718156">ug::IsVolumeBoundaryFace</a> (<a class="el" href="classug_1_1_grid.html">Grid</a> &amp;grid, <a class="el" href="classug_1_1_constrained_face.html">ConstrainedFace</a> *f)</td></tr>
<tr class="memdesc:ga6612d9dd1c1ccd191d67a1a1e6718156"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if the given face is a boundary face.  <a href="group__lib__grid__algorithms__face__util.html#ga6612d9dd1c1ccd191d67a1a1e6718156">More...</a><br /></td></tr>
<tr class="separator:ga6612d9dd1c1ccd191d67a1a1e6718156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e9dfa154c5ab46e2f77c4a48a8ee98c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__face__util.html#ga4e9dfa154c5ab46e2f77c4a48a8ee98c">ug::IsVolumeBoundaryFace</a> (<a class="el" href="classug_1_1_grid.html">Grid</a> &amp;grid, <a class="el" href="classug_1_1_constraining_face.html">ConstrainingFace</a> *f)</td></tr>
<tr class="memdesc:ga4e9dfa154c5ab46e2f77c4a48a8ee98c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if the given face is a boundary face.  <a href="group__lib__grid__algorithms__face__util.html#ga4e9dfa154c5ab46e2f77c4a48a8ee98c">More...</a><br /></td></tr>
<tr class="separator:ga4e9dfa154c5ab46e2f77c4a48a8ee98c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd8032868d5b1b81c1d0171156ce7acd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__face__util.html#gafd8032868d5b1b81c1d0171156ce7acd">ug::IsVolumeBoundaryFace</a> (<a class="el" href="classug_1_1_grid.html">Grid</a> &amp;grid, <a class="el" href="classug_1_1_face.html">Face</a> *f)</td></tr>
<tr class="memdesc:gafd8032868d5b1b81c1d0171156ce7acd"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if the given face is a boundary face.  <a href="group__lib__grid__algorithms__face__util.html#gafd8032868d5b1b81c1d0171156ce7acd">More...</a><br /></td></tr>
<tr class="separator:gafd8032868d5b1b81c1d0171156ce7acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga546524dbafff353c160a8e52acb90260"><td class="memTemplParams" colspan="2">template&lt;class TFace &gt; </td></tr>
<tr class="memitem:ga546524dbafff353c160a8e52acb90260"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__face__util.html#ga546524dbafff353c160a8e52acb90260">ug::LiesOnBoundary</a> (<a class="el" href="classug_1_1_grid.html">Grid</a> &amp;grid, TFace *f)</td></tr>
<tr class="memdesc:ga546524dbafff353c160a8e52acb90260"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper for IsVolumeBoundaryFace.  <a href="group__lib__grid__algorithms__face__util.html#ga546524dbafff353c160a8e52acb90260">More...</a><br /></td></tr>
<tr class="separator:ga546524dbafff353c160a8e52acb90260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e099f969485473fadd5113b40fe508a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__face__util.html#ga2e099f969485473fadd5113b40fe508a">ug::NumAssociatedVolumes</a> (<a class="el" href="classug_1_1_grid.html">Grid</a> &amp;grid, <a class="el" href="classug_1_1_face.html">Face</a> *f)</td></tr>
<tr class="memdesc:ga2e099f969485473fadd5113b40fe508a"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the number of associated volumes of the specified face  <a href="group__lib__grid__algorithms__face__util.html#ga2e099f969485473fadd5113b40fe508a">More...</a><br /></td></tr>
<tr class="separator:ga2e099f969485473fadd5113b40fe508a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ed3a8995006d786f63e318b7f6c358f"><td class="memTemplParams" colspan="2">template&lt;class TAAPosVRT &gt; </td></tr>
<tr class="memitem:ga9ed3a8995006d786f63e318b7f6c358f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__face__util.html#ga9ed3a8995006d786f63e318b7f6c358f">ug::PointFaceTest</a> (<a class="el" href="group__vectors.html#ga894cdb8af74f7a563a94fb49c220fdcd">vector3</a> &amp;v, <a class="el" href="classug_1_1_face.html">Face</a> *f, TAAPosVRT &amp;aaPos)</td></tr>
<tr class="separator:ga9ed3a8995006d786f63e318b7f6c358f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe4b069038c2eb0c0284efde3a3bd64b"><td class="memTemplParams" colspan="2">template&lt;class TTriangleIterator , class TAAPosVRT &gt; </td></tr>
<tr class="memitem:gabe4b069038c2eb0c0284efde3a3bd64b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__face__util.html#gabe4b069038c2eb0c0284efde3a3bd64b">ug::ProjectPointToSurface</a> (<a class="el" href="group__vectors.html#ga894cdb8af74f7a563a94fb49c220fdcd">vector3</a> &amp;vOut, const <a class="el" href="group__vectors.html#ga894cdb8af74f7a563a94fb49c220fdcd">vector3</a> &amp;v, const <a class="el" href="group__vectors.html#ga894cdb8af74f7a563a94fb49c220fdcd">vector3</a> &amp;n, TTriangleIterator trisBegin, TTriangleIterator trisEnd, TAAPosVRT &amp;aaPos, bool compareNormals=false)</td></tr>
<tr class="separator:gabe4b069038c2eb0c0284efde3a3bd64b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae772e4fd343550a940e172b770faaf1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__face__util.html#gae772e4fd343550a940e172b770faaf1b">ug::TriangleQuality</a> (<a class="el" href="group__vectors.html#ga894cdb8af74f7a563a94fb49c220fdcd">vector3</a> &amp;v1, <a class="el" href="group__vectors.html#ga894cdb8af74f7a563a94fb49c220fdcd">vector3</a> &amp;v2, <a class="el" href="group__vectors.html#ga894cdb8af74f7a563a94fb49c220fdcd">vector3</a> &amp;v3)</td></tr>
<tr class="memdesc:gae772e4fd343550a940e172b770faaf1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple measure for the quality of a triangle  <a href="group__lib__grid__algorithms__face__util.html#gae772e4fd343550a940e172b770faaf1b">More...</a><br /></td></tr>
<tr class="separator:gae772e4fd343550a940e172b770faaf1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e830eb2ca680c580b9309aa4f9c445e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__face__util.html#ga5e830eb2ca680c580b9309aa4f9c445e">ug::Triangulate</a> (<a class="el" href="classug_1_1_grid.html">Grid</a> &amp;grid, <a class="el" href="classug_1_1_grid_1_1_vertex_attachment_accessor.html">Grid::VertexAttachmentAccessor</a>&lt; <a class="el" href="namespaceug.html#a780dd3524b97269f891365fd3c3b895a">APosition</a> &gt; *paaPos=NULL)</td></tr>
<tr class="separator:ga5e830eb2ca680c580b9309aa4f9c445e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5dd5ed95ed5f64fd5d29133769324be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__face__util.html#gac5dd5ed95ed5f64fd5d29133769324be">ug::Triangulate</a> (<a class="el" href="classug_1_1_grid.html">Grid</a> &amp;grid, <a class="el" href="classug_1_1_quadrilateral.html">Quadrilateral</a> *q, <a class="el" href="classug_1_1_grid_1_1_vertex_attachment_accessor.html">Grid::VertexAttachmentAccessor</a>&lt; <a class="el" href="namespaceug.html#a780dd3524b97269f891365fd3c3b895a">APosition</a> &gt; *paaPos=NULL)</td></tr>
<tr class="memdesc:gac5dd5ed95ed5f64fd5d29133769324be"><td class="mdescLeft">&#160;</td><td class="mdescRight">removes the quadrilateral and replaces it by two triangles.  <a href="group__lib__grid__algorithms__face__util.html#gac5dd5ed95ed5f64fd5d29133769324be">More...</a><br /></td></tr>
<tr class="separator:gac5dd5ed95ed5f64fd5d29133769324be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b4fdf52742a3186bfd3473b2f028926"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__face__util.html#ga2b4fdf52742a3186bfd3473b2f028926">ug::Triangulate</a> (<a class="el" href="classug_1_1_grid.html">Grid</a> &amp;grid, <a class="el" href="namespaceug.html#a15ffcc65340980c745bdf5de374b100a">QuadrilateralIterator</a> iterBegin, <a class="el" href="namespaceug.html#a15ffcc65340980c745bdf5de374b100a">QuadrilateralIterator</a> iterEnd, <a class="el" href="classug_1_1_grid_1_1_vertex_attachment_accessor.html">Grid::VertexAttachmentAccessor</a>&lt; <a class="el" href="namespaceug.html#a780dd3524b97269f891365fd3c3b895a">APosition</a> &gt; *paaPos=NULL)</td></tr>
<tr class="memdesc:ga2b4fdf52742a3186bfd3473b2f028926"><td class="mdescLeft">&#160;</td><td class="mdescRight">replaces all specified quadrilaterals by triangles.  <a href="group__lib__grid__algorithms__face__util.html#ga2b4fdf52742a3186bfd3473b2f028926">More...</a><br /></td></tr>
<tr class="separator:ga2b4fdf52742a3186bfd3473b2f028926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9efe78d6ae9b5ed2ef2b832ff2520942"><td class="memTemplParams" colspan="2">template&lt;class TVertexPositionAttachmentAccessor &gt; </td></tr>
<tr class="memitem:ga9efe78d6ae9b5ed2ef2b832ff2520942"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> TVertexPositionAttachmentAccessor::ValueType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__grid__algorithms__face__util.html#ga9efe78d6ae9b5ed2ef2b832ff2520942">ug::CalculateCenter</a> (const <a class="el" href="classug_1_1_face_vertices.html">FaceVertices</a> *f, TVertexPositionAttachmentAccessor &amp;aaPosVRT)</td></tr>
<tr class="memdesc:ga9efe78d6ae9b5ed2ef2b832ff2520942"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculates the center of a face.  <a href="group__lib__grid__algorithms__face__util.html#ga9efe78d6ae9b5ed2ef2b832ff2520942">More...</a><br /></td></tr>
<tr class="separator:ga9efe78d6ae9b5ed2ef2b832ff2520942"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>contains methods to manipulate faces </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga9e37b000b12799c3d1852b4096330112"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e37b000b12799c3d1852b4096330112">&#9670;&nbsp;</a></span>AreaFaceQuality()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> <a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a> ug::AreaFaceQuality </td>
          <td>(</td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>facesBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>facesEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid_1_1_vertex_attachment_accessor.html">Grid::VertexAttachmentAccessor</a>&lt; <a class="el" href="namespaceug.html#a780dd3524b97269f891365fd3c3b895a">APosition</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>aaPos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns a value between 0 (bad) and 1 (good) that describes the quality of the area. </p>
<p>returns the worst FaceQuality of the faces between facesBegin and FacesEnd. TIterator has to be an iterator with a value-type compatible to Face*. </p>

<p class="reference">References <a class="el" href="group__lib__grid__algorithms__face__util.html#ga69c2b459338a1d7007d19daabba2df32">ug::FaceQuality()</a>.</p>

</div>
</div>
<a id="ga0e9449fff40c3ebec3af35606dffd26d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e9449fff40c3ebec3af35606dffd26d">&#9670;&nbsp;</a></span>CalculateCenter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TAAPosVRT , class TAAWeightVRT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> TAAPosVRT::ValueType ug::CalculateCenter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classug_1_1_face_vertices.html">FaceVertices</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TAAPosVRT &amp;&#160;</td>
          <td class="paramname"><em>aaPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TAAWeightVRT &amp;&#160;</td>
          <td class="paramname"><em>aaWeight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the weighted center of the vertices of the given face </p>
<p>TAAWeightVRT has to be an attachment to the vertices of the grid in which f is contained, with ValueType number (or compatible). </p>

<p class="reference">References <a class="el" href="classug_1_1_face_vertices.html#a91c22d6b5fcc4c90e359685aafe2aa19">ug::FaceVertices::num_vertices()</a>, <a class="el" href="group__vectors.html#gaa0cd3e6bb61c8e341541f8cf3065ec6d">ug::VecScale()</a>, <a class="el" href="group__vectors.html#ga02a8ab32c0b406dc365cc6fb8da1e046">ug::VecScaleAppend()</a>, <a class="el" href="group__vectors.html#ga37c542a5b243f331a1d8bb74d331ba4e">ug::VecSet()</a>, and <a class="el" href="classug_1_1_face_vertices.html#a6b0da4dcacca2cec9869b7a87ad6381b">ug::FaceVertices::vertices()</a>.</p>

</div>
</div>
<a id="ga9efe78d6ae9b5ed2ef2b832ff2520942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9efe78d6ae9b5ed2ef2b832ff2520942">&#9670;&nbsp;</a></span>CalculateCenter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TVertexPositionAttachmentAccessor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> TVertexPositionAttachmentAccessor::ValueType ug::CalculateCenter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classug_1_1_face_vertices.html">FaceVertices</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TVertexPositionAttachmentAccessor &amp;&#160;</td>
          <td class="paramname"><em>aaPosVRT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculates the center of a face. </p>
<p>TVertexPositionAttachmentAccessor has to be an <a class="el" href="classug_1_1_attachment_accessor.html" title="Used to access data that has been attached to an attachment pipe.">AttachmentAccessor</a>, where <a class="el" href="classug_1_1_attachment_accessor.html#a79fa03225fc8c46324d6e10df2d62d14">AttachmentAccessor::ValueType</a> is a vector-type compatible to the lgmath vector descriptor. The accessor has to access an attachment of the vertices, to which f refers. </p>

<p class="reference">References <a class="el" href="classug_1_1_face_vertices.html#a91c22d6b5fcc4c90e359685aafe2aa19">ug::FaceVertices::num_vertices()</a>, <a class="el" href="group__vectors.html#ga945c247d94409091fd35fdbbcb5032c2">ug::VecAdd()</a>, <a class="el" href="group__vectors.html#gaa0cd3e6bb61c8e341541f8cf3065ec6d">ug::VecScale()</a>, <a class="el" href="group__vectors.html#ga37c542a5b243f331a1d8bb74d331ba4e">ug::VecSet()</a>, and <a class="el" href="classug_1_1_face_vertices.html#a6b0da4dcacca2cec9869b7a87ad6381b">ug::FaceVertices::vertices()</a>.</p>

</div>
</div>
<a id="ga2d4668290e6397c61e18291a9e2c0dff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d4668290e6397c61e18291a9e2c0dff">&#9670;&nbsp;</a></span>CalculateFaceNormals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ug::CalculateFaceNormals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid.html">Grid</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceug.html#a238c06e12b8d23c6fbdf6a9a6de07032">FaceIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>facesBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceug.html#a238c06e12b8d23c6fbdf6a9a6de07032">FaceIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>facesEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceug.html#afa6d5df7a310aa9215f9c16eb80b18e7">AVector3</a> &amp;&#160;</td>
          <td class="paramname"><em>aPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceug.html#afa6d5df7a310aa9215f9c16eb80b18e7">AVector3</a> &amp;&#160;</td>
          <td class="paramname"><em>aNorm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculates the normal of each face. Presumes that all faces are flat. </p>
<p>aPos has to be attached to the vertices of the grid. aPos should contain the position data. Normals will be written to aNorm (face attachment). </p>

<p class="reference">References <a class="el" href="classug_1_1_grid.html#ac9c0701186e8a7c423abef48b8e9a7ff">ug::Grid::attach_to_faces()</a>, <a class="el" href="group__lib__grid__algorithms__face__util.html#ga2ae4708519bbc75cd7dacf71d6807448">ug::CalculateNormal()</a>, <a class="el" href="classug_1_1_grid.html#a45503abb713915f659b770239f9dca97">ug::Grid::has_face_attachment()</a>, and <a class="el" href="classug_1_1_grid.html#ace5ab805d91e2051d93f4d54d24fa605">ug::Grid::has_vertex_attachment()</a>.</p>

</div>
</div>
<a id="ga2ae4708519bbc75cd7dacf71d6807448"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ae4708519bbc75cd7dacf71d6807448">&#9670;&nbsp;</a></span>CalculateNormal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> void ug::CalculateNormal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__vectors.html#ga894cdb8af74f7a563a94fb49c220fdcd">vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>vNormOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classug_1_1_face_vertices.html">FaceVertices</a> *&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid_1_1_attachment_accessor.html">Grid::AttachmentAccessor</a>&lt; <a class="el" href="classug_1_1_vertex.html">Vertex</a>, <a class="el" href="namespaceug.html#a780dd3524b97269f891365fd3c3b895a">APosition</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>aaPos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculates the normal of the given face </p>
<p>aaPos has to be a valid positition-attachment-accessor to the vertices of the grid which contains the face. if the face contains less than 3 vertices (0, 0, 0) will be written to vNormOut (this should never happen!). For triangles the normal is calculated using the standard cross-product. for quadrilaterals the normals of the two sub-triangles (0, 1, 2) and (2, 3, 0) is calculated and averaged. If the face contains more than 4 vertices the normal of the first sub-triangle is returned.</p>
<p>Performs normalization on the calcluated normals. </p>

<p class="reference">References <a class="el" href="group__vectors.html#ga88538c0d45b51a0f8b592761462e7ee1">ug::CalculateTriangleNormal()</a>, <a class="el" href="group__vectors.html#ga5be9ee257bccce9d31593bbb39f337e8">ug::CalculateTriangleNormalNoNormalize()</a>, <a class="el" href="classug_1_1_face_vertices.html#a91c22d6b5fcc4c90e359685aafe2aa19">ug::FaceVertices::num_vertices()</a>, <a class="el" href="group__vectors.html#ga945c247d94409091fd35fdbbcb5032c2">ug::VecAdd()</a>, <a class="el" href="group__vectors.html#ga53ae2dda87330ab64fb2a5901606b3e4">ug::VecNormalize()</a>, and <a class="el" href="classug_1_1_face_vertices.html#a8f18cc58d9b6142a2d3728cfe55159d1">ug::FaceVertices::vertex()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__lib__grid__algorithms__face__util.html#ga2d4668290e6397c61e18291a9e2c0dff">ug::CalculateFaceNormals()</a>.</p>

</div>
</div>
<a id="ga912030fd2018063c84edc5140381bd61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga912030fd2018063c84edc5140381bd61">&#9670;&nbsp;</a></span>CalculateNormalNoNormalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> void ug::CalculateNormalNoNormalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__vectors.html#ga894cdb8af74f7a563a94fb49c220fdcd">vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>vNormOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_face_vertices.html">FaceVertices</a> *&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid_1_1_attachment_accessor.html">Grid::AttachmentAccessor</a>&lt; <a class="el" href="classug_1_1_vertex.html">Vertex</a>, <a class="el" href="namespaceug.html#a780dd3524b97269f891365fd3c3b895a">APosition</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>aaPos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculates the normal of the given face </p>
<p>aaPos has to be a valid positition-attachment-accessor to the vertices of the grid which contains the face. if the face contains less than 3 vertices (0, 0, 0) will be written to vNormOut (this should never happen!). For triangles the normal is calculated using the standard cross-product. for quadrilaterals the normals of the two sub-triangles (0, 1, 2) and (2, 3, 0) is calculated and averaged. If the face contains more than 4 vertices the normal of the first sub-triangle is returned.</p>
<p>performs no normalization on the calculated normals </p>

<p class="reference">References <a class="el" href="group__vectors.html#ga5be9ee257bccce9d31593bbb39f337e8">ug::CalculateTriangleNormalNoNormalize()</a>, <a class="el" href="classug_1_1_face_vertices.html#a91c22d6b5fcc4c90e359685aafe2aa19">ug::FaceVertices::num_vertices()</a>, <a class="el" href="group__vectors.html#ga945c247d94409091fd35fdbbcb5032c2">ug::VecAdd()</a>, <a class="el" href="group__vectors.html#gaa0cd3e6bb61c8e341541f8cf3065ec6d">ug::VecScale()</a>, and <a class="el" href="classug_1_1_face_vertices.html#a8f18cc58d9b6142a2d3728cfe55159d1">ug::FaceVertices::vertex()</a>.</p>

</div>
</div>
<a id="ga27555c9331930a1204c71b39aed50c5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27555c9331930a1204c71b39aed50c5f">&#9670;&nbsp;</a></span>CompareVertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> bool ug::CompareVertices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classug_1_1_face_vertices.html">FaceVertices</a> *&#160;</td>
          <td class="paramname"><em>fv1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classug_1_1_face_vertices.html">FaceVertices</a> *&#160;</td>
          <td class="paramname"><em>fv2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether fv1 and fv2 contain the same vertices. </p>
<p>Can be used to compare <a class="el" href="classug_1_1_face.html" title="Faces are 2-dimensional objects.">Face</a> with <a class="el" href="classug_1_1_face.html" title="Faces are 2-dimensional objects.">Face</a>, <a class="el" href="classug_1_1_face_descriptor.html" title="Can be queried for the edges and vertices of a face.">FaceDescriptor</a> with <a class="el" href="classug_1_1_face_descriptor.html" title="Can be queried for the edges and vertices of a face.">FaceDescriptor</a> or <a class="el" href="classug_1_1_face.html" title="Faces are 2-dimensional objects.">Face</a> with <a class="el" href="classug_1_1_face_descriptor.html" title="Can be queried for the edges and vertices of a face.">FaceDescriptor</a>.</p>
<p>Before calling this method one should consider to compare the hashes of fv1 and fv2 (if(hash_key(fv1) == hash_key(fv2))...) </p>

<p class="reference">References <a class="el" href="classug_1_1_face_vertices.html#a91c22d6b5fcc4c90e359685aafe2aa19">ug::FaceVertices::num_vertices()</a>, and <a class="el" href="classug_1_1_face_vertices.html#a6b0da4dcacca2cec9869b7a87ad6381b">ug::FaceVertices::vertices()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__lib__grid__algorithms__edge__util.html#ga9f7b8169cfae5eb50fc502401c9d8fde">ug::EdgeCollapseIsValid()</a>, <a class="el" href="classug_1_1_grid.html#a2fe74d9fb86285be678755cb3386aad5">ug::Grid::find_face_in_associated_faces()</a>, <a class="el" href="classug_1_1_grid.html#aa7bc21a18e597733f035b131688428f9">ug::Grid::find_volume_in_associated_volumes()</a>, <a class="el" href="classug_1_1_face.html#a70e271603f5ff107a8d92758a954d222">ug::Face::get_local_side_index()</a>, <a class="el" href="classug_1_1_volume.html#a164a8f5e6d87048a523983d877699042">ug::Volume::get_local_side_index()</a>, <a class="el" href="group__lib__grid__algorithms__edge__util.html#ga1630d8ea9135b8305a86bdece82d93f0">ug::GetEdgeIndex()</a>, <a class="el" href="group__lib__grid__algorithms__face__util.html#gad06618d95786eda8fbc7030319075608">ug::GetFaceIndex()</a>, <a class="el" href="namespaceug.html#a15b0673ef4bd274edd53c30c692803cf">ug::GetOpposingSide()</a>, <a class="el" href="namespaceug.html#adeff1790eedba598dcfb5bf5d616fc1a">ug::GetRightLeftUnitIndex()</a>, <a class="el" href="classug_1_1_multi_grid.html#a544579dbb0f7a011880b43c8302934dc">ug::MultiGrid::num()</a>, <a class="el" href="namespaceug.html#a49cd55fe7c2f2287bcf35ab5a9ffe176">ug::OrientationMatches()</a>, <a class="el" href="classug_1_1_grid.html#a644ae17aeee55fd8e22162e2bf9e9a67">ug::Grid::register_edge()</a>, <a class="el" href="namespaceug.html#ad0e0eb8fc0aac764a89018b792951ee6">ug::RemoveDuplicates()</a>, and <a class="el" href="classug_1_1_grid.html#a397e256b906193758891fedb990b0e71">ug::Grid::volume_sort_associated_edge_container()</a>.</p>

</div>
</div>
<a id="ga4ca083f629b95067b5b291dd57ba41e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ca083f629b95067b5b291dd57ba41e9">&#9670;&nbsp;</a></span>ContainsPoint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class vector_t , class TAAPos &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> bool ug::ContainsPoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classug_1_1_face_vertices.html">FaceVertices</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_t &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TAAPos&#160;</td>
          <td class="paramname"><em>aaPos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given point lies inside the given face. </p>
<dl class="section note"><dt>Note</dt><dd>The method only works properly, if the point and the face are located in the same x-y-plane. </dd></dl>

<p class="reference">References <a class="el" href="classug_1_1_face_vertices.html#a91c22d6b5fcc4c90e359685aafe2aa19">ug::FaceVertices::num_vertices()</a>, <a class="elRef" href="../plugins/_biogas_8lua.html#a57f1028d958bb73c4e3c64e2077342fc">p</a>, <a class="el" href="group__ugbase__mathutil.html#ga12b4ed922ad23eb842a5f2fc18e0f6be">ug::PointIsInsideQuadrilateral()</a>, <a class="el" href="group__ugbase__mathutil.html#ga4e050e3d7b5ee4407eecaece9de6d064">ug::PointIsInsideTriangle()</a>, <a class="el" href="group__ugbase__common.html#ga43687df88af405f6ac7058dd3639993d">UG_THROW</a>, and <a class="el" href="classug_1_1_face_vertices.html#a8f18cc58d9b6142a2d3728cfe55159d1">ug::FaceVertices::vertex()</a>.</p>

</div>
</div>
<a id="ga1a51f28ca75577853eaa0de3794980a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a51f28ca75577853eaa0de3794980a0">&#9670;&nbsp;</a></span>FaceArea() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TAAPosVRT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> <a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a> ug::FaceArea </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_face_vertices.html">FaceVertices</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TAAPosVRT &amp;&#160;</td>
          <td class="paramname"><em>aaPos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the area of a convex face. </p>

<p class="reference">References <a class="el" href="classug_1_1_face_vertices.html#a91c22d6b5fcc4c90e359685aafe2aa19">ug::FaceVertices::num_vertices()</a>, <a class="el" href="group__ugbase__mathutil.html#ga0d8b23331ba6dc60c99af44d50758e9f">ug::TriangleArea()</a>, and <a class="el" href="classug_1_1_face_vertices.html#a8f18cc58d9b6142a2d3728cfe55159d1">ug::FaceVertices::vertex()</a>.</p>

</div>
</div>
<a id="gaaf351c4d2400a56a6642ef92497f22bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf351c4d2400a56a6642ef92497f22bd">&#9670;&nbsp;</a></span>FaceArea() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TIterator , class TAAPosVRT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> <a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a> ug::FaceArea </td>
          <td>(</td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>facesBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>facesEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TAAPosVRT &amp;&#160;</td>
          <td class="paramname"><em>aaPos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the area sum of convex faces. </p>

<p class="reference">References <a class="el" href="group__domain__bridge.html#ga92317ceec1e4b3340d0956d8709024e4">ug::FaceArea()</a>.</p>

</div>
</div>
<a id="ga749cd2682d933d3923aed6387b564d4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga749cd2682d933d3923aed6387b564d4d">&#9670;&nbsp;</a></span>FaceContains() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> bool ug::FaceContains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_face.html">Face</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_edge_vertices.html">EdgeVertices</a> *&#160;</td>
          <td class="paramname"><em>ev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns true if the given face contains the two given vertices </p>
<p>returns true if the given face contains the given edge </p>

<p class="reference">References <a class="el" href="group__lib__grid__algorithms__volume__util.html#ga71697540df69ad33d455c45ac337f9fe">ug::CompareVertices()</a>, <a class="el" href="classug_1_1_face.html#a58d3b73e59ed266bdb6558c759ec0d51">ug::Face::edge_desc()</a>, and <a class="el" href="classug_1_1_face.html#ab2a35640fa0837cabc630c7287cd4340">ug::Face::num_edges()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__lib__grid__algorithms__vertex__util.html#ga4c2796a9f87efa8c0cb25f5d8f8e3458">ug::CalculateBoundaryVertexNormal3D()</a>, <a class="el" href="namespaceug.html#ad4308003b1bcbd1af40626d00447bb88">ug::CalculateCreaseNormal()</a>, <a class="el" href="namespaceug.html#a08443c2eab8aef136eef22d01b0e744b">ug::CollectAssociatedSides()</a>, <a class="el" href="namespaceug.html#ad27c6ba35e44b1e247b79f2e61ee6937">ug::ProjectVerticesToCloseFaces()</a>, <a class="el" href="classug_1_1_grid.html#afed82089e45ac6b3a7c52bc38bda0e57">ug::Grid::replace_vertex_is_valid()</a>, <a class="el" href="namespaceug.html#ab49bd7b2589650c86c2e3c5354ab23a7">ug::ResolveEdgeFaceIntersection()</a>, and <a class="el" href="namespaceug.html#a5d02c001317ea98280382921614e1a8f">ug::ResolveVertexFaceIntersection()</a>.</p>

</div>
</div>
<a id="ga24e7ebdd741a8bf9e9de43ec8b570b12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24e7ebdd741a8bf9e9de43ec8b570b12">&#9670;&nbsp;</a></span>FaceContains() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ug::FaceContains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_face_vertices.html">FaceVertices</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns true if the given face contains the given vertex </p>
<p>returns true if the given face contains exactly the same points as the given descriptor.</p>
<p>returns true if the given face contains the given vertex </p>

<p class="reference">References <a class="el" href="classug_1_1_face_vertices.html#a91c22d6b5fcc4c90e359685aafe2aa19">ug::FaceVertices::num_vertices()</a>, and <a class="el" href="classug_1_1_face_vertices.html#a6b0da4dcacca2cec9869b7a87ad6381b">ug::FaceVertices::vertices()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__lib__grid__algorithms__neighborhood__util.html#gae5cccb31e550f7f750f141b7b52c63ec">ug::CollectFaces()</a>.</p>

</div>
</div>
<a id="ga69c2b459338a1d7007d19daabba2df32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69c2b459338a1d7007d19daabba2df32">&#9670;&nbsp;</a></span>FaceQuality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> <a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a> ug::FaceQuality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_face_vertices.html">FaceVertices</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid_1_1_vertex_attachment_accessor.html">Grid::VertexAttachmentAccessor</a>&lt; <a class="el" href="namespaceug.html#a780dd3524b97269f891365fd3c3b895a">APosition</a> &gt;&#160;</td>
          <td class="paramname"><em>aaPos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a simple measure for the quality of a face </p>
<p>returns a value between 0 and 1, where 1 indicates a good quality and 0 a bad. This method checks the dot-products of edges at the corners. The worst one (closest to 1 or -1) determines the quality. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__lib__grid__algorithms__face__util.html#gae772e4fd343550a940e172b770faaf1b" title="a simple measure for the quality of a triangle">TriangleQuality</a> </dd></dl>

<p class="reference">References <a class="el" href="classug_1_1_face_vertices.html#a91c22d6b5fcc4c90e359685aafe2aa19">ug::FaceVertices::num_vertices()</a>, <a class="el" href="group__vectors.html#gae9174d47662deb0ba119e0e21f28ec71">ug::VecDot()</a>, <a class="el" href="group__vectors.html#ga017412e0fb3129d2584d77125e692faf">ug::VecLength()</a>, <a class="el" href="group__vectors.html#gaa0cd3e6bb61c8e341541f8cf3065ec6d">ug::VecScale()</a>, <a class="el" href="group__vectors.html#ga5c7eda5aeb4cd0d53ce04f682d0a0058">ug::VecSubtract()</a>, and <a class="el" href="classug_1_1_face_vertices.html#a8f18cc58d9b6142a2d3728cfe55159d1">ug::FaceVertices::vertex()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__lib__grid__algorithms__face__util.html#ga9e37b000b12799c3d1852b4096330112">ug::AreaFaceQuality()</a>, <a class="el" href="namespaceug.html#ac74fc55bfe7ebece65e282d50571bda0">ug::AssignSubsetsByQuality()</a>, and <a class="el" href="namespaceug.html#a1542104ac2ce93ffd11d323508e03f52">ug::ReplaceByQuadrilaterals_EdgeBased()</a>.</p>

</div>
</div>
<a id="gad08429cf628013edea965ef6acd036c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad08429cf628013edea965ef6acd036c7">&#9670;&nbsp;</a></span>FindSmallestFace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TIterator , class TAAPosVRT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> <a class="el" href="classug_1_1_face.html">Face</a>* ug::FindSmallestFace </td>
          <td>(</td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>facesBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>facesEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TAAPosVRT &amp;&#160;</td>
          <td class="paramname"><em>aaPos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the face with the smallest area. </p>
<p>Make sure that TIterator::value_type equals Face* and that aaPos operates on the grid from which the faces were taken. </p>

<p class="reference">References <a class="el" href="group__domain__bridge.html#ga92317ceec1e4b3340d0956d8709024e4">ug::FaceArea()</a>.</p>

</div>
</div>
<a id="gad06618d95786eda8fbc7030319075608"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad06618d95786eda8fbc7030319075608">&#9670;&nbsp;</a></span>GetFaceIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> int ug::GetFaceIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_volume.html">Volume</a> *&#160;</td>
          <td class="paramname"><em>vol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_face.html">Face</a> *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the index at which face f is found in the given object </p>
<p>returns -1 if the face was not found. </p>

<p class="reference">References <a class="el" href="group__lib__grid__algorithms__face__util.html#ga27555c9331930a1204c71b39aed50c5f">ug::CompareVertices()</a>, <a class="el" href="classug_1_1_volume.html#a2cc6c78635a58f178b7e9a48255df5a0">ug::Volume::face_desc()</a>, and <a class="el" href="classug_1_1_volume.html#adbca5f25aac929300e37aed9878e9b01">ug::Volume::num_faces()</a>.</p>

<p class="reference">Referenced by <a class="el" href="namespaceug.html#aaa6dc6e820042160919759e9d5f80c18">ug::CreateHexahedronFromPrisms()</a>, and <a class="el" href="classug_1_1_i_refiner.html#a615aa48d59030c11599609b775e4c4cc">ug::IRefiner::get_local_face_mark()</a>.</p>

</div>
</div>
<a id="ga8cc5bf9ce5eff9eb09058c99938b6aa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8cc5bf9ce5eff9eb09058c99938b6aa0">&#9670;&nbsp;</a></span>GetNeighbours()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> void ug::GetNeighbours </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classug_1_1_face.html">Face</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>vFacesOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid.html">Grid</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_face.html">Face</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>clearContainer</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>collects neighbours of the given side of a face. </p>
<p>collects all faces that are adjacent to the given side of f. </p>

<p class="reference">References <a class="el" href="group__lib__grid__algorithms__neighborhood__util.html#gae78d5b92ef32b1bd35364affde2ca69e">ug::CollectFaces()</a>, <a class="el" href="classug_1_1_grid.html#ae94bdb2aa02392c63f9f15bde3d21328">ug::Grid::enable_options()</a>, <a class="el" href="group__lib__grid.html#ggad5f5a639937a67f1018d12996992f6f3a91ebc7149fdaed37fc203643bb6e3994">ug::FACEOPT_AUTOGENERATE_EDGES</a>, <a class="el" href="classug_1_1_grid.html#a631569f60d18f00177e8cf24e5b3e3ff">ug::Grid::get_edge()</a>, <a class="el" href="group__ugbase__common.html#ga158a8c64f24645c7478298399825737f">LOG</a>, and <a class="el" href="classug_1_1_grid.html#a1a52ff3974dd27f9cce544226c43586c">ug::Grid::option_is_enabled()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__lib__grid__algorithms__subset__util.html#ga5057ed4b0f1291b50f67dc721451d7ca">ug::AssignRegionToSubset()</a>, <a class="el" href="namespaceug.html#a670fd9a1468187d3d1f34b1c711d0ac9">ug::CalculateSmoothManifoldPosInParentLevelButterflyScheme()</a>, and <a class="el" href="namespaceug.html#ad8fcb675b0b87b9fa3379d8d71d1cf94">ug::FixFaceOrientation()</a>.</p>

</div>
</div>
<a id="ga9b62fea37b09cfc002c1930766d5fdd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b62fea37b09cfc002c1930766d5fdd6">&#9670;&nbsp;</a></span>GetVertex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classug_1_1_vertex.html">Vertex</a> * ug::GetVertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_face.html">Face</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the i'th vertex of a face </p>
<p>This function simply returns the i'th vertex of a face </p>

<p class="reference">References <a class="el" href="namespaceboost.html#a9a0147028d720cc8409c818ede288560">boost::num_vertices()</a>, <a class="el" href="group__ugbase__common.html#ga0b928ef153b78f1b5e025638cf28f841">UG_ASSERT</a>, and <a class="el" href="classug_1_1_face_vertices.html#a8f18cc58d9b6142a2d3728cfe55159d1">ug::FaceVertices::vertex()</a>.</p>

</div>
</div>
<a id="gad75663712608cfcd1d1e432a0198593a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad75663712608cfcd1d1e432a0198593a">&#9670;&nbsp;</a></span>InsertCenterVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> void ug::InsertCenterVertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid.html">Grid</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_face.html">Face</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>vrt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>eraseOldFace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Refines the face by connecting its sides with the new center. </p>
<p>Make sure that the specified vertex is belongs to the specified grid, and that its position lies inside the specified face (self-intersections would occur if it would lie outside). The original face may optionally be deleted. </p>

<p class="reference">References <a class="el" href="classug_1_1_grid.html#adfae2fb22706392c881d20f696e97ba9">ug::Grid::create()</a>, <a class="el" href="classug_1_1_face.html#a58d3b73e59ed266bdb6558c759ec0d51">ug::Face::edge_desc()</a>, <a class="el" href="classug_1_1_grid.html#a94e7d19731e2d384bd0dc1b70a173cfc">ug::Grid::erase()</a>, <a class="el" href="classug_1_1_face.html#ab2a35640fa0837cabc630c7287cd4340">ug::Face::num_edges()</a>, and <a class="el" href="classug_1_1_edge_vertices.html#a0f2ec2644877a1354489544f43c71206">ug::EdgeVertices::vertex()</a>.</p>

</div>
</div>
<a id="ga13333d7cf4577f562d1a92d1b3fc4c5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga13333d7cf4577f562d1a92d1b3fc4c5e">&#9670;&nbsp;</a></span>IsBoundaryFace3D()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TFace &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> bool ug::IsBoundaryFace3D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid.html">Grid</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TFace *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A wrapper for IsVolumeBoundaryFace. </p>

<p class="reference">References <a class="el" href="group__lib__grid__algorithms__face__util.html#gafd8032868d5b1b81c1d0171156ce7acd">ug::IsVolumeBoundaryFace()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__lib__grid__algorithms__vertex__util.html#ga4c2796a9f87efa8c0cb25f5d8f8e3458">ug::CalculateBoundaryVertexNormal3D()</a>, <a class="el" href="group__lib__grid__algorithms__edge__util.html#gaca999ef2fe108897bf5f89f81493ca48">ug::IsBoundaryEdge3D()</a>, and <a class="el" href="group__lib__grid__algorithms__face__util.html#ga546524dbafff353c160a8e52acb90260">ug::LiesOnBoundary()</a>.</p>

</div>
</div>
<a id="ga07103928668c01fbc9a92a670a9ba9e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07103928668c01fbc9a92a670a9ba9e4">&#9670;&nbsp;</a></span>IsDegenerated()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TAAPosVRT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> bool ug::IsDegenerated </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_face.html">Face</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TAAPosVRT &amp;&#160;</td>
          <td class="paramname"><em>aaPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a>&#160;</td>
          <td class="paramname"><em>threshold</em> = <code><a class="el" href="namespaceug.html#a33c1491a216aec0f5a603a9a3dd6f758">SMALL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns true if the given face is degenerated. </p>
<p>Faces are degenerated if at least one edge is shorter than the given threshold. </p>

<p class="reference">References <a class="el" href="classug_1_1_face_vertices.html#a91c22d6b5fcc4c90e359685aafe2aa19">ug::FaceVertices::num_vertices()</a>, <a class="el" href="group__vectors.html#ga7da70ab2d2c942a82b582f1cc7888069">ug::VecDistanceSq()</a>, and <a class="el" href="classug_1_1_face_vertices.html#a8f18cc58d9b6142a2d3728cfe55159d1">ug::FaceVertices::vertex()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__lib__grid__algorithms__selection__util.html#gab092504c1ee2d0d4df3318ff2c2ed5b5">ug::SelectLinkedFlatAndDegeneratedFaces()</a>.</p>

</div>
</div>
<a id="ga6612d9dd1c1ccd191d67a1a1e6718156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6612d9dd1c1ccd191d67a1a1e6718156">&#9670;&nbsp;</a></span>IsVolumeBoundaryFace() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> bool ug::IsVolumeBoundaryFace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid.html">Grid</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_constrained_face.html">ConstrainedFace</a> *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns true if the given face is a boundary face. </p>
<p>Overload for <a class="el" href="classug_1_1_constrained_face.html" title="This class stores the constraining object.">ConstrainedFace</a>. A face is regarded as a boundary face if it is adjacent to exactly one volume. </p>

<p class="reference">References <a class="el" href="group__lib__grid__algorithms__neighborhood__util.html#ga03bd7e264a1a23ea14e7774a146d59ec">ug::CollectVolumes()</a>.</p>

</div>
</div>
<a id="ga4e9dfa154c5ab46e2f77c4a48a8ee98c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e9dfa154c5ab46e2f77c4a48a8ee98c">&#9670;&nbsp;</a></span>IsVolumeBoundaryFace() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> bool ug::IsVolumeBoundaryFace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid.html">Grid</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_constraining_face.html">ConstrainingFace</a> *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns true if the given face is a boundary face. </p>
<p>Overload for <a class="el" href="classug_1_1_constrained_face.html" title="This class stores the constraining object.">ConstrainedFace</a>. A face is regarded as a boundary face if it is adjacent to exactly one volume. </p>

<p class="reference">References <a class="el" href="group__lib__grid__algorithms__neighborhood__util.html#ga03bd7e264a1a23ea14e7774a146d59ec">ug::CollectVolumes()</a>.</p>

</div>
</div>
<a id="gafd8032868d5b1b81c1d0171156ce7acd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd8032868d5b1b81c1d0171156ce7acd">&#9670;&nbsp;</a></span>IsVolumeBoundaryFace() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> bool ug::IsVolumeBoundaryFace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid.html">Grid</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_face.html">Face</a> *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns true if the given face is a boundary face. </p>
<p>A face is regarded as a boundary face if it is adjacent to exactly one volume.</p>
<p>Please note that overloads of this function for Constrained- and ConstrainingFaces exist. </p>

<p class="reference">References <a class="el" href="group__lib__grid__algorithms__face__util.html#ga2e099f969485473fadd5113b40fe508a">ug::NumAssociatedVolumes()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__lib__grid__algorithms__subset__util.html#ga74d472fdbe503c6753783dec6195adce">ug::AssignInnerAndBoundarySubsets()</a>, <a class="el" href="group__lib__grid__algorithms__face__util.html#ga13333d7cf4577f562d1a92d1b3fc4c5e">ug::IsBoundaryFace3D()</a>, and <a class="el" href="group__lib__grid__algorithms__vertex__util.html#ga7e2bc9e8f5f8133db8ac2939f6ba178b">ug::IsBoundaryVertex3D()</a>.</p>

</div>
</div>
<a id="ga546524dbafff353c160a8e52acb90260"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga546524dbafff353c160a8e52acb90260">&#9670;&nbsp;</a></span>LiesOnBoundary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TFace &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> bool ug::LiesOnBoundary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid.html">Grid</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TFace *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A wrapper for IsVolumeBoundaryFace. </p>

<p class="reference">References <a class="el" href="group__lib__grid__algorithms__face__util.html#ga13333d7cf4577f562d1a92d1b3fc4c5e">ug::IsBoundaryFace3D()</a>.</p>

</div>
</div>
<a id="ga2e099f969485473fadd5113b40fe508a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e099f969485473fadd5113b40fe508a">&#9670;&nbsp;</a></span>NumAssociatedVolumes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ug::NumAssociatedVolumes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid.html">Grid</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_face.html">Face</a> *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the number of associated volumes of the specified face </p>

<p class="reference">References <a class="el" href="classug_1_1_grid.html#a9b6fe1a67b9fa0d1dcb5b18d8cc23dd9">ug::Grid::associated_volumes_begin()</a>, <a class="el" href="classug_1_1_grid.html#ae4fba41614633b0b6e56e2bed4cf4e26">ug::Grid::associated_volumes_end()</a>, <a class="el" href="group__lib__grid.html#ggad5f5a639937a67f1018d12996992f6f3a3d8b76c15b6f0e744e727f23e0150932">ug::FACEOPT_STORE_ASSOCIATED_VOLUMES</a>, <a class="el" href="classug_1_1_grid.html#a1a52ff3974dd27f9cce544226c43586c">ug::Grid::option_is_enabled()</a>, <a class="el" href="classug_1_1_face_vertices.html#a8f18cc58d9b6142a2d3728cfe55159d1">ug::FaceVertices::vertex()</a>, and <a class="el" href="group__lib__grid__algorithms__volume__util.html#gab28fc56b79458ac223c95f3585c67117">ug::VolumeContains()</a>.</p>

<p class="reference">Referenced by <a class="el" href="namespaceug.html#ad8fcb675b0b87b9fa3379d8d71d1cf94">ug::FixFaceOrientation()</a>, and <a class="el" href="group__lib__grid__algorithms__face__util.html#gafd8032868d5b1b81c1d0171156ce7acd">ug::IsVolumeBoundaryFace()</a>.</p>

</div>
</div>
<a id="ga9ed3a8995006d786f63e318b7f6c358f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ed3a8995006d786f63e318b7f6c358f">&#9670;&nbsp;</a></span>PointFaceTest()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TAAPosVRT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> int ug::PointFaceTest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__vectors.html#ga894cdb8af74f7a563a94fb49c220fdcd">vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_face.html">Face</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TAAPosVRT &amp;&#160;</td>
          <td class="paramname"><em>aaPos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>returns 1 if a point lies in front of a face, 0 if it lies on the face and -1 if it lies behind the face. TAAPosVRT has to be an <a class="el" href="classug_1_1_attachment_accessor.html" title="Used to access data that has been attached to an attachment pipe.">AttachmentAccessor</a> compatible type that operates on vector3. </p>

<p class="reference">References <a class="el" href="group__lib__grid__algorithms__edge__util.html#ga47d8d9dc1634d72a7500de9fe2e1f7a3">ug::CalculateNormal()</a>, <a class="el" href="group__vectors.html#gae9174d47662deb0ba119e0e21f28ec71">ug::VecDot()</a>, <a class="el" href="group__vectors.html#ga5c7eda5aeb4cd0d53ce04f682d0a0058">ug::VecSubtract()</a>, and <a class="el" href="classug_1_1_face_vertices.html#a8f18cc58d9b6142a2d3728cfe55159d1">ug::FaceVertices::vertex()</a>.</p>

<p class="reference">Referenced by <a class="el" href="namespaceug.html#a91df3660fc32c1e8c4f84adcdd174dca">ug::CreatePrism()</a>, <a class="el" href="namespaceug.html#a6fadfe41f01df20621e438757c1f568d">ug::CreatePyramid()</a>, and <a class="el" href="namespaceug.html#a91ce6e59f1c21da299576be963e9f371">ug::CreateTetrahedron()</a>.</p>

</div>
</div>
<a id="gabe4b069038c2eb0c0284efde3a3bd64b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe4b069038c2eb0c0284efde3a3bd64b">&#9670;&nbsp;</a></span>ProjectPointToSurface()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TTriangleIterator , class TAAPosVRT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> bool ug::ProjectPointToSurface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__vectors.html#ga894cdb8af74f7a563a94fb49c220fdcd">vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>vOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__vectors.html#ga894cdb8af74f7a563a94fb49c220fdcd">vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__vectors.html#ga894cdb8af74f7a563a94fb49c220fdcd">vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TTriangleIterator&#160;</td>
          <td class="paramname"><em>trisBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TTriangleIterator&#160;</td>
          <td class="paramname"><em>trisEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TAAPosVRT &amp;&#160;</td>
          <td class="paramname"><em>aaPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compareNormals</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="group__vectors.html#ga5be9ee257bccce9d31593bbb39f337e8">ug::CalculateTriangleNormalNoNormalize()</a>, <a class="el" href="group__ugbase__mathutil.html#gafb36695faca9865a363c59b91fede0dc">ug::DistancePointToTriangle()</a>, <a class="el" href="group__vectors.html#gae9174d47662deb0ba119e0e21f28ec71">ug::VecDot()</a>, and <a class="el" href="classug_1_1_custom_triangle.html#ac5059768b9528b54980af2aaa8685211">ug::CustomTriangle&lt; ConcreteTriangleType, BaseClass, RefTriType, RefQuadType &gt;::vertex()</a>.</p>

</div>
</div>
<a id="gae772e4fd343550a940e172b770faaf1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae772e4fd343550a940e172b770faaf1b">&#9670;&nbsp;</a></span>TriangleQuality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> <a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a> ug::TriangleQuality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__vectors.html#ga894cdb8af74f7a563a94fb49c220fdcd">vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__vectors.html#ga894cdb8af74f7a563a94fb49c220fdcd">vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__vectors.html#ga894cdb8af74f7a563a94fb49c220fdcd">vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>v3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a simple measure for the quality of a triangle </p>
<p>returns a value between 0 and 1, where 1 indicates a good quality and 0 a bad. This method checks the dot-products of edges at the corners. The worst one (closest to 1 or -1) determines the quality. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__lib__grid__algorithms__face__util.html#ga69c2b459338a1d7007d19daabba2df32" title="a simple measure for the quality of a face">FaceQuality</a> </dd></dl>

<p class="reference">References <a class="el" href="group__vectors.html#gae9174d47662deb0ba119e0e21f28ec71">ug::VecDot()</a>, <a class="el" href="group__vectors.html#ga53ae2dda87330ab64fb2a5901606b3e4">ug::VecNormalize()</a>, <a class="el" href="group__vectors.html#gaa0cd3e6bb61c8e341541f8cf3065ec6d">ug::VecScale()</a>, and <a class="el" href="group__vectors.html#ga5c7eda5aeb4cd0d53ce04f682d0a0058">ug::VecSubtract()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__lib__grid__algorithms__face__util.html#gac5dd5ed95ed5f64fd5d29133769324be">ug::Triangulate()</a>.</p>

</div>
</div>
<a id="ga5e830eb2ca680c580b9309aa4f9c445e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e830eb2ca680c580b9309aa4f9c445e">&#9670;&nbsp;</a></span>Triangulate() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ug::Triangulate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid.html">Grid</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid_1_1_vertex_attachment_accessor.html">Grid::VertexAttachmentAccessor</a>&lt; <a class="el" href="namespaceug.html#a780dd3524b97269f891365fd3c3b895a">APosition</a> &gt; *&#160;</td>
          <td class="paramname"><em>paaPos</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="classug_1_1_grid.html#ac61deaa5a86f28e8e78fa481467f5d45">ug::Grid::begin()</a>, <a class="el" href="classug_1_1_grid.html#aecec2b9e3e45241347497a58de7aa13a">ug::Grid::end()</a>, and <a class="el" href="group__lib__grid__algorithms__face__util.html#gac5dd5ed95ed5f64fd5d29133769324be">ug::Triangulate()</a>.</p>

</div>
</div>
<a id="gac5dd5ed95ed5f64fd5d29133769324be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5dd5ed95ed5f64fd5d29133769324be">&#9670;&nbsp;</a></span>Triangulate() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> void ug::Triangulate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid.html">Grid</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_quadrilateral.html">Quadrilateral</a> *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid_1_1_vertex_attachment_accessor.html">Grid::VertexAttachmentAccessor</a>&lt; <a class="el" href="namespaceug.html#a780dd3524b97269f891365fd3c3b895a">APosition</a> &gt; *&#160;</td>
          <td class="paramname"><em>paaPos</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>removes the quadrilateral and replaces it by two triangles. </p>
<p>if paaPos is set to NULL, the quadrilateral will be splitted along the edge between the first and the third vertex. If paaPos points to a position-attachment-accessor, then the new edge will be chosen so that the worst triangle-quality is better. </p>

<p class="reference">References <a class="el" href="group__lib__grid__algorithms__vertex__util.html#ga8c98c2d1d058d59c32717dd75d97055c">ug::CalculateVertexNormal()</a>, <a class="el" href="classug_1_1_grid.html#adfae2fb22706392c881d20f696e97ba9">ug::Grid::create()</a>, <a class="el" href="classug_1_1_grid.html#a94e7d19731e2d384bd0dc1b70a173cfc">ug::Grid::erase()</a>, <a class="el" href="namespaceug.html#a33c1491a216aec0f5a603a9a3dd6f758">ug::SMALL</a>, <a class="el" href="group__lib__grid__algorithms__face__util.html#gae772e4fd343550a940e172b770faaf1b">ug::TriangleQuality()</a>, <a class="el" href="group__vectors.html#gae9174d47662deb0ba119e0e21f28ec71">ug::VecDot()</a>, and <a class="el" href="classug_1_1_custom_quadrilateral.html#a2325071c2f34dfa7889ca019b56cf809">ug::CustomQuadrilateral&lt; ConcreteQuadrilateralType, BaseClass, RefTriType, RefQuadType &gt;::vertex()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__lib__grid__algorithms__remeshing.html#gaa6cdff940793032a9dac5582b475ee86">ug::AdaptSurfaceGridToCylinder()</a>, <a class="el" href="group__lib__grid__algorithms__remeshing.html#gab217fe44fb42f01be0dab1a46c2908ae">ug::AdjustEdgeLength()</a>, <a class="el" href="namespaceug.html#a12aa226211e88392b205b90b11a914d7">ug::ExtrudeLayersMixed()</a>, <a class="el" href="namespaceug.html#af32c1177e1b1acd0784c8a9fd42153d9">ug::MultiEdgeSplit()</a>, <a class="el" href="namespaceug.html#a500c334f1f91ba7c83e38cc61cbbfd10">ug::PerformTetrahedralization()</a>, and <a class="el" href="group__lib__grid__algorithms__face__util.html#ga5e830eb2ca680c580b9309aa4f9c445e">ug::Triangulate()</a>.</p>

</div>
</div>
<a id="ga2b4fdf52742a3186bfd3473b2f028926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b4fdf52742a3186bfd3473b2f028926">&#9670;&nbsp;</a></span>Triangulate() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#ga6a442be2e75e98247f82d1aa90a06aac">UG_API</a> void ug::Triangulate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid.html">Grid</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceug.html#a15ffcc65340980c745bdf5de374b100a">QuadrilateralIterator</a>&#160;</td>
          <td class="paramname"><em>iterBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceug.html#a15ffcc65340980c745bdf5de374b100a">QuadrilateralIterator</a>&#160;</td>
          <td class="paramname"><em>iterEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classug_1_1_grid_1_1_vertex_attachment_accessor.html">Grid::VertexAttachmentAccessor</a>&lt; <a class="el" href="namespaceug.html#a780dd3524b97269f891365fd3c3b895a">APosition</a> &gt; *&#160;</td>
          <td class="paramname"><em>paaPos</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>replaces all specified quadrilaterals by triangles. </p>
<p>if paaPos is set to NULL, the quadrilaterals will be splitted along the edge between their first and their third vertex. If paaPos points to a position-attachment-accessor, then the new edge will be chosen so that the worst triangle-quality is better. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Dec 4 2023 00:57:31 for ug4 by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
