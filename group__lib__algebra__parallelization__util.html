<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ug4: Parallel Algebra Util</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ug4
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__lib__algebra__parallelization__util.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Parallel Algebra Util<div class="ingroups"><a class="el" href="group__lib__algebra.html">lib_algebra</a> &raquo; <a class="el" href="group__lib__algebra__parallelization.html">Parallel Algebra</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Util Functions for parallel Algebra.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="memitem:ga16d29da500a93fd47184d23442fcd5ed"><td class="memTemplParams" colspan="2">template&lt;class TLayout &gt; </td></tr>
<tr class="memitem:ga16d29da500a93fd47184d23442fcd5ed"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__algebra__parallelization__util.html#ga16d29da500a93fd47184d23442fcd5ed">ug::GenerateGlobalAlgebraIDs</a> (<a class="el" href="classpcl_1_1_interface_communicator.html">pcl::InterfaceCommunicator</a>&lt; TLayout &gt; &amp;communicator, std::vector&lt; <a class="el" href="structug_1_1_algebra_i_d.html">AlgebraID</a> &gt; &amp;idsOut, size_t numIDs, const TLayout &amp;masterLayout, const TLayout &amp;slaveLayout)</td></tr>
<tr class="memdesc:ga16d29da500a93fd47184d23442fcd5ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a set of unique global algebra ids.  <a href="group__lib__algebra__parallelization__util.html#ga16d29da500a93fd47184d23442fcd5ed">More...</a><br /></td></tr>
<tr class="separator:ga16d29da500a93fd47184d23442fcd5ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3da2c2603824b8c974b22d8b2f67275b"><td class="memTemplParams" colspan="2">template&lt;typename TMatrix &gt; </td></tr>
<tr class="memitem:ga3da2c2603824b8c974b22d8b2f67275b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__algebra__parallelization__util.html#ga3da2c2603824b8c974b22d8b2f67275b">ug::MatAddSlaveRowsToMasterRowOverlap0</a> (TMatrix &amp;mat)</td></tr>
<tr class="memdesc:ga3da2c2603824b8c974b22d8b2f67275b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a set of unique global algebra ids.  <a href="group__lib__algebra__parallelization__util.html#ga3da2c2603824b8c974b22d8b2f67275b">More...</a><br /></td></tr>
<tr class="separator:ga3da2c2603824b8c974b22d8b2f67275b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62ff21e4f3ecc0f4803e61725edd7fed"><td class="memTemplParams" colspan="2">template&lt;typename TMatrix &gt; </td></tr>
<tr class="memitem:ga62ff21e4f3ecc0f4803e61725edd7fed"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__algebra__parallelization__util.html#ga62ff21e4f3ecc0f4803e61725edd7fed">ug::MatMakeConsistentOverlap0</a> (TMatrix &amp;mat)</td></tr>
<tr class="memdesc:ga62ff21e4f3ecc0f4803e61725edd7fed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a set of unique global algebra ids.  <a href="group__lib__algebra__parallelization__util.html#ga62ff21e4f3ecc0f4803e61725edd7fed">More...</a><br /></td></tr>
<tr class="separator:ga62ff21e4f3ecc0f4803e61725edd7fed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecc2ecad8e08839d585ef1846667e44f"><td class="memTemplParams" colspan="2">template&lt;typename TVector &gt; </td></tr>
<tr class="memitem:gaecc2ecad8e08839d585ef1846667e44f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__algebra__parallelization__util.html#gaecc2ecad8e08839d585ef1846667e44f">ug::AdditiveToConsistent</a> (TVector *pVec, const <a class="el" href="group__lib__algebra__parallelization.html#gad2e106a1a11b3d94250becdabf196f65">IndexLayout</a> &amp;masterLayout, const <a class="el" href="group__lib__algebra__parallelization.html#gad2e106a1a11b3d94250becdabf196f65">IndexLayout</a> &amp;slaveLayout, <a class="el" href="classpcl_1_1_interface_communicator.html">pcl::InterfaceCommunicator</a>&lt; <a class="el" href="group__lib__algebra__parallelization.html#gad2e106a1a11b3d94250becdabf196f65">IndexLayout</a> &gt; *pCom=NULL)</td></tr>
<tr class="memdesc:gaecc2ecad8e08839d585ef1846667e44f"><td class="mdescLeft">&#160;</td><td class="mdescRight">changes parallel storage type from additive to consistent  <a href="group__lib__algebra__parallelization__util.html#gaecc2ecad8e08839d585ef1846667e44f">More...</a><br /></td></tr>
<tr class="separator:gaecc2ecad8e08839d585ef1846667e44f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41105b645bc5319e94c405fd4670b848"><td class="memTemplParams" colspan="2">template&lt;typename TVector &gt; </td></tr>
<tr class="memitem:ga41105b645bc5319e94c405fd4670b848"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__algebra__parallelization__util.html#ga41105b645bc5319e94c405fd4670b848">ug::UniqueToConsistent</a> (TVector *pVec, const <a class="el" href="group__lib__algebra__parallelization.html#gad2e106a1a11b3d94250becdabf196f65">IndexLayout</a> &amp;masterLayout, const <a class="el" href="group__lib__algebra__parallelization.html#gad2e106a1a11b3d94250becdabf196f65">IndexLayout</a> &amp;slaveLayout, <a class="el" href="classpcl_1_1_interface_communicator.html">pcl::InterfaceCommunicator</a>&lt; <a class="el" href="group__lib__algebra__parallelization.html#gad2e106a1a11b3d94250becdabf196f65">IndexLayout</a> &gt; *pCom=NULL)</td></tr>
<tr class="memdesc:ga41105b645bc5319e94c405fd4670b848"><td class="mdescLeft">&#160;</td><td class="mdescRight">changes parallel storage type from unique to consistent  <a href="group__lib__algebra__parallelization__util.html#ga41105b645bc5319e94c405fd4670b848">More...</a><br /></td></tr>
<tr class="separator:ga41105b645bc5319e94c405fd4670b848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae7502365fc2b2a3a1867c8e06324cd8"><td class="memTemplParams" colspan="2">template&lt;typename TVector &gt; </td></tr>
<tr class="memitem:gaae7502365fc2b2a3a1867c8e06324cd8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__algebra__parallelization__util.html#gaae7502365fc2b2a3a1867c8e06324cd8">ug::CopyValues</a> (TVector *pVec, const <a class="el" href="group__lib__algebra__parallelization.html#gad2e106a1a11b3d94250becdabf196f65">IndexLayout</a> &amp;sourceLayout, const <a class="el" href="group__lib__algebra__parallelization.html#gad2e106a1a11b3d94250becdabf196f65">IndexLayout</a> &amp;targetLayout, <a class="el" href="classpcl_1_1_interface_communicator.html">pcl::InterfaceCommunicator</a>&lt; <a class="el" href="group__lib__algebra__parallelization.html#gad2e106a1a11b3d94250becdabf196f65">IndexLayout</a> &gt; *pCom=NULL)</td></tr>
<tr class="memdesc:gaae7502365fc2b2a3a1867c8e06324cd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies values from the source to the target layout.  <a href="group__lib__algebra__parallelization__util.html#gaae7502365fc2b2a3a1867c8e06324cd8">More...</a><br /></td></tr>
<tr class="separator:gaae7502365fc2b2a3a1867c8e06324cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cce17d66c105ef07b39137bcb130efa"><td class="memTemplParams" colspan="2">template&lt;typename TVector &gt; </td></tr>
<tr class="memitem:ga7cce17d66c105ef07b39137bcb130efa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__algebra__parallelization__util.html#ga7cce17d66c105ef07b39137bcb130efa">ug::AdditiveToUnique</a> (TVector *pVec, const <a class="el" href="group__lib__algebra__parallelization.html#gad2e106a1a11b3d94250becdabf196f65">IndexLayout</a> &amp;masterLayout, const <a class="el" href="group__lib__algebra__parallelization.html#gad2e106a1a11b3d94250becdabf196f65">IndexLayout</a> &amp;slaveLayout, <a class="el" href="classpcl_1_1_interface_communicator.html">pcl::InterfaceCommunicator</a>&lt; <a class="el" href="group__lib__algebra__parallelization.html#gad2e106a1a11b3d94250becdabf196f65">IndexLayout</a> &gt; *pCom=NULL)</td></tr>
<tr class="memdesc:ga7cce17d66c105ef07b39137bcb130efa"><td class="mdescLeft">&#160;</td><td class="mdescRight">changes parallel storage type from additive to unique  <a href="group__lib__algebra__parallelization__util.html#ga7cce17d66c105ef07b39137bcb130efa">More...</a><br /></td></tr>
<tr class="separator:ga7cce17d66c105ef07b39137bcb130efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9801a124862216fb6db2999188ac4c32"><td class="memTemplParams" colspan="2">template&lt;typename TVector &gt; </td></tr>
<tr class="memitem:ga9801a124862216fb6db2999188ac4c32"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__algebra__parallelization__util.html#ga9801a124862216fb6db2999188ac4c32">ug::SetInterfaceValues</a> (TVector *pVec, const <a class="el" href="classpcl_1_1_single_level_layout.html#ad72a8f489a129a6f85eab9f4a7b01020">IndexLayout::Interface</a> &amp;interface, typename <a class="el" href="sparsematrix__interface_8h.html#a265a253612b46abed17c61b0a5e5ce30">TVector::value_type</a> val)</td></tr>
<tr class="memdesc:ga9801a124862216fb6db2999188ac4c32"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the values of a vector to a given number only on the interface indices  <a href="group__lib__algebra__parallelization__util.html#ga9801a124862216fb6db2999188ac4c32">More...</a><br /></td></tr>
<tr class="separator:ga9801a124862216fb6db2999188ac4c32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33b4797e3d3382885a96223a2c44d72f"><td class="memTemplParams" colspan="2">template&lt;typename TVector &gt; </td></tr>
<tr class="memitem:ga33b4797e3d3382885a96223a2c44d72f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__algebra__parallelization__util.html#ga33b4797e3d3382885a96223a2c44d72f">ug::SetLayoutValues</a> (TVector *pVec, const <a class="el" href="group__lib__algebra__parallelization.html#gad2e106a1a11b3d94250becdabf196f65">IndexLayout</a> &amp;layout, typename <a class="el" href="sparsematrix__interface_8h.html#a265a253612b46abed17c61b0a5e5ce30">TVector::value_type</a> val)</td></tr>
<tr class="memdesc:ga33b4797e3d3382885a96223a2c44d72f"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the values of a vector to a given number only on the layout indices  <a href="group__lib__algebra__parallelization__util.html#ga33b4797e3d3382885a96223a2c44d72f">More...</a><br /></td></tr>
<tr class="separator:ga33b4797e3d3382885a96223a2c44d72f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga008815d4f97936dac5cae4be5e019c0c"><td class="memTemplParams" colspan="2">template&lt;typename TVector &gt; </td></tr>
<tr class="memitem:ga008815d4f97936dac5cae4be5e019c0c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__algebra__parallelization__util.html#ga008815d4f97936dac5cae4be5e019c0c">ug::ScaleLayoutValues</a> (TVector *pVec, const <a class="el" href="group__lib__algebra__parallelization.html#gad2e106a1a11b3d94250becdabf196f65">IndexLayout</a> &amp;layout, <a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a> scale)</td></tr>
<tr class="memdesc:ga008815d4f97936dac5cae4be5e019c0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">scales the values of a vector by a given number only on the layout indices  <a href="group__lib__algebra__parallelization__util.html#ga008815d4f97936dac5cae4be5e019c0c">More...</a><br /></td></tr>
<tr class="separator:ga008815d4f97936dac5cae4be5e019c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d12aface4416d0f6cc43997ad21001f"><td class="memTemplParams" colspan="2">template&lt;typename TVector &gt; </td></tr>
<tr class="memitem:ga0d12aface4416d0f6cc43997ad21001f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__algebra__parallelization__util.html#ga0d12aface4416d0f6cc43997ad21001f">ug::ConsistentToUnique</a> (TVector *pVec, const <a class="el" href="group__lib__algebra__parallelization.html#gad2e106a1a11b3d94250becdabf196f65">IndexLayout</a> &amp;slaveLayout)</td></tr>
<tr class="memdesc:ga0d12aface4416d0f6cc43997ad21001f"><td class="mdescLeft">&#160;</td><td class="mdescRight">changes parallel storage type from consistent to unique  <a href="group__lib__algebra__parallelization__util.html#ga0d12aface4416d0f6cc43997ad21001f">More...</a><br /></td></tr>
<tr class="separator:ga0d12aface4416d0f6cc43997ad21001f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ec969fdb51f7876a953e584f640650d"><td class="memTemplParams" colspan="2">template&lt;typename TVector &gt; </td></tr>
<tr class="memitem:ga7ec969fdb51f7876a953e584f640650d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__algebra__parallelization__util.html#ga7ec969fdb51f7876a953e584f640650d">ug::VecSubtractOnLayout</a> (TVector *pVec, const <a class="el" href="group__lib__algebra__parallelization.html#gad2e106a1a11b3d94250becdabf196f65">IndexLayout</a> &amp;masterLayout, const <a class="el" href="group__lib__algebra__parallelization.html#gad2e106a1a11b3d94250becdabf196f65">IndexLayout</a> &amp;slaveLayout, <a class="el" href="classpcl_1_1_interface_communicator.html">pcl::InterfaceCommunicator</a>&lt; <a class="el" href="group__lib__algebra__parallelization.html#gad2e106a1a11b3d94250becdabf196f65">IndexLayout</a> &gt; *pCom=NULL)</td></tr>
<tr class="memdesc:ga7ec969fdb51f7876a953e584f640650d"><td class="mdescLeft">&#160;</td><td class="mdescRight">subtracts values of slave layout from master layout and sets slave layouts to negative of difference  <a href="group__lib__algebra__parallelization__util.html#ga7ec969fdb51f7876a953e584f640650d">More...</a><br /></td></tr>
<tr class="separator:ga7ec969fdb51f7876a953e584f640650d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8263314ed9f4dc23d502a82e85038c78"><td class="memTemplParams" colspan="2">template&lt;typename TVector &gt; </td></tr>
<tr class="memitem:ga8263314ed9f4dc23d502a82e85038c78"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__algebra__parallelization__util.html#ga8263314ed9f4dc23d502a82e85038c78">ug::VecSubtractOneSlaveFromMaster</a> (TVector *pVec, const <a class="el" href="group__lib__algebra__parallelization.html#gad2e106a1a11b3d94250becdabf196f65">IndexLayout</a> &amp;masterLayout, const <a class="el" href="group__lib__algebra__parallelization.html#gad2e106a1a11b3d94250becdabf196f65">IndexLayout</a> &amp;slaveLayout, <a class="el" href="classpcl_1_1_interface_communicator.html">pcl::InterfaceCommunicator</a>&lt; <a class="el" href="group__lib__algebra__parallelization.html#gad2e106a1a11b3d94250becdabf196f65">IndexLayout</a> &gt; *pCom=NULL)</td></tr>
<tr class="memdesc:ga8263314ed9f4dc23d502a82e85038c78"><td class="mdescLeft">&#160;</td><td class="mdescRight">subtracts values of only one slave dof per master on layout  <a href="group__lib__algebra__parallelization__util.html#ga8263314ed9f4dc23d502a82e85038c78">More...</a><br /></td></tr>
<tr class="separator:ga8263314ed9f4dc23d502a82e85038c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b8fc9258a77acf678a224ad4366e65e"><td class="memTemplParams" colspan="2">template&lt;typename TVector &gt; </td></tr>
<tr class="memitem:ga0b8fc9258a77acf678a224ad4366e65e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__algebra__parallelization__util.html#ga0b8fc9258a77acf678a224ad4366e65e">ug::VecCopy</a> (TVector *pVec, const <a class="el" href="group__lib__algebra__parallelization.html#gad2e106a1a11b3d94250becdabf196f65">IndexLayout</a> &amp;masterLayout, const <a class="el" href="group__lib__algebra__parallelization.html#gad2e106a1a11b3d94250becdabf196f65">IndexLayout</a> &amp;slaveLayout, <a class="el" href="classpcl_1_1_interface_communicator.html">pcl::InterfaceCommunicator</a>&lt; <a class="el" href="group__lib__algebra__parallelization.html#gad2e106a1a11b3d94250becdabf196f65">IndexLayout</a> &gt; *pCom=NULL)</td></tr>
<tr class="memdesc:ga0b8fc9258a77acf678a224ad4366e65e"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy a vector only at a layout  <a href="group__lib__algebra__parallelization__util.html#ga0b8fc9258a77acf678a224ad4366e65e">More...</a><br /></td></tr>
<tr class="separator:ga0b8fc9258a77acf678a224ad4366e65e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7aff107c35514a47f19ce2ddb8586f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__algebra__parallelization__util.html#gad7aff107c35514a47f19ce2ddb8586f1">ug::CommunicateConnections</a> (std::vector&lt; std::vector&lt; int &gt; &gt; &amp;connectionsToProcsOut, std::vector&lt; std::vector&lt; int &gt; &gt; &amp;connectionsToSubDomsOut, <a class="el" href="group__lib__algebra__parallelization.html#gad2e106a1a11b3d94250becdabf196f65">IndexLayout</a> &amp;masterLayout, <a class="el" href="group__lib__algebra__parallelization.html#gad2e106a1a11b3d94250becdabf196f65">IndexLayout</a> &amp;slaveLayout, int highestReferencedIndex, <a class="el" href="classpcl_1_1_i_domain_decomposition_info.html">pcl::IDomainDecompositionInfo</a> &amp;ddinfo)</td></tr>
<tr class="memdesc:gad7aff107c35514a47f19ce2ddb8586f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">fills a connection list, which gives the connected processes to each interface.  <a href="group__lib__algebra__parallelization__util.html#gad7aff107c35514a47f19ce2ddb8586f1">More...</a><br /></td></tr>
<tr class="separator:gad7aff107c35514a47f19ce2ddb8586f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Util Functions for parallel Algebra. </p>
<p>In order to simplify the use of Communication Policies for Algebras some util functions are provided. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaecc2ecad8e08839d585ef1846667e44f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaecc2ecad8e08839d585ef1846667e44f">&#9670;&nbsp;</a></span>AdditiveToConsistent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ug::AdditiveToConsistent </td>
          <td>(</td>
          <td class="paramtype">TVector *&#160;</td>
          <td class="paramname"><em>pVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__lib__algebra__parallelization.html#gad2e106a1a11b3d94250becdabf196f65">IndexLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>masterLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__lib__algebra__parallelization.html#gad2e106a1a11b3d94250becdabf196f65">IndexLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>slaveLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_interface_communicator.html">pcl::InterfaceCommunicator</a>&lt; <a class="el" href="group__lib__algebra__parallelization.html#gad2e106a1a11b3d94250becdabf196f65">IndexLayout</a> &gt; *&#160;</td>
          <td class="paramname"><em>pCom</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>changes parallel storage type from additive to consistent </p>
<p>This function changes the storage type of a parallel vector from additive to consistent. A InterfaceCommunicator is created iff no communicator passed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pVec</td><td>Parallel <a class="el" href="classug_1_1_vector.html">Vector</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">masterLayout</td><td>Master Layout </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slaveLayout</td><td>Slave Layout </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pCom</td><td>Parallel Communicator </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classpcl_1_1_interface_communicator.html#a86d3ffad4801623f1401b0d14ef5c1ae">pcl::InterfaceCommunicator&lt; TLayout &gt;::communicate()</a>, <a class="el" href="profiler_8h.html#a3766fe91615588782ad5452a4d60ea5b">PROFILE_FUNC_GROUP</a>, <a class="el" href="lib__algebra_2parallelization_2parallelization__util_8h.html#a1c2096a172bb7d8efb71df3cb9e8ae54">PU_PROFILE_BEGIN</a>, <a class="el" href="lib__algebra_2parallelization_2parallelization__util_8h.html#a157f2db5501dda27a34c1860b2bdc5fa">PU_PROFILE_END</a>, <a class="el" href="classpcl_1_1_interface_communicator.html#aa7cd1f6556736ad0a9f556546166c1bd">pcl::InterfaceCommunicator&lt; TLayout &gt;::receive_data()</a>, and <a class="el" href="classpcl_1_1_interface_communicator.html#a870c5820b4a0762086775b389f7f6aa0">pcl::InterfaceCommunicator&lt; TLayout &gt;::send_data()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classug_1_1_parallel_vector.html#af0a152fd3984195f4dd9c6cc081a9026">ug::ParallelVector&lt; Vector&lt; double &gt; &gt;::clone_without_values()</a>, <a class="el" href="namespaceug.html#a3f4b32857abee95bd9fd4804f44e9060">ug::MatAdditiveToConsistentOnDiag()</a>, and <a class="el" href="classug_1_1_std_transfer.html#a260f0387f239404feda34377798a104e">ug::StdTransfer&lt; TDomain, TAlgebra &gt;::prolongate()</a>.</p>

</div>
</div>
<a id="ga7cce17d66c105ef07b39137bcb130efa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7cce17d66c105ef07b39137bcb130efa">&#9670;&nbsp;</a></span>AdditiveToUnique()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ug::AdditiveToUnique </td>
          <td>(</td>
          <td class="paramtype">TVector *&#160;</td>
          <td class="paramname"><em>pVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__lib__algebra__parallelization.html#gad2e106a1a11b3d94250becdabf196f65">IndexLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>masterLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__lib__algebra__parallelization.html#gad2e106a1a11b3d94250becdabf196f65">IndexLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>slaveLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_interface_communicator.html">pcl::InterfaceCommunicator</a>&lt; <a class="el" href="group__lib__algebra__parallelization.html#gad2e106a1a11b3d94250becdabf196f65">IndexLayout</a> &gt; *&#160;</td>
          <td class="paramname"><em>pCom</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>changes parallel storage type from additive to unique </p>
<p>This function changes the storage type of a parallel vector from additive to unique. A InterfaceCommunicator is created iff no communicator passed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pVec</td><td>Parallel <a class="el" href="classug_1_1_vector.html">Vector</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">masterLayout</td><td>Master Layout </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slaveLayout</td><td>Slave Layout </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pCom</td><td>Parallel Communicator </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classpcl_1_1_interface_communicator.html#a86d3ffad4801623f1401b0d14ef5c1ae">pcl::InterfaceCommunicator&lt; TLayout &gt;::communicate()</a>, <a class="el" href="profiler_8h.html#a3766fe91615588782ad5452a4d60ea5b">PROFILE_FUNC_GROUP</a>, <a class="el" href="classpcl_1_1_interface_communicator.html#aa7cd1f6556736ad0a9f556546166c1bd">pcl::InterfaceCommunicator&lt; TLayout &gt;::receive_data()</a>, and <a class="el" href="classpcl_1_1_interface_communicator.html#a870c5820b4a0762086775b389f7f6aa0">pcl::InterfaceCommunicator&lt; TLayout &gt;::send_data()</a>.</p>

</div>
</div>
<a id="gad7aff107c35514a47f19ce2ddb8586f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7aff107c35514a47f19ce2ddb8586f1">&#9670;&nbsp;</a></span>CommunicateConnections()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ug::CommunicateConnections </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>connectionsToProcsOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>connectionsToSubDomsOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__lib__algebra__parallelization.html#gad2e106a1a11b3d94250becdabf196f65">IndexLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>masterLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__lib__algebra__parallelization.html#gad2e106a1a11b3d94250becdabf196f65">IndexLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>slaveLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>highestReferencedIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_i_domain_decomposition_info.html">pcl::IDomainDecompositionInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>ddinfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>fills a connection list, which gives the connected processes to each interface. </p>
<p>The i-th entry in connectionsOut is a vector which contains the process-ids of all connected processes of the layout-entry with value i. This includes connections to all slaves of the associated master. The first entry for each connection is the process on which the master-element lies, followed by the processes where associated slaves lie.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">connectionsOut</td><td>will have the size highestReferencedIndex + 1 when the method is done. By indexing connectionsOut with an entry of one of the layouts interfaces, you will obtain a vector of all processes on which copies of that entry reside.</td></tr>
    <tr><td class="paramname">highestReferencedIndex</td><td>has to hold the highest index which is referenced either by entries in the interfaces of masterLayout or by entries in the interfaces of slaveLayout. Note that it can be obtained by a call to std::max(GetHighestReferencedIndex(masterLayout), GetHighestReferencedIndex(slaveLayout)).</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000013">Todo:</a></b></dt><dd>The method should probably automatically find the highestReferencedIndex, to avoid misuse. </dd></dl>

</div>
</div>
<a id="ga0d12aface4416d0f6cc43997ad21001f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d12aface4416d0f6cc43997ad21001f">&#9670;&nbsp;</a></span>ConsistentToUnique()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ug::ConsistentToUnique </td>
          <td>(</td>
          <td class="paramtype">TVector *&#160;</td>
          <td class="paramname"><em>pVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__lib__algebra__parallelization.html#gad2e106a1a11b3d94250becdabf196f65">IndexLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>slaveLayout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>changes parallel storage type from consistent to unique </p>
<p>This function changes the storage type of a parallel vector from consistent to unique. Note, that no communication is needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pVec</td><td>Parallel <a class="el" href="classug_1_1_vector.html">Vector</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slaveLayout</td><td>Slave Layout </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="profiler_8h.html#a3766fe91615588782ad5452a4d60ea5b">PROFILE_FUNC_GROUP</a>, and <a class="el" href="group__lib__algebra__parallelization__util.html#ga33b4797e3d3382885a96223a2c44d72f">ug::SetLayoutValues()</a>.</p>

</div>
</div>
<a id="gaae7502365fc2b2a3a1867c8e06324cd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae7502365fc2b2a3a1867c8e06324cd8">&#9670;&nbsp;</a></span>CopyValues()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ug::CopyValues </td>
          <td>(</td>
          <td class="paramtype">TVector *&#160;</td>
          <td class="paramname"><em>pVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__lib__algebra__parallelization.html#gad2e106a1a11b3d94250becdabf196f65">IndexLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>sourceLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__lib__algebra__parallelization.html#gad2e106a1a11b3d94250becdabf196f65">IndexLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>targetLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_interface_communicator.html">pcl::InterfaceCommunicator</a>&lt; <a class="el" href="group__lib__algebra__parallelization.html#gad2e106a1a11b3d94250becdabf196f65">IndexLayout</a> &gt; *&#160;</td>
          <td class="paramname"><em>pCom</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies values from the source to the target layout. </p>

<p class="reference">References <a class="el" href="classpcl_1_1_interface_communicator.html#a86d3ffad4801623f1401b0d14ef5c1ae">pcl::InterfaceCommunicator&lt; TLayout &gt;::communicate()</a>, <a class="el" href="profiler_8h.html#a3766fe91615588782ad5452a4d60ea5b">PROFILE_FUNC_GROUP</a>, <a class="el" href="classpcl_1_1_interface_communicator.html#aa7cd1f6556736ad0a9f556546166c1bd">pcl::InterfaceCommunicator&lt; TLayout &gt;::receive_data()</a>, and <a class="el" href="classpcl_1_1_interface_communicator.html#a870c5820b4a0762086775b389f7f6aa0">pcl::InterfaceCommunicator&lt; TLayout &gt;::send_data()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classug_1_1_overlap_writer.html#af193370cf978e3faa1828113f85be68f">ug::OverlapWriter&lt; TAlgebra &gt;::init()</a>.</p>

</div>
</div>
<a id="ga16d29da500a93fd47184d23442fcd5ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16d29da500a93fd47184d23442fcd5ed">&#9670;&nbsp;</a></span>GenerateGlobalAlgebraIDs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TLayout &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ug::GenerateGlobalAlgebraIDs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_interface_communicator.html">pcl::InterfaceCommunicator</a>&lt; TLayout &gt; &amp;&#160;</td>
          <td class="paramname"><em>communicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structug_1_1_algebra_i_d.html">AlgebraID</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>idsOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numIDs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TLayout &amp;&#160;</td>
          <td class="paramname"><em>masterLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TLayout &amp;&#160;</td>
          <td class="paramname"><em>slaveLayout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a set of unique global algebra ids. </p>
<p>Horizontal slaves have the same algebra-id as their associated horizontal masters. Make sure that masterLayout and slaveLayout do not reference indices &gt;= numIDs. </p>

<p class="reference">References <a class="el" href="classpcl_1_1_interface_communicator.html#a86d3ffad4801623f1401b0d14ef5c1ae">pcl::InterfaceCommunicator&lt; TLayout &gt;::communicate()</a>, <a class="el" href="group__pcl.html#ga319e84518e2b596fc9f9b40b4383ec36">pcl::ProcRank()</a>, <a class="el" href="profiler_8h.html#a3766fe91615588782ad5452a4d60ea5b">PROFILE_FUNC_GROUP</a>, <a class="el" href="classpcl_1_1_interface_communicator.html#aa7cd1f6556736ad0a9f556546166c1bd">pcl::InterfaceCommunicator&lt; TLayout &gt;::receive_data()</a>, and <a class="el" href="classpcl_1_1_interface_communicator.html#a870c5820b4a0762086775b389f7f6aa0">pcl::InterfaceCommunicator&lt; TLayout &gt;::send_data()</a>.</p>

<p class="reference">Referenced by <a class="el" href="namespaceug.html#a7088b9aeb9fbd910b33bebc856b18f5b">ug::CreateOverlap()</a>, <a class="el" href="group__lib__algebra__parallelization__util.html#ga3da2c2603824b8c974b22d8b2f67275b">ug::MatAddSlaveRowsToMasterRowOverlap0()</a>, <a class="el" href="group__lib__algebra__parallelization__util.html#ga62ff21e4f3ecc0f4803e61725edd7fed">ug::MatMakeConsistentOverlap0()</a>, <a class="el" href="classug_1_1_parallel_nodes.html#a76aa7cea1a8286774926fcd7a5f13ec6">ug::ParallelNodes::ParallelNodes()</a>, and <a class="el" href="namespaceug.html#a2ee4542a644c6674bf17f17facc32955">ug::TestHorizontalAlgebraLayouts()</a>.</p>

</div>
</div>
<a id="ga3da2c2603824b8c974b22d8b2f67275b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3da2c2603824b8c974b22d8b2f67275b">&#9670;&nbsp;</a></span>MatAddSlaveRowsToMasterRowOverlap0()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMatrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ug::MatAddSlaveRowsToMasterRowOverlap0 </td>
          <td>(</td>
          <td class="paramtype">TMatrix &amp;&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a set of unique global algebra ids. </p>
<p>Horizontal slaves have the same algebra-id as their associated horizontal masters. Make sure that masterLayout and slaveLayout do not reference indices &gt;= numIDs. </p>

<p class="reference">References <a class="el" href="classpcl_1_1_interface_communicator.html#a86d3ffad4801623f1401b0d14ef5c1ae">pcl::InterfaceCommunicator&lt; TLayout &gt;::communicate()</a>, <a class="el" href="group__lib__algebra__parallelization__util.html#ga16d29da500a93fd47184d23442fcd5ed">ug::GenerateGlobalAlgebraIDs()</a>, <a class="el" href="profiler_8h.html#a3766fe91615588782ad5452a4d60ea5b">PROFILE_FUNC_GROUP</a>, <a class="el" href="classpcl_1_1_interface_communicator.html#aa7cd1f6556736ad0a9f556546166c1bd">pcl::InterfaceCommunicator&lt; TLayout &gt;::receive_data()</a>, and <a class="el" href="classpcl_1_1_interface_communicator.html#a870c5820b4a0762086775b389f7f6aa0">pcl::InterfaceCommunicator&lt; TLayout &gt;::send_data()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classug_1_1_i_external_solver.html#a2f75d3f467d7f62b0ad6d08bcd6cf636">ug::IExternalSolver&lt; TAlgebra &gt;::mat_preprocess()</a>, <a class="el" href="classug_1_1_i_l_u_t_scalar_preconditioner.html#aa86a2242cc3ab137250d43e162b8415a">ug::ILUTScalarPreconditioner&lt; TAlgebra &gt;::preprocess()</a>, <a class="el" href="classug_1_1_i_block_jacobi_preconditioner.html#a634ba3f20a70d90a7432180bf5c1c10a">ug::IBlockJacobiPreconditioner&lt; TAlgebra &gt;::preprocess()</a>, <a class="el" href="classug_1_1_i_l_u.html#a5952ebace9335bc3c223eec6cb6fe9dd">ug::ILU&lt; TAlgebra &gt;::preprocess()</a>, and <a class="el" href="classug_1_1_i_l_u_t_preconditioner.html#a878bfddd48692c49aa517d9bd3e2465a">ug::ILUTPreconditioner&lt; TAlgebra &gt;::preprocess_mat()</a>.</p>

</div>
</div>
<a id="ga62ff21e4f3ecc0f4803e61725edd7fed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga62ff21e4f3ecc0f4803e61725edd7fed">&#9670;&nbsp;</a></span>MatMakeConsistentOverlap0()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMatrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ug::MatMakeConsistentOverlap0 </td>
          <td>(</td>
          <td class="paramtype">TMatrix &amp;&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a set of unique global algebra ids. </p>
<p>Horizontal slaves have the same algebra-id as their associated horizontal masters. Make sure that masterLayout and slaveLayout do not reference indices &gt;= numIDs. </p>

<p class="reference">References <a class="el" href="classpcl_1_1_interface_communicator.html#a86d3ffad4801623f1401b0d14ef5c1ae">pcl::InterfaceCommunicator&lt; TLayout &gt;::communicate()</a>, <a class="el" href="group__lib__algebra__parallelization__util.html#ga16d29da500a93fd47184d23442fcd5ed">ug::GenerateGlobalAlgebraIDs()</a>, <a class="el" href="profiler_8h.html#a3766fe91615588782ad5452a4d60ea5b">PROFILE_FUNC_GROUP</a>, <a class="el" href="classpcl_1_1_interface_communicator.html#aa7cd1f6556736ad0a9f556546166c1bd">pcl::InterfaceCommunicator&lt; TLayout &gt;::receive_data()</a>, and <a class="el" href="classpcl_1_1_interface_communicator.html#a870c5820b4a0762086775b389f7f6aa0">pcl::InterfaceCommunicator&lt; TLayout &gt;::send_data()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classug_1_1_i_external_solver.html#a2f75d3f467d7f62b0ad6d08bcd6cf636">ug::IExternalSolver&lt; TAlgebra &gt;::mat_preprocess()</a>, <a class="el" href="classug_1_1_gauss_seidel_base.html#ab9f60018ba3d3c2b0d8744e1f9cdb013">ug::GaussSeidelBase&lt; TAlgebra &gt;::preprocess()</a>, and <a class="el" href="classug_1_1_i_l_u.html#a5952ebace9335bc3c223eec6cb6fe9dd">ug::ILU&lt; TAlgebra &gt;::preprocess()</a>.</p>

</div>
</div>
<a id="ga008815d4f97936dac5cae4be5e019c0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga008815d4f97936dac5cae4be5e019c0c">&#9670;&nbsp;</a></span>ScaleLayoutValues()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ug::ScaleLayoutValues </td>
          <td>(</td>
          <td class="paramtype">TVector *&#160;</td>
          <td class="paramname"><em>pVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__lib__algebra__parallelization.html#gad2e106a1a11b3d94250becdabf196f65">IndexLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a>&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>scales the values of a vector by a given number only on the layout indices </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pVec</td><td><a class="el" href="classug_1_1_vector.html">Vector</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layout</td><td>Layout </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scale</td><td>Scaling factor </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classpcl_1_1_single_level_layout.html#a1ad0d030bdaa6c59bb7367db9ad8a806">pcl::SingleLevelLayout&lt; TInterface &gt;::begin()</a>, <a class="el" href="classpcl_1_1_single_level_layout.html#a0575221758f8b725e20ac5dddfe2a529">pcl::SingleLevelLayout&lt; TInterface &gt;::end()</a>, <a class="el" href="classpcl_1_1_ordered_interface.html#abbeeb5588895dd0649681116c3900bbf">pcl::OrderedInterface&lt; TType, TContainer, TAlloc &gt;::get_element()</a>, and <a class="el" href="profiler_8h.html#a3766fe91615588782ad5452a4d60ea5b">PROFILE_FUNC_GROUP</a>.</p>

<p class="reference">Referenced by <a class="el" href="classug_1_1_std_transfer.html#a260f0387f239404feda34377798a104e">ug::StdTransfer&lt; TDomain, TAlgebra &gt;::prolongate()</a>.</p>

</div>
</div>
<a id="ga9801a124862216fb6db2999188ac4c32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9801a124862216fb6db2999188ac4c32">&#9670;&nbsp;</a></span>SetInterfaceValues()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ug::SetInterfaceValues </td>
          <td>(</td>
          <td class="paramtype">TVector *&#160;</td>
          <td class="paramname"><em>pVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpcl_1_1_single_level_layout.html#ad72a8f489a129a6f85eab9f4a7b01020">IndexLayout::Interface</a> &amp;&#160;</td>
          <td class="paramname"><em>interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="sparsematrix__interface_8h.html#a265a253612b46abed17c61b0a5e5ce30">TVector::value_type</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sets the values of a vector to a given number only on the interface indices </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pVec</td><td><a class="el" href="classug_1_1_vector.html">Vector</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layout</td><td>Layout </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>Value to set on layout indices </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classpcl_1_1_ordered_interface.html#a8b90a445fb14789fb9b257123c39f7ea">pcl::OrderedInterface&lt; TType, TContainer, TAlloc &gt;::begin()</a>, <a class="el" href="classpcl_1_1_ordered_interface.html#a4b82cef21a9e8490dec38c27776a7976">pcl::OrderedInterface&lt; TType, TContainer, TAlloc &gt;::end()</a>, <a class="el" href="classpcl_1_1_ordered_interface.html#abbeeb5588895dd0649681116c3900bbf">pcl::OrderedInterface&lt; TType, TContainer, TAlloc &gt;::get_element()</a>, and <a class="el" href="profiler_8h.html#a3766fe91615588782ad5452a4d60ea5b">PROFILE_FUNC_GROUP</a>.</p>

</div>
</div>
<a id="ga33b4797e3d3382885a96223a2c44d72f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33b4797e3d3382885a96223a2c44d72f">&#9670;&nbsp;</a></span>SetLayoutValues()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ug::SetLayoutValues </td>
          <td>(</td>
          <td class="paramtype">TVector *&#160;</td>
          <td class="paramname"><em>pVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__lib__algebra__parallelization.html#gad2e106a1a11b3d94250becdabf196f65">IndexLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="sparsematrix__interface_8h.html#a265a253612b46abed17c61b0a5e5ce30">TVector::value_type</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sets the values of a vector to a given number only on the layout indices </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pVec</td><td><a class="el" href="classug_1_1_vector.html">Vector</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layout</td><td>Layout </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>Value to set on layout indices </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classpcl_1_1_single_level_layout.html#a1ad0d030bdaa6c59bb7367db9ad8a806">pcl::SingleLevelLayout&lt; TInterface &gt;::begin()</a>, <a class="el" href="classpcl_1_1_single_level_layout.html#a0575221758f8b725e20ac5dddfe2a529">pcl::SingleLevelLayout&lt; TInterface &gt;::end()</a>, <a class="el" href="classpcl_1_1_ordered_interface.html#abbeeb5588895dd0649681116c3900bbf">pcl::OrderedInterface&lt; TType, TContainer, TAlloc &gt;::get_element()</a>, and <a class="el" href="profiler_8h.html#a3766fe91615588782ad5452a4d60ea5b">PROFILE_FUNC_GROUP</a>.</p>

<p class="reference">Referenced by <a class="el" href="classug_1_1_assembled_multi_grid_cycle.html#a1b2fadecff11f0b0101670f21f0bd48f">ug::AssembledMultiGridCycle&lt; TDomain, TAlgebra &gt;::base_solve()</a>, <a class="el" href="group__lib__algebra__parallelization__util.html#ga0d12aface4416d0f6cc43997ad21001f">ug::ConsistentToUnique()</a>, <a class="el" href="classug_1_1_parallel_vector.html#af4c3e5106b467d0995901ae29cac71de">ug::ParallelVector&lt; TVector &gt;::enforce_consistent_type()</a>, <a class="el" href="namespaceug.html#a18b06f5618d879be669451b63ecedcbb">ug::GenerateGlobalConsecutiveIndices()</a>, <a class="el" href="classug_1_1_assembled_multi_grid_cycle.html#ace6abf97c116ebc1c904c8861c6b4933">ug::AssembledMultiGridCycle&lt; TDomain, TAlgebra &gt;::presmooth_and_restriction()</a>, <a class="el" href="classug_1_1_gauss_seidel_base.html#a536783cd74d99826c66db6f07daf19f8">ug::GaussSeidelBase&lt; TAlgebra &gt;::step()</a>, and <a class="el" href="classug_1_1_i_l_u.html#aa996dcc25fe8253a80ea70410ffcb333">ug::ILU&lt; TAlgebra &gt;::step()</a>.</p>

</div>
</div>
<a id="ga41105b645bc5319e94c405fd4670b848"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41105b645bc5319e94c405fd4670b848">&#9670;&nbsp;</a></span>UniqueToConsistent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ug::UniqueToConsistent </td>
          <td>(</td>
          <td class="paramtype">TVector *&#160;</td>
          <td class="paramname"><em>pVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__lib__algebra__parallelization.html#gad2e106a1a11b3d94250becdabf196f65">IndexLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>masterLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__lib__algebra__parallelization.html#gad2e106a1a11b3d94250becdabf196f65">IndexLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>slaveLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_interface_communicator.html">pcl::InterfaceCommunicator</a>&lt; <a class="el" href="group__lib__algebra__parallelization.html#gad2e106a1a11b3d94250becdabf196f65">IndexLayout</a> &gt; *&#160;</td>
          <td class="paramname"><em>pCom</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>changes parallel storage type from unique to consistent </p>
<p>This function changes the storage type of a parallel vector from unique to consistent. A InterfaceCommunicator is created iff no communicator passed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pVec</td><td>Parallel <a class="el" href="classug_1_1_vector.html">Vector</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">masterLayout</td><td>Master Layout </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slaveLayout</td><td>Slave Layout </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pCom</td><td>Parallel Communicator </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classpcl_1_1_interface_communicator.html#a86d3ffad4801623f1401b0d14ef5c1ae">pcl::InterfaceCommunicator&lt; TLayout &gt;::communicate()</a>, <a class="el" href="profiler_8h.html#a3766fe91615588782ad5452a4d60ea5b">PROFILE_FUNC_GROUP</a>, <a class="el" href="classpcl_1_1_interface_communicator.html#aa7cd1f6556736ad0a9f556546166c1bd">pcl::InterfaceCommunicator&lt; TLayout &gt;::receive_data()</a>, and <a class="el" href="classpcl_1_1_interface_communicator.html#a870c5820b4a0762086775b389f7f6aa0">pcl::InterfaceCommunicator&lt; TLayout &gt;::send_data()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classug_1_1_parallel_vector.html#af4c3e5106b467d0995901ae29cac71de">ug::ParallelVector&lt; Vector&lt; double &gt; &gt;::enforce_consistent_type()</a>.</p>

</div>
</div>
<a id="ga0b8fc9258a77acf678a224ad4366e65e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b8fc9258a77acf678a224ad4366e65e">&#9670;&nbsp;</a></span>VecCopy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ug::VecCopy </td>
          <td>(</td>
          <td class="paramtype">TVector *&#160;</td>
          <td class="paramname"><em>pVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__lib__algebra__parallelization.html#gad2e106a1a11b3d94250becdabf196f65">IndexLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>masterLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__lib__algebra__parallelization.html#gad2e106a1a11b3d94250becdabf196f65">IndexLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>slaveLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_interface_communicator.html">pcl::InterfaceCommunicator</a>&lt; <a class="el" href="group__lib__algebra__parallelization.html#gad2e106a1a11b3d94250becdabf196f65">IndexLayout</a> &gt; *&#160;</td>
          <td class="paramname"><em>pCom</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>copy a vector only at a layout </p>
<p>This function copies a vector only at a layout. Communication is performed. Information flow is from masters to slaves but not vice versa. Note: This function is basically '<a class="el" href="group__lib__algebra__parallelization__util.html#ga41105b645bc5319e94c405fd4670b848" title="changes parallel storage type from unique to consistent">UniqueToConsistent()</a>', so "sender" and "receiver" in this function are the same as in '<a class="el" href="group__lib__algebra__parallelization__util.html#ga41105b645bc5319e94c405fd4670b848" title="changes parallel storage type from unique to consistent">UniqueToConsistent()</a>').</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pVec</td><td>Parallel <a class="el" href="classug_1_1_vector.html">Vector</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">masterLayout</td><td>Master Layout </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slaveLayout</td><td>Slave Layout </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pCom</td><td>Parallel Communicator </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classpcl_1_1_interface_communicator.html#a86d3ffad4801623f1401b0d14ef5c1ae">pcl::InterfaceCommunicator&lt; TLayout &gt;::communicate()</a>, <a class="el" href="profiler_8h.html#a3766fe91615588782ad5452a4d60ea5b">PROFILE_FUNC_GROUP</a>, <a class="el" href="classpcl_1_1_interface_communicator.html#aa7cd1f6556736ad0a9f556546166c1bd">pcl::InterfaceCommunicator&lt; TLayout &gt;::receive_data()</a>, and <a class="el" href="classpcl_1_1_interface_communicator.html#a870c5820b4a0762086775b389f7f6aa0">pcl::InterfaceCommunicator&lt; TLayout &gt;::send_data()</a>.</p>

</div>
</div>
<a id="ga8263314ed9f4dc23d502a82e85038c78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8263314ed9f4dc23d502a82e85038c78">&#9670;&nbsp;</a></span>VecSubtractOneSlaveFromMaster()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ug::VecSubtractOneSlaveFromMaster </td>
          <td>(</td>
          <td class="paramtype">TVector *&#160;</td>
          <td class="paramname"><em>pVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__lib__algebra__parallelization.html#gad2e106a1a11b3d94250becdabf196f65">IndexLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>masterLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__lib__algebra__parallelization.html#gad2e106a1a11b3d94250becdabf196f65">IndexLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>slaveLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_interface_communicator.html">pcl::InterfaceCommunicator</a>&lt; <a class="el" href="group__lib__algebra__parallelization.html#gad2e106a1a11b3d94250becdabf196f65">IndexLayout</a> &gt; *&#160;</td>
          <td class="paramname"><em>pCom</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>subtracts values of only one slave dof per master on layout </p>
<p>This function subtracts one slave value dof per master dof. Communication is performed. Information flow is from slaves to masters but not vice versa.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pVec</td><td>Parallel <a class="el" href="classug_1_1_vector.html">Vector</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">masterLayout</td><td>Master Layout </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slaveLayout</td><td>Slave Layout </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pCom</td><td>Parallel Communicator </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classpcl_1_1_interface_communicator.html#a86d3ffad4801623f1401b0d14ef5c1ae">pcl::InterfaceCommunicator&lt; TLayout &gt;::communicate()</a>, <a class="el" href="profiler_8h.html#a3766fe91615588782ad5452a4d60ea5b">PROFILE_FUNC_GROUP</a>, <a class="el" href="classpcl_1_1_interface_communicator.html#aa7cd1f6556736ad0a9f556546166c1bd">pcl::InterfaceCommunicator&lt; TLayout &gt;::receive_data()</a>, and <a class="el" href="classpcl_1_1_interface_communicator.html#a870c5820b4a0762086775b389f7f6aa0">pcl::InterfaceCommunicator&lt; TLayout &gt;::send_data()</a>.</p>

<p class="reference">Referenced by <a class="el" href="namespaceug.html#a794df0919e5dd7bdbaf4181fb438bf83">ug::ComputeDifferenceOnDelta()</a>.</p>

</div>
</div>
<a id="ga7ec969fdb51f7876a953e584f640650d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ec969fdb51f7876a953e584f640650d">&#9670;&nbsp;</a></span>VecSubtractOnLayout()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ug::VecSubtractOnLayout </td>
          <td>(</td>
          <td class="paramtype">TVector *&#160;</td>
          <td class="paramname"><em>pVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__lib__algebra__parallelization.html#gad2e106a1a11b3d94250becdabf196f65">IndexLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>masterLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__lib__algebra__parallelization.html#gad2e106a1a11b3d94250becdabf196f65">IndexLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>slaveLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcl_1_1_interface_communicator.html">pcl::InterfaceCommunicator</a>&lt; <a class="el" href="group__lib__algebra__parallelization.html#gad2e106a1a11b3d94250becdabf196f65">IndexLayout</a> &gt; *&#160;</td>
          <td class="paramname"><em>pCom</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>subtracts values of slave layout from master layout and sets slave layouts to negative of difference </p>
<p>This function subtracts all slave values from the master value. Then, the slave values are set to the negative of the computed difference.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pVec</td><td>Parallel <a class="el" href="classug_1_1_vector.html">Vector</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">masterLayout</td><td>Master Layout </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slaveLayout</td><td>Slave Layout </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pCom</td><td>Parallel Communicator </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classpcl_1_1_interface_communicator.html#a86d3ffad4801623f1401b0d14ef5c1ae">pcl::InterfaceCommunicator&lt; TLayout &gt;::communicate()</a>, <a class="el" href="profiler_8h.html#a3766fe91615588782ad5452a4d60ea5b">PROFILE_FUNC_GROUP</a>, <a class="el" href="classpcl_1_1_interface_communicator.html#aa7cd1f6556736ad0a9f556546166c1bd">pcl::InterfaceCommunicator&lt; TLayout &gt;::receive_data()</a>, and <a class="el" href="classpcl_1_1_interface_communicator.html#a870c5820b4a0762086775b389f7f6aa0">pcl::InterfaceCommunicator&lt; TLayout &gt;::send_data()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Jul 24 2023 01:07:57 for ug4 by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
