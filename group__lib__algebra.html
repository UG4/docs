<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ug4: lib_algebra</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ug4
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__lib__algebra.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">lib_algebra</div>  </div>
</div><!--header-->
<div class="contents">

<p>Algebra Library.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__cpu__algebra"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpu__algebra.html">CPU Algebra</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__crs__algebra"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__crs__algebra.html">CRS Algebra</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__lib__algebra__common"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__algebra__common.html">lib_algebra Common</a></td></tr>
<tr class="memdesc:group__lib__algebra__common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utilities for libAlgebra. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__lib__algebra__parallelization"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__algebra__parallelization.html">Parallel Algebra</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__small__algebra"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__small__algebra.html">Small Algebra</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_algebra_type.html">ug::AlgebraType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">class describing the type of an algebra  <a href="classug_1_1_algebra_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_default_algebra.html">ug::DefaultAlgebra</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Singleton, providing the current default algebra.  <a href="classug_1_1_default_algebra.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structug_1_1_dense_matrix_from_sparse_matrix.html">ug::DenseMatrixFromSparseMatrix&lt; TSparseMatrix &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_map_sparse_matrix.html">ug::MapSparseMatrix&lt; TValueType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">sparse matrix for big, variable sparse matrices.  <a href="classug_1_1_map_sparse_matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_map_vector.html">ug::MapVector&lt; TValueType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structug_1_1matrix__algebra__type__traits_3_01_map_sparse_matrix_3_01_t_01_4_01_4.html">ug::matrix_algebra_type_traits&lt; MapSparseMatrix&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structug_1_1sort_struct.html">ug::sortStruct&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga4526bb543d3223ad7d3b5425283c875c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__algebra.html#ga4526bb543d3223ad7d3b5425283c875c">FORCE_CREATION</a>&#160;&#160;&#160;volatile size_t ___never_happens___ = 0; <a class="el" href="parser_8cpp.html#ab3454b1e7e7c4c0b732dfeb74a0c040f">if</a>(___never_happens___)</td></tr>
<tr class="separator:ga4526bb543d3223ad7d3b5425283c875c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf7f98346f6aa16fc71901289cab8412"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__algebra.html#gadf7f98346f6aa16fc71901289cab8412">UNUSED_VARIABLE</a>(var)&#160;&#160;&#160;((void) var);</td></tr>
<tr class="memdesc:gadf7f98346f6aa16fc71901289cab8412"><td class="mdescLeft">&#160;</td><td class="mdescRight">prevent unused variable-warnings  <a href="group__lib__algebra.html#gadf7f98346f6aa16fc71901289cab8412">More...</a><br /></td></tr>
<tr class="separator:gadf7f98346f6aa16fc71901289cab8412"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga5e483791c37d11d54d2fa0ac352d3c90"><td class="memItemLeft" align="right" valign="top">typedef TValueType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__algebra.html#ga5e483791c37d11d54d2fa0ac352d3c90">ug::MapVector&lt; TValueType &gt;::value_type</a></td></tr>
<tr class="separator:ga5e483791c37d11d54d2fa0ac352d3c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf11c2aa408d075d1f6fa6e217f6afe13"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classug_1_1_map_vector.html">MapVector</a>&lt; TValueType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__algebra.html#gaf11c2aa408d075d1f6fa6e217f6afe13">ug::MapVector&lt; TValueType &gt;::vector_type</a></td></tr>
<tr class="separator:gaf11c2aa408d075d1f6fa6e217f6afe13"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga17d1221cff7d2e57c43bca8c2159b4b7"><td class="memTemplParams" colspan="2">template&lt;typename ABC_type , typename A_type , typename B_type , typename C_type &gt; </td></tr>
<tr class="memitem:ga17d1221cff7d2e57c43bca8c2159b4b7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__algebra.html#ga17d1221cff7d2e57c43bca8c2159b4b7">ug::AddMultiplyOf</a> (<a class="el" href="sparsematrix__interface_8h.html#ab9e3f3f78158aa638cac857df2cfee9b">ABC_type</a> &amp;M, const <a class="el" href="sparsematrix__interface_8h.html#aeff4317cfbde1de13f86a24953f0d838">A_type</a> &amp;A, const <a class="el" href="sparsematrix__interface_8h.html#a2311fc15e144ac7dd6261c83ffad242b">B_type</a> &amp;B, const C_type &amp;C, double epsilonTruncation=0.0)</td></tr>
<tr class="memdesc:ga17d1221cff7d2e57c43bca8c2159b4b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates M += A*B*C.  <a href="group__lib__algebra.html#ga17d1221cff7d2e57c43bca8c2159b4b7">More...</a><br /></td></tr>
<tr class="separator:ga17d1221cff7d2e57c43bca8c2159b4b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ee6d5fac7a8757239cd98ab67e747da"><td class="memTemplParams" colspan="2">template&lt;typename TSparseMatrix , typename vector_t &gt; </td></tr>
<tr class="memitem:ga9ee6d5fac7a8757239cd98ab67e747da"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__algebra.html#ga9ee6d5fac7a8757239cd98ab67e747da">ug::Axpy_transposedCommonSparseMatrix</a> (const TSparseMatrix &amp;A, vector_t &amp;dest, const <a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a> &amp;alpha1, const vector_t &amp;v1, const <a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a> &amp;beta1, const vector_t &amp;w1)</td></tr>
<tr class="separator:ga9ee6d5fac7a8757239cd98ab67e747da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cd3c946e0dc8412ff327804b1cdbe84"><td class="memTemplParams" colspan="2">template&lt;typename TSparseMatrix , typename vector_t &gt; </td></tr>
<tr class="memitem:ga5cd3c946e0dc8412ff327804b1cdbe84"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__algebra.html#ga5cd3c946e0dc8412ff327804b1cdbe84">ug::AxpyCommonSparseMatrix</a> (const TSparseMatrix &amp;A, vector_t &amp;dest, const <a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a> &amp;alpha1, const vector_t &amp;v1, const <a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a> &amp;beta1, const vector_t &amp;w1)</td></tr>
<tr class="separator:ga5cd3c946e0dc8412ff327804b1cdbe84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ff420bacd1e54330978db211ae8270f"><td class="memTemplParams" colspan="2">template&lt;typename TSparseMatrix &gt; </td></tr>
<tr class="memitem:ga5ff420bacd1e54330978db211ae8270f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__algebra.html#ga5ff420bacd1e54330978db211ae8270f">ug::CheckDiagonalInvertible</a> (const <a class="el" href="classug_1_1_parallel_matrix.html">ParallelMatrix</a>&lt; TSparseMatrix &gt; &amp;m)</td></tr>
<tr class="separator:ga5ff420bacd1e54330978db211ae8270f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27e3e71059c2ae350f51716e1ebd66ef"><td class="memTemplParams" colspan="2">template&lt;typename TSparseMatrix &gt; </td></tr>
<tr class="memitem:ga27e3e71059c2ae350f51716e1ebd66ef"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__algebra.html#ga27e3e71059c2ae350f51716e1ebd66ef">ug::CheckDiagonalInvertible</a> (const TSparseMatrix &amp;A)</td></tr>
<tr class="separator:ga27e3e71059c2ae350f51716e1ebd66ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36194b79ab7b8fbc13e63016e598ffe7"><td class="memTemplParams" colspan="2">template&lt;typename TSparseMatrix &gt; </td></tr>
<tr class="memitem:ga36194b79ab7b8fbc13e63016e598ffe7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__algebra.html#ga36194b79ab7b8fbc13e63016e598ffe7">ug::CheckRowIterators</a> (const TSparseMatrix &amp;A)</td></tr>
<tr class="separator:ga36194b79ab7b8fbc13e63016e598ffe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72f2a1c3cfd4b8babafe92fc636a2d85"><td class="memTemplParams" colspan="2">template&lt;typename TVector &gt; </td></tr>
<tr class="memitem:ga72f2a1c3cfd4b8babafe92fc636a2d85"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__algebra.html#ga72f2a1c3cfd4b8babafe92fc636a2d85">ug::CheckVectorInvertible</a> (const <a class="el" href="classug_1_1_parallel_vector.html">ParallelVector</a>&lt; TVector &gt; &amp;v)</td></tr>
<tr class="separator:ga72f2a1c3cfd4b8babafe92fc636a2d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f054358e74488ce11850263ff62c6a1"><td class="memTemplParams" colspan="2">template&lt;typename TVector &gt; </td></tr>
<tr class="memitem:ga2f054358e74488ce11850263ff62c6a1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__algebra.html#ga2f054358e74488ce11850263ff62c6a1">ug::CheckVectorInvertible</a> (const TVector &amp;v)</td></tr>
<tr class="separator:ga2f054358e74488ce11850263ff62c6a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec865da3d07ee7bcf932b2ee5d3a8e77"><td class="memTemplParams" colspan="2">template&lt;typename AB_type , typename A_type , typename B_type &gt; </td></tr>
<tr class="memitem:gaec865da3d07ee7bcf932b2ee5d3a8e77"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__algebra.html#gaec865da3d07ee7bcf932b2ee5d3a8e77">ug::CreateAsMultiplyOf</a> (AB_type &amp;M, const <a class="el" href="sparsematrix__interface_8h.html#aeff4317cfbde1de13f86a24953f0d838">A_type</a> &amp;A, const <a class="el" href="sparsematrix__interface_8h.html#a2311fc15e144ac7dd6261c83ffad242b">B_type</a> &amp;B)</td></tr>
<tr class="memdesc:gaec865da3d07ee7bcf932b2ee5d3a8e77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates M = A*B.  <a href="group__lib__algebra.html#gaec865da3d07ee7bcf932b2ee5d3a8e77">More...</a><br /></td></tr>
<tr class="separator:gaec865da3d07ee7bcf932b2ee5d3a8e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a6a6e8f6a05082613a1870297e7ea8a"><td class="memTemplParams" colspan="2">template&lt;typename ABC_type , typename A_type , typename B_type , typename C_type &gt; </td></tr>
<tr class="memitem:ga9a6a6e8f6a05082613a1870297e7ea8a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__algebra.html#ga9a6a6e8f6a05082613a1870297e7ea8a">ug::CreateAsMultiplyOf</a> (<a class="el" href="sparsematrix__interface_8h.html#ab9e3f3f78158aa638cac857df2cfee9b">ABC_type</a> &amp;M, const <a class="el" href="sparsematrix__interface_8h.html#aeff4317cfbde1de13f86a24953f0d838">A_type</a> &amp;A, const <a class="el" href="sparsematrix__interface_8h.html#a2311fc15e144ac7dd6261c83ffad242b">B_type</a> &amp;B, const C_type &amp;C, double epsilonTruncation=0.0)</td></tr>
<tr class="memdesc:ga9a6a6e8f6a05082613a1870297e7ea8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates M = A*B*C.  <a href="group__lib__algebra.html#ga9a6a6e8f6a05082613a1870297e7ea8a">More...</a><br /></td></tr>
<tr class="separator:ga9a6a6e8f6a05082613a1870297e7ea8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef5b964b912673a04dd75cb4d6c06f3d"><td class="memTemplParams" colspan="2">template&lt;typename TSparseMatrix , class TIStream &gt; </td></tr>
<tr class="memitem:gaef5b964b912673a04dd75cb4d6c06f3d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__algebra.html#gaef5b964b912673a04dd75cb4d6c06f3d">ug::DeserializeMatrix</a> (TIStream &amp;buf, TSparseMatrix &amp;A)</td></tr>
<tr class="separator:gaef5b964b912673a04dd75cb4d6c06f3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0530b5446400873554834211f173970"><td class="memTemplParams" colspan="2">template&lt;typename Matrix_type , typename Vector_type &gt; </td></tr>
<tr class="memitem:gaa0530b5446400873554834211f173970"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__algebra.html#gaa0530b5446400873554834211f173970">ug::diag_step</a> (const Matrix_type &amp;A, Vector_type &amp;c, const Vector_type &amp;d, <a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a> damp)</td></tr>
<tr class="memdesc:gaa0530b5446400873554834211f173970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a jacobi-step.  <a href="group__lib__algebra.html#gaa0530b5446400873554834211f173970">More...</a><br /></td></tr>
<tr class="separator:gaa0530b5446400873554834211f173970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ed0739a5937e2adeadf74439e187b01"><td class="memTemplParams" colspan="2">template&lt;typename TDenseType , typename TSparseMatrix &gt; </td></tr>
<tr class="memitem:ga9ed0739a5937e2adeadf74439e187b01"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__algebra.html#ga9ed0739a5937e2adeadf74439e187b01">ug::GetDenseDoubleFromSparse</a> (TDenseType &amp;A, const TSparseMatrix &amp;S)</td></tr>
<tr class="separator:ga9ed0739a5937e2adeadf74439e187b01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25765881ec0229d2f6b0a2cde2202f59"><td class="memTemplParams" colspan="2">template&lt;typename TSparseMatrix &gt; </td></tr>
<tr class="memitem:ga25765881ec0229d2f6b0a2cde2202f59"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structug_1_1_dense_matrix_from_sparse_matrix.html">DenseMatrixFromSparseMatrix</a>&lt; TSparseMatrix &gt;::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__algebra.html#ga25765881ec0229d2f6b0a2cde2202f59">ug::GetDenseFromSparse</a> (typename <a class="el" href="structug_1_1_dense_matrix_from_sparse_matrix.html">DenseMatrixFromSparseMatrix</a>&lt; TSparseMatrix &gt;::type &amp;A, const TSparseMatrix &amp;S)</td></tr>
<tr class="separator:ga25765881ec0229d2f6b0a2cde2202f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04e1b55e8160dd71a6bde7371d655af4"><td class="memTemplParams" colspan="2">template&lt;typename TDoubleType , typename TSparseMatrix &gt; </td></tr>
<tr class="memitem:ga04e1b55e8160dd71a6bde7371d655af4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__algebra.html#ga04e1b55e8160dd71a6bde7371d655af4">ug::GetDoubleFromSparseBlock</a> (TDoubleType &amp;A, const TSparseMatrix &amp;S)</td></tr>
<tr class="separator:ga04e1b55e8160dd71a6bde7371d655af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga066c012e62162f3245b680048351bee9"><td class="memTemplParams" colspan="2">template&lt;typename TSparseMatrix &gt; </td></tr>
<tr class="memitem:ga066c012e62162f3245b680048351bee9"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__algebra.html#ga066c012e62162f3245b680048351bee9">ug::GetDoubleSize</a> (const TSparseMatrix &amp;S)</td></tr>
<tr class="separator:ga066c012e62162f3245b680048351bee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga476f78fff8ccd5c4fd626f4925f3a67b"><td class="memTemplParams" colspan="2">template&lt;typename TDoubleSparse , typename TSparseMatrix &gt; </td></tr>
<tr class="memitem:ga476f78fff8ccd5c4fd626f4925f3a67b"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__algebra.html#ga476f78fff8ccd5c4fd626f4925f3a67b">ug::GetDoubleSparseFromBlockSparse</a> (TDoubleSparse &amp;A, const TSparseMatrix &amp;S)</td></tr>
<tr class="separator:ga476f78fff8ccd5c4fd626f4925f3a67b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefc28813774a71719d96778603d26282"><td class="memTemplParams" colspan="2">template&lt;typename TSparseMatrix &gt; </td></tr>
<tr class="memitem:gaefc28813774a71719d96778603d26282"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__algebra.html#gaefc28813774a71719d96778603d26282">ug::GetMaxConnections</a> (const TSparseMatrix &amp;A)</td></tr>
<tr class="memdesc:gaefc28813774a71719d96778603d26282"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns max number of non-zero connections in rows  <a href="group__lib__algebra.html#gaefc28813774a71719d96778603d26282">More...</a><br /></td></tr>
<tr class="separator:gaefc28813774a71719d96778603d26282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7dded838c7ae9cffe31c0aafb44e73a"><td class="memTemplParams" colspan="2">template&lt;typename TSparseMatrix &gt; </td></tr>
<tr class="memitem:gae7dded838c7ae9cffe31c0aafb44e73a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__algebra.html#gae7dded838c7ae9cffe31c0aafb44e73a">ug::GetNeighborhood</a> (const TSparseMatrix &amp;A, size_t node, size_t depth, std::vector&lt; size_t &gt; &amp;indices)</td></tr>
<tr class="separator:gae7dded838c7ae9cffe31c0aafb44e73a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4282b51c1309076385f9ce7ffc1b6711"><td class="memTemplParams" colspan="2">template&lt;typename TSparseMatrix &gt; </td></tr>
<tr class="memitem:ga4282b51c1309076385f9ce7ffc1b6711"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__algebra.html#ga4282b51c1309076385f9ce7ffc1b6711">ug::GetNeighborhood</a> (const TSparseMatrix &amp;A, size_t node, size_t depth, std::vector&lt; size_t &gt; &amp;indices, std::vector&lt; bool &gt; &amp;bVisited, bool bResetVisitedFlags=true)</td></tr>
<tr class="separator:ga4282b51c1309076385f9ce7ffc1b6711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f57b93a579bf6159d548139db9d955c"><td class="memTemplParams" colspan="2">template&lt;typename TSparseMatrix &gt; </td></tr>
<tr class="memitem:ga5f57b93a579bf6159d548139db9d955c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__algebra.html#ga5f57b93a579bf6159d548139db9d955c">ug::GetNeighborhood_worker</a> (const TSparseMatrix &amp;A, size_t node, size_t depth, std::vector&lt; size_t &gt; &amp;indices, std::vector&lt; bool &gt; &amp;bVisited)</td></tr>
<tr class="separator:ga5f57b93a579bf6159d548139db9d955c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecfee9ea1328c255c9198196bd41131e"><td class="memTemplParams" colspan="2">template&lt;typename TSparseMatrix &gt; </td></tr>
<tr class="memitem:gaecfee9ea1328c255c9198196bd41131e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__algebra.html#gaecfee9ea1328c255c9198196bd41131e">ug::GetNeighborhoodHierachy</a> (const TSparseMatrix &amp;A, size_t node, size_t depth, std::vector&lt; std::vector&lt; size_t &gt; &gt; &amp;indices)</td></tr>
<tr class="separator:gaecfee9ea1328c255c9198196bd41131e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae929092009419957d34116aafb267787"><td class="memTemplParams" colspan="2">template&lt;typename TSparseMatrix &gt; </td></tr>
<tr class="memitem:gae929092009419957d34116aafb267787"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__algebra.html#gae929092009419957d34116aafb267787">ug::GetNeighborhoodHierachy</a> (const TSparseMatrix &amp;A, size_t node, size_t depth, std::vector&lt; std::vector&lt; size_t &gt; &gt; &amp;indices, std::vector&lt; bool &gt; &amp;bVisited, bool bResetVisitedFlags=true)</td></tr>
<tr class="separator:gae929092009419957d34116aafb267787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1420754fc13975271b328dd56a08e85"><td class="memTemplParams" colspan="2">template&lt;typename TSparseMatrix &gt; </td></tr>
<tr class="memitem:gab1420754fc13975271b328dd56a08e85"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__algebra.html#gab1420754fc13975271b328dd56a08e85">ug::GetNeighborhoodHierachy_worker</a> (const TSparseMatrix &amp;A, size_t node, size_t depth, size_t maxdepth, std::vector&lt; std::vector&lt; size_t &gt; &gt; &amp;indices, std::vector&lt; bool &gt; &amp;bVisited)</td></tr>
<tr class="separator:gab1420754fc13975271b328dd56a08e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cc763c460b57eb9f5b2c6eb2fe2652f"><td class="memTemplParams" colspan="2">template&lt;typename TSparseMatrix &gt; </td></tr>
<tr class="memitem:ga6cc763c460b57eb9f5b2c6eb2fe2652f"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__algebra.html#ga6cc763c460b57eb9f5b2c6eb2fe2652f">ug::GetNNZs</a> (const TSparseMatrix &amp;A)</td></tr>
<tr class="memdesc:ga6cc763c460b57eb9f5b2c6eb2fe2652f"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the number of non-zeroes (!= number of connections)  <a href="group__lib__algebra.html#ga6cc763c460b57eb9f5b2c6eb2fe2652f">More...</a><br /></td></tr>
<tr class="separator:ga6cc763c460b57eb9f5b2c6eb2fe2652f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98970ee004dd8a19da9268ba651ffdce"><td class="memTemplParams" colspan="2">template&lt;typename Matrix_type , typename Vector_type &gt; </td></tr>
<tr class="memitem:ga98970ee004dd8a19da9268ba651ffdce"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__algebra.html#ga98970ee004dd8a19da9268ba651ffdce">ug::gs_step_LL</a> (const Matrix_type &amp;A, Vector_type &amp;c, const Vector_type &amp;d, const <a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a> relaxFactor)</td></tr>
<tr class="memdesc:ga98970ee004dd8a19da9268ba651ffdce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gauss-Seidel-Iterations.  <a href="group__lib__algebra.html#ga98970ee004dd8a19da9268ba651ffdce">More...</a><br /></td></tr>
<tr class="separator:ga98970ee004dd8a19da9268ba651ffdce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf89a853adfa2e1a00812ac4d9e160bbd"><td class="memTemplParams" colspan="2">template&lt;typename Matrix_type , typename Vector_type &gt; </td></tr>
<tr class="memitem:gaf89a853adfa2e1a00812ac4d9e160bbd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__algebra.html#gaf89a853adfa2e1a00812ac4d9e160bbd">ug::gs_step_LL</a> (const Matrix_type &amp;A, Vector_type &amp;x, const Vector_type &amp;b)</td></tr>
<tr class="memdesc:gaf89a853adfa2e1a00812ac4d9e160bbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a forward gauss-seidel-step, that is, solve on the lower left of A.  <a href="group__lib__algebra.html#gaf89a853adfa2e1a00812ac4d9e160bbd">More...</a><br /></td></tr>
<tr class="separator:gaf89a853adfa2e1a00812ac4d9e160bbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cec366add5874b559c21b14321e6a25"><td class="memTemplParams" colspan="2">template&lt;typename Matrix_type , typename Vector_type &gt; </td></tr>
<tr class="memitem:ga6cec366add5874b559c21b14321e6a25"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__algebra.html#ga6cec366add5874b559c21b14321e6a25">ug::gs_step_UR</a> (const Matrix_type &amp;A, Vector_type &amp;c, const Vector_type &amp;d, const <a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a> relaxFactor)</td></tr>
<tr class="memdesc:ga6cec366add5874b559c21b14321e6a25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a backward gauss-seidel-step, that is, solve on the upper right of A. Using gs_step_UR within a preconditioner-scheme leads to the fact that we get the correction by successive inserting the already computed values of c in c = N * d, with c being the correction and d being the defect. N denotes the matrix of the second normal-form of a linear iteration scheme.  <a href="group__lib__algebra.html#ga6cec366add5874b559c21b14321e6a25">More...</a><br /></td></tr>
<tr class="separator:ga6cec366add5874b559c21b14321e6a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad30a4b301891ccfb6f5ddaaab1b4b402"><td class="memTemplParams" colspan="2">template&lt;typename Matrix_type , typename Vector_type &gt; </td></tr>
<tr class="memitem:gad30a4b301891ccfb6f5ddaaab1b4b402"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__algebra.html#gad30a4b301891ccfb6f5ddaaab1b4b402">ug::gs_step_UR</a> (const Matrix_type &amp;A, Vector_type &amp;x, const Vector_type &amp;b)</td></tr>
<tr class="memdesc:gad30a4b301891ccfb6f5ddaaab1b4b402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a backward gauss-seidel-step, that is, solve on the upper right of A.  <a href="group__lib__algebra.html#gad30a4b301891ccfb6f5ddaaab1b4b402">More...</a><br /></td></tr>
<tr class="separator:gad30a4b301891ccfb6f5ddaaab1b4b402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaee05c7f21ad2d30fd7c7f74f978d97c"><td class="memTemplParams" colspan="2">template&lt;typename TSparseMatrix &gt; </td></tr>
<tr class="memitem:gaaee05c7f21ad2d30fd7c7f74f978d97c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__algebra.html#gaaee05c7f21ad2d30fd7c7f74f978d97c">ug::IsCloseToBoundary</a> (const TSparseMatrix &amp;A, size_t node, size_t distance)</td></tr>
<tr class="memdesc:gaaee05c7f21ad2d30fd7c7f74f978d97c"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets the neighborhood of a node in the connectivity graph of a <a class="el" href="classug_1_1_sparse_matrix.html" title="sparse matrix for big, variable sparse matrices.">SparseMatrix</a>.  <a href="group__lib__algebra.html#gaaee05c7f21ad2d30fd7c7f74f978d97c">More...</a><br /></td></tr>
<tr class="separator:gaaee05c7f21ad2d30fd7c7f74f978d97c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88a690cd89636d7b0a375b8652d5317b"><td class="memTemplParams" colspan="2">template&lt;typename TSparseMatrix &gt; </td></tr>
<tr class="memitem:ga88a690cd89636d7b0a375b8652d5317b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__algebra.html#ga88a690cd89636d7b0a375b8652d5317b">ug::IsDirichletRow</a> (const TSparseMatrix &amp;A, size_t i, size_t <a class="elRef" href="../plugins/group__small__strain__mechanics.html#ga8ff3c16c0fe165cbcce8e09e4eb4c61f">alpha</a>)</td></tr>
<tr class="memdesc:ga88a690cd89636d7b0a375b8652d5317b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates 'true', iff corresponding row is Dirichlet.  <a href="group__lib__algebra.html#ga88a690cd89636d7b0a375b8652d5317b">More...</a><br /></td></tr>
<tr class="separator:ga88a690cd89636d7b0a375b8652d5317b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1fce5c9f1b8df00c5218fb982db0b08"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__algebra.html#gac1fce5c9f1b8df00c5218fb982db0b08">ug::MapVector&lt; TValueType &gt;::MapVector</a> ()</td></tr>
<tr class="memdesc:gac1fce5c9f1b8df00c5218fb982db0b08"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor  <a href="group__lib__algebra.html#gac1fce5c9f1b8df00c5218fb982db0b08">More...</a><br /></td></tr>
<tr class="separator:gac1fce5c9f1b8df00c5218fb982db0b08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga704b8f35ffe170e1aed99562e462e5da"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__algebra.html#ga704b8f35ffe170e1aed99562e462e5da">ug::MapVector&lt; TValueType &gt;::MapVector</a> (size_t _length)</td></tr>
<tr class="memdesc:ga704b8f35ffe170e1aed99562e462e5da"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor with length  <a href="group__lib__algebra.html#ga704b8f35ffe170e1aed99562e462e5da">More...</a><br /></td></tr>
<tr class="separator:ga704b8f35ffe170e1aed99562e462e5da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65008c8fcc354658666ddc2452de8892"><td class="memTemplParams" colspan="2">template&lt;typename TSparseMatrix &gt; </td></tr>
<tr class="memitem:ga65008c8fcc354658666ddc2452de8892"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__algebra.html#ga65008c8fcc354658666ddc2452de8892">ug::MarkNeighbors</a> (const TSparseMatrix &amp;A, size_t node, size_t depth, std::vector&lt; bool &gt; &amp;bVisited)</td></tr>
<tr class="separator:ga65008c8fcc354658666ddc2452de8892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0a2f1ced18e6724fa6174a860f91143"><td class="memTemplParams" colspan="2">template&lt;typename matrix_type &gt; </td></tr>
<tr class="memitem:gae0a2f1ced18e6724fa6174a860f91143"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__algebra.html#gae0a2f1ced18e6724fa6174a860f91143">ug::MatAdd</a> (<a class="elRef" href="../plugins/namespaceug_1_1_demo_plugin.html#a10498f9373a78e4bcc071def1baee06d">matrix_type</a> &amp;M, <a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a> alpha1, const <a class="elRef" href="../plugins/namespaceug_1_1_demo_plugin.html#a10498f9373a78e4bcc071def1baee06d">matrix_type</a> &amp;A, <a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a> alpha2, const <a class="elRef" href="../plugins/namespaceug_1_1_demo_plugin.html#a10498f9373a78e4bcc071def1baee06d">matrix_type</a> &amp;B)</td></tr>
<tr class="memdesc:gae0a2f1ced18e6724fa6174a860f91143"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates M = A + B.  <a href="group__lib__algebra.html#gae0a2f1ced18e6724fa6174a860f91143">More...</a><br /></td></tr>
<tr class="separator:gae0a2f1ced18e6724fa6174a860f91143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9ebaabd22c0563f8ad332acb3d5634d"><td class="memTemplParams" colspan="2">template&lt;typename matrix_type &gt; </td></tr>
<tr class="memitem:gad9ebaabd22c0563f8ad332acb3d5634d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__algebra.html#gad9ebaabd22c0563f8ad332acb3d5634d">ug::MatAddNonDirichlet</a> (<a class="elRef" href="../plugins/namespaceug_1_1_demo_plugin.html#a10498f9373a78e4bcc071def1baee06d">matrix_type</a> &amp;M, <a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a> alpha1, const <a class="elRef" href="../plugins/namespaceug_1_1_demo_plugin.html#a10498f9373a78e4bcc071def1baee06d">matrix_type</a> &amp;A, <a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a> alpha2, const <a class="elRef" href="../plugins/namespaceug_1_1_demo_plugin.html#a10498f9373a78e4bcc071def1baee06d">matrix_type</a> &amp;B)</td></tr>
<tr class="memdesc:gad9ebaabd22c0563f8ad332acb3d5634d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates M = A + B.  <a href="group__lib__algebra.html#gad9ebaabd22c0563f8ad332acb3d5634d">More...</a><br /></td></tr>
<tr class="separator:gad9ebaabd22c0563f8ad332acb3d5634d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga900386dcaad538841307de03ccf59bae"><td class="memTemplParams" colspan="2">template&lt;typename vector_t , typename matrix_t &gt; </td></tr>
<tr class="memitem:ga900386dcaad538841307de03ccf59bae"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__algebra.html#ga900386dcaad538841307de03ccf59bae">ug::MatMultTransposedAdd</a> (vector_t &amp;dest, const <a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a> &amp;alpha1, const vector_t &amp;v1, const <a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a> &amp;beta1, const <a class="el" href="classug_1_1_map_sparse_matrix.html">MapSparseMatrix</a>&lt; matrix_t &gt; &amp;A1, const vector_t &amp;w1)</td></tr>
<tr class="memdesc:ga900386dcaad538841307de03ccf59bae"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculates dest = alpha1*v1 + beta1 * A1^T *w1;  <a href="group__lib__algebra.html#ga900386dcaad538841307de03ccf59bae">More...</a><br /></td></tr>
<tr class="separator:ga900386dcaad538841307de03ccf59bae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bedbec132c5ec0328fbfc2d1e4fe2b2"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lib__algebra.html#ga2bedbec132c5ec0328fbfc2d1e4fe2b2">ug::operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classug_1_1_algebra_type.html">AlgebraType</a> &amp;v)</td></tr>
<tr class="memdesc:ga2bedbec132c5ec0328fbfc2d1e4fe2b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">writes the Identifier to the output stream  <a href="group__lib__algebra.html#ga2bedbec132c5ec0328fbfc2d1e4fe2b2">More...</a><br /></td></tr>
<tr class="separator:ga2bedbec132c5ec0328fbfc2d1e4fe2b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga025e14dfd65cb4169e5955a59df0f5c5"><td class="memTemplParams" colspan="2">template&lt;typename TSparseMatrix &gt; </td></tr>
<tr class="memitem:ga025e14dfd65cb4169e5955a59df0f5c5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__algebra.html#ga025e14dfd65cb4169e5955a59df0f5c5">ug::ScaleRow</a> (TSparseMatrix &amp;A, size_t i, <a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a> fac)</td></tr>
<tr class="separator:ga025e14dfd65cb4169e5955a59df0f5c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1ebe41ef745874c5bd31f77ec75a94e"><td class="memTemplParams" colspan="2">template&lt;typename TSparseMatrix &gt; </td></tr>
<tr class="memitem:gaf1ebe41ef745874c5bd31f77ec75a94e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__algebra.html#gaf1ebe41ef745874c5bd31f77ec75a94e">ug::ScaleSparseMatrixCommon</a> (TSparseMatrix &amp;A, double d)</td></tr>
<tr class="separator:gaf1ebe41ef745874c5bd31f77ec75a94e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafff5f870be2d5be78c9488565d81abb7"><td class="memTemplParams" colspan="2">template&lt;typename TSparseMatrix , class TOStream &gt; </td></tr>
<tr class="memitem:gafff5f870be2d5be78c9488565d81abb7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__algebra.html#gafff5f870be2d5be78c9488565d81abb7">ug::SerializeMatrix</a> (TOStream &amp;buf, const TSparseMatrix &amp;A)</td></tr>
<tr class="separator:gafff5f870be2d5be78c9488565d81abb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0759e26a47118ebfb07eb9cab776e36"><td class="memTemplParams" colspan="2">template&lt;typename TSparseMatrix &gt; </td></tr>
<tr class="memitem:gad0759e26a47118ebfb07eb9cab776e36"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__algebra.html#gad0759e26a47118ebfb07eb9cab776e36">ug::SetCol</a> (TSparseMatrix &amp;A, size_t i, size_t <a class="elRef" href="../plugins/group__small__strain__mechanics.html#ga8ff3c16c0fe165cbcce8e09e4eb4c61f">alpha</a>, <a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a> val=0.0)</td></tr>
<tr class="separator:gad0759e26a47118ebfb07eb9cab776e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5386eec244c7ae060f05b81fc56674f4"><td class="memTemplParams" colspan="2">template&lt;typename TSparseMatrix &gt; </td></tr>
<tr class="memitem:ga5386eec244c7ae060f05b81fc56674f4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__algebra.html#ga5386eec244c7ae060f05b81fc56674f4">ug::SetDirichletRow</a> (TSparseMatrix &amp;A, const std::vector&lt; size_t &gt; vIndex)</td></tr>
<tr class="separator:ga5386eec244c7ae060f05b81fc56674f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01ed3ff58ad516c4d6ef6b761f54ba29"><td class="memTemplParams" colspan="2">template&lt;typename TSparseMatrix &gt; </td></tr>
<tr class="memitem:ga01ed3ff58ad516c4d6ef6b761f54ba29"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__algebra.html#ga01ed3ff58ad516c4d6ef6b761f54ba29">ug::SetDirichletRow</a> (TSparseMatrix &amp;A, size_t i)</td></tr>
<tr class="separator:ga01ed3ff58ad516c4d6ef6b761f54ba29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8517cb090f40832480c0dd692b0471b"><td class="memTemplParams" colspan="2">template&lt;typename TSparseMatrix &gt; </td></tr>
<tr class="memitem:gaa8517cb090f40832480c0dd692b0471b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__algebra.html#gaa8517cb090f40832480c0dd692b0471b">ug::SetDirichletRow</a> (TSparseMatrix &amp;A, size_t i, size_t <a class="elRef" href="../plugins/group__small__strain__mechanics.html#ga8ff3c16c0fe165cbcce8e09e4eb4c61f">alpha</a>)</td></tr>
<tr class="separator:gaa8517cb090f40832480c0dd692b0471b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab76efa38a80f081ba03e58e0a2385a38"><td class="memTemplParams" colspan="2">template&lt;typename TSparseMatrix &gt; </td></tr>
<tr class="memitem:gab76efa38a80f081ba03e58e0a2385a38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__algebra.html#gab76efa38a80f081ba03e58e0a2385a38">ug::SetRow</a> (TSparseMatrix &amp;A, size_t i, <a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a> val=0.0)</td></tr>
<tr class="separator:gab76efa38a80f081ba03e58e0a2385a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf276745a13b918814ff59f9a9607eca"><td class="memTemplParams" colspan="2">template&lt;typename TSparseMatrix &gt; </td></tr>
<tr class="memitem:gabf276745a13b918814ff59f9a9607eca"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__algebra.html#gabf276745a13b918814ff59f9a9607eca">ug::SetRow</a> (TSparseMatrix &amp;A, size_t i, size_t <a class="elRef" href="../plugins/group__small__strain__mechanics.html#ga8ff3c16c0fe165cbcce8e09e4eb4c61f">alpha</a>, <a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a> val=0.0)</td></tr>
<tr class="separator:gabf276745a13b918814ff59f9a9607eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae550d865ffb7730fde393ab5a1f83a4b"><td class="memTemplParams" colspan="2">template&lt;typename Matrix_type , typename Vector_type &gt; </td></tr>
<tr class="memitem:gae550d865ffb7730fde393ab5a1f83a4b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__algebra.html#gae550d865ffb7730fde393ab5a1f83a4b">ug::sgs_step</a> (const Matrix_type &amp;A, Vector_type &amp;c, const Vector_type &amp;d, const <a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a> relaxFactor)</td></tr>
<tr class="memdesc:gae550d865ffb7730fde393ab5a1f83a4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a symmetric gauss-seidel step. Using sgs_step within a preconditioner-scheme leads to the fact that we get the correction by successive inserting the already computed values of c in c = N * d, with c being the correction and d being the defect. N denotes the matrix of the second normal-form of a linear iteration scheme.  <a href="group__lib__algebra.html#gae550d865ffb7730fde393ab5a1f83a4b">More...</a><br /></td></tr>
<tr class="separator:gae550d865ffb7730fde393ab5a1f83a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2545fdc55efebdea7880c002b2aa3926"><td class="memTemplParams" colspan="2">template&lt;typename Matrix_type , typename Vector_type &gt; </td></tr>
<tr class="memitem:ga2545fdc55efebdea7880c002b2aa3926"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lib__algebra.html#ga2545fdc55efebdea7880c002b2aa3926">ug::sgs_step</a> (const Matrix_type &amp;A, Vector_type &amp;x, const Vector_type &amp;b)</td></tr>
<tr class="memdesc:ga2545fdc55efebdea7880c002b2aa3926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a symmetric gauss-seidel step.  <a href="group__lib__algebra.html#ga2545fdc55efebdea7880c002b2aa3926">More...</a><br /></td></tr>
<tr class="separator:ga2545fdc55efebdea7880c002b2aa3926"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Algebra Library. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga4526bb543d3223ad7d3b5425283c875c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4526bb543d3223ad7d3b5425283c875c">&#9670;&nbsp;</a></span>FORCE_CREATION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FORCE_CREATION&#160;&#160;&#160;volatile size_t ___never_happens___ = 0; <a class="el" href="parser_8cpp.html#ab3454b1e7e7c4c0b732dfeb74a0c040f">if</a>(___never_happens___)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>use this to force the creation of prsize_t routines or similar for use in gdb. </p>

</div>
</div>
<a id="gadf7f98346f6aa16fc71901289cab8412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf7f98346f6aa16fc71901289cab8412">&#9670;&nbsp;</a></span>UNUSED_VARIABLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UNUSED_VARIABLE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">var</td><td>)</td>
          <td>&#160;&#160;&#160;((void) var);</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>prevent unused variable-warnings </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga5e483791c37d11d54d2fa0ac352d3c90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e483791c37d11d54d2fa0ac352d3c90">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef TValueType <a class="el" href="classug_1_1_map_vector.html">ug::MapVector</a>&lt; TValueType &gt;::<a class="el" href="classug_1_1_vector.html#a3e2c7549c97f9debe2bf475f4e2682d7">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaf11c2aa408d075d1f6fa6e217f6afe13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf11c2aa408d075d1f6fa6e217f6afe13">&#9670;&nbsp;</a></span>vector_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classug_1_1_map_vector.html">MapVector</a>&lt;TValueType&gt; <a class="el" href="classug_1_1_map_vector.html">ug::MapVector</a>&lt; TValueType &gt;::<a class="el" href="classug_1_1_vector.html#adf635d690da8d8ede95532e42af14b32">vector_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga17d1221cff7d2e57c43bca8c2159b4b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17d1221cff7d2e57c43bca8c2159b4b7">&#9670;&nbsp;</a></span>AddMultiplyOf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ABC_type , typename A_type , typename B_type , typename C_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ug::AddMultiplyOf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sparsematrix__interface_8h.html#ab9e3f3f78158aa638cac857df2cfee9b">ABC_type</a> &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="sparsematrix__interface_8h.html#aeff4317cfbde1de13f86a24953f0d838">A_type</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="sparsematrix__interface_8h.html#a2311fc15e144ac7dd6261c83ffad242b">B_type</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const C_type &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilonTruncation</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates M += A*B*C. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>(in/out) Matrix M, M += A*B*C$ </td></tr>
    <tr><td class="paramname">A</td><td>(in) Matrix A </td></tr>
    <tr><td class="paramname">B</td><td>(in) Matrix B </td></tr>
    <tr><td class="paramname">C</td><td>(in) Matrix C</td></tr>
  </table>
  </dd>
</dl>
<p>Complete formula for calculating M=A*B*C: </p><p class="formulaDsp">
\[ M_{ij} += \sum_{kl} A_{ik} * B_{kl} * C_{lj} \]
</p>
 
<p class="reference">References <a class="el" href="namespaceug.html#adb7421dbbbe05ceb45d60d0770a48908">ug::AddMult()</a>, <a class="el" href="namespaceug.html#a27d325a963eea27d1ef3693f501f123e">ug::AssignMult()</a>, <a class="el" href="namespaceug.html#af526bb9c77c4ced2467ac7867ceb9a9e">ug::BlockNorm()</a>, <a class="el" href="profiler_8h.html#a3766fe91615588782ad5452a4d60ea5b">PROFILE_FUNC_GROUP</a>, <a class="el" href="group__ugbase__common.html#ga0b928ef153b78f1b5e025638cf28f841">UG_ASSERT</a>, and <a class="el" href="group__ugbase__common.html#ga43687df88af405f6ac7058dd3639993d">UG_THROW</a>.</p>

<p class="reference">Referenced by <a class="el" href="classug_1_1_assembled_multi_grid_cycle.html#a57f28a0010739772995248786292dc41">ug::AssembledMultiGridCycle&lt; TDomain, TAlgebra &gt;::init_rap_operator()</a>.</p>

</div>
</div>
<a id="ga9ee6d5fac7a8757239cd98ab67e747da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ee6d5fac7a8757239cd98ab67e747da">&#9670;&nbsp;</a></span>Axpy_transposedCommonSparseMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSparseMatrix , typename vector_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ug::Axpy_transposedCommonSparseMatrix </td>
          <td>(</td>
          <td class="paramtype">const TSparseMatrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_t &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a> &amp;&#160;</td>
          <td class="paramname"><em>alpha1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_t &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a> &amp;&#160;</td>
          <td class="paramname"><em>beta1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_t &amp;&#160;</td>
          <td class="paramname"><em>w1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceug.html#a4089b4f01719a1fb04b5564c36b78c8c">ug::MatMultTransposedAdd()</a>, and <a class="el" href="namespaceug.html#afd6199e8080b4899251f1318be6366d3">ug::VecScaleAssign()</a>.</p>

</div>
</div>
<a id="ga5cd3c946e0dc8412ff327804b1cdbe84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5cd3c946e0dc8412ff327804b1cdbe84">&#9670;&nbsp;</a></span>AxpyCommonSparseMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSparseMatrix , typename vector_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ug::AxpyCommonSparseMatrix </td>
          <td>(</td>
          <td class="paramtype">const TSparseMatrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_t &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a> &amp;&#160;</td>
          <td class="paramname"><em>alpha1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_t &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a> &amp;&#160;</td>
          <td class="paramname"><em>beta1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_t &amp;&#160;</td>
          <td class="paramname"><em>w1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceug.html#ad76b10ff156c4239abd30c333373f71c">ug::MatMult()</a>, <a class="el" href="namespaceug.html#a6f1addfcc15e261ec19eca7c425d5d79">ug::MatMultAdd()</a>, and <a class="el" href="namespaceug.html#afd6199e8080b4899251f1318be6366d3">ug::VecScaleAssign()</a>.</p>

</div>
</div>
<a id="ga5ff420bacd1e54330978db211ae8270f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ff420bacd1e54330978db211ae8270f">&#9670;&nbsp;</a></span>CheckDiagonalInvertible() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSparseMatrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ug::CheckDiagonalInvertible </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classug_1_1_parallel_matrix.html">ParallelMatrix</a>&lt; TSparseMatrix &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="group__pcl.html#ga944eeb7a85cdf4e14beba56bf4729e3e">pcl::AllProcsTrue()</a>, <a class="el" href="group__lib__algebra.html#ga27e3e71059c2ae350f51716e1ebd66ef">ug::CheckDiagonalInvertible()</a>, and <a class="el" href="classug_1_1_parallel_matrix.html#a63d7c09d03252eb4b52ac13b6d8d6227">ug::ParallelMatrix&lt; TMatrix &gt;::layouts()</a>.</p>

</div>
</div>
<a id="ga27e3e71059c2ae350f51716e1ebd66ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27e3e71059c2ae350f51716e1ebd66ef">&#9670;&nbsp;</a></span>CheckDiagonalInvertible() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSparseMatrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ug::CheckDiagonalInvertible </td>
          <td>(</td>
          <td class="paramtype">const TSparseMatrix &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceug.html#a112a567845bd04dcc1c3be005e4f516b">ug::GetInverse()</a>, and <a class="el" href="group__ugbase__common.html#ga849480b16e1d7c49266a92cd5db63942">UG_LOG</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__lib__algebra.html#ga5ff420bacd1e54330978db211ae8270f">ug::CheckDiagonalInvertible()</a>, and <a class="el" href="classug_1_1_gauss_seidel_base.html#ab9f60018ba3d3c2b0d8744e1f9cdb013">ug::GaussSeidelBase&lt; TAlgebra &gt;::preprocess()</a>.</p>

</div>
</div>
<a id="ga36194b79ab7b8fbc13e63016e598ffe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36194b79ab7b8fbc13e63016e598ffe7">&#9670;&nbsp;</a></span>CheckRowIterators()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSparseMatrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ug::CheckRowIterators </td>
          <td>(</td>
          <td class="paramtype">const TSparseMatrix &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="group__ugbase__common.html#ga849480b16e1d7c49266a92cd5db63942">UG_LOG</a>.</p>

<p class="reference">Referenced by <a class="el" href="classug_1_1_uzawa_base.html#a2fef8d151d84a04869fe1bb911abebaf">ug::UzawaBase&lt; TDomain, TAlgebra &gt;::extract_schur_update()</a>.</p>

</div>
</div>
<a id="ga72f2a1c3cfd4b8babafe92fc636a2d85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72f2a1c3cfd4b8babafe92fc636a2d85">&#9670;&nbsp;</a></span>CheckVectorInvertible() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ug::CheckVectorInvertible </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classug_1_1_parallel_vector.html">ParallelVector</a>&lt; TVector &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="group__pcl.html#ga944eeb7a85cdf4e14beba56bf4729e3e">pcl::AllProcsTrue()</a>, <a class="el" href="group__lib__algebra.html#ga2f054358e74488ce11850263ff62c6a1">ug::CheckVectorInvertible()</a>, and <a class="el" href="classug_1_1_parallel_vector.html#a69f2410c9a57408efb7869da93ba4149">ug::ParallelVector&lt; TVector &gt;::layouts()</a>.</p>

</div>
</div>
<a id="ga2f054358e74488ce11850263ff62c6a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f054358e74488ce11850263ff62c6a1">&#9670;&nbsp;</a></span>CheckVectorInvertible() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ug::CheckVectorInvertible </td>
          <td>(</td>
          <td class="paramtype">const TVector &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceug.html#a112a567845bd04dcc1c3be005e4f516b">ug::GetInverse()</a>, and <a class="el" href="group__ugbase__common.html#ga849480b16e1d7c49266a92cd5db63942">UG_LOG</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__lib__algebra.html#ga72f2a1c3cfd4b8babafe92fc636a2d85">ug::CheckVectorInvertible()</a>, and <a class="el" href="classug_1_1_jacobi.html#a21ae9838ef346913df755ecda1b24254">ug::Jacobi&lt; TAlgebra &gt;::preprocess()</a>.</p>

</div>
</div>
<a id="gaec865da3d07ee7bcf932b2ee5d3a8e77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec865da3d07ee7bcf932b2ee5d3a8e77">&#9670;&nbsp;</a></span>CreateAsMultiplyOf() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AB_type , typename A_type , typename B_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ug::CreateAsMultiplyOf </td>
          <td>(</td>
          <td class="paramtype">AB_type &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="sparsematrix__interface_8h.html#aeff4317cfbde1de13f86a24953f0d838">A_type</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="sparsematrix__interface_8h.html#a2311fc15e144ac7dd6261c83ffad242b">B_type</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates M = A*B. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>(out) Matrix M, M = A*B$ </td></tr>
    <tr><td class="paramname">A</td><td>(in) Matrix A </td></tr>
    <tr><td class="paramname">B</td><td>(in) Matrix B \( M_{ij} = \sum_k A_{ik} * B_{kj} \) For implementation details, see also CreateAsMultiplyOf(M, A, B, C). </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="namespaceug.html#adb7421dbbbe05ceb45d60d0770a48908">ug::AddMult()</a>, <a class="el" href="profiler_8h.html#a3766fe91615588782ad5452a4d60ea5b">PROFILE_FUNC_GROUP</a>, and <a class="el" href="group__ugbase__common.html#ga0b928ef153b78f1b5e025638cf28f841">UG_ASSERT</a>.</p>

</div>
</div>
<a id="ga9a6a6e8f6a05082613a1870297e7ea8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a6a6e8f6a05082613a1870297e7ea8a">&#9670;&nbsp;</a></span>CreateAsMultiplyOf() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ABC_type , typename A_type , typename B_type , typename C_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ug::CreateAsMultiplyOf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sparsematrix__interface_8h.html#ab9e3f3f78158aa638cac857df2cfee9b">ABC_type</a> &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="sparsematrix__interface_8h.html#aeff4317cfbde1de13f86a24953f0d838">A_type</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="sparsematrix__interface_8h.html#a2311fc15e144ac7dd6261c83ffad242b">B_type</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const C_type &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilonTruncation</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates M = A*B*C. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>(out) Matrix M, M = A*B*C$ </td></tr>
    <tr><td class="paramname">A</td><td>(in) Matrix A </td></tr>
    <tr><td class="paramname">B</td><td>(in) Matrix B </td></tr>
    <tr><td class="paramname">C</td><td>(in) Matrix C</td></tr>
  </table>
  </dd>
</dl>
<p>Complete formula for calculating M=A*B*C: </p><p class="formulaDsp">
\[ M_{ij} = \sum_{kl} A_{ik} * B_{kl} * C_{lj} \]
</p>
<p> Calculation is done on row-basis without a temporary BC or AB matrix. This has shown to be much faster than implementations with temporary matrices due to cache effects. We also added an improved way of storing the results of the calculation: when we go through connections of B and C and want to add the connection (i, j) to M, we need to know if this connection already exists. For this we have an array posInConnections, needs n=A.num_rows() memory. posInConnections[i]: index in the connections for current row (if not in row: -1) tried this also with std::map, but took 1511.53 ms instead of 393.972 ms searching in the connections array is also slower </p>

<p class="reference">References <a class="el" href="namespaceug.html#adb7421dbbbe05ceb45d60d0770a48908">ug::AddMult()</a>, <a class="el" href="namespaceug.html#a27d325a963eea27d1ef3693f501f123e">ug::AssignMult()</a>, <a class="el" href="namespaceug.html#af526bb9c77c4ced2467ac7867ceb9a9e">ug::BlockNorm()</a>, <a class="el" href="profiler_8h.html#a3766fe91615588782ad5452a4d60ea5b">PROFILE_FUNC_GROUP</a>, and <a class="el" href="group__ugbase__common.html#ga0b928ef153b78f1b5e025638cf28f841">UG_ASSERT</a>.</p>

</div>
</div>
<a id="gaef5b964b912673a04dd75cb4d6c06f3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef5b964b912673a04dd75cb4d6c06f3d">&#9670;&nbsp;</a></span>DeserializeMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSparseMatrix , class TIStream &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ug::DeserializeMatrix </td>
          <td>(</td>
          <td class="paramtype">TIStream &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSparseMatrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceug.html#a7b02f2134ee87750f975d6139828d69d">ug::Deserialize()</a>, and <a class="el" href="sparsematrix__interface_8h.html#a5c08a4de7d9b04993b920ac035074a35">num_connections()</a>.</p>

</div>
</div>
<a id="gaa0530b5446400873554834211f173970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0530b5446400873554834211f173970">&#9670;&nbsp;</a></span>diag_step()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix_type , typename Vector_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ug::diag_step </td>
          <td>(</td>
          <td class="paramtype">const Matrix_type &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector_type &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector_type &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a>&#160;</td>
          <td class="paramname"><em>damp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a jacobi-step. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Matrix \(A = D - L - R\) </td></tr>
    <tr><td class="paramname">c</td><td>will be \(c = N * d = D^{-1} d \) </td></tr>
    <tr><td class="paramname">d</td><td>the vector d. </td></tr>
    <tr><td class="paramname">damp</td><td>the damping factor </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="namespaceug.html#ae3578a2d24573312c4b9c35ebac65494">ug::InverseMatMult()</a>, and <a class="el" href="group__ugbase__common.html#ga0b928ef153b78f1b5e025638cf28f841">UG_ASSERT</a>.</p>

</div>
</div>
<a id="ga9ed0739a5937e2adeadf74439e187b01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ed0739a5937e2adeadf74439e187b01">&#9670;&nbsp;</a></span>GetDenseDoubleFromSparse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDenseType , typename TSparseMatrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t ug::GetDenseDoubleFromSparse </td>
          <td>(</td>
          <td class="paramtype">TDenseType &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TSparseMatrix &amp;&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="group__lib__algebra.html#ga04e1b55e8160dd71a6bde7371d655af4">ug::GetDoubleFromSparseBlock()</a>, and <a class="el" href="group__lib__algebra.html#ga066c012e62162f3245b680048351bee9">ug::GetDoubleSize()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classug_1_1_l_u.html#a4ff9c78e6634f7cf948ea6c63e2ef17d">ug::LU&lt; TAlgebra &gt;::init_dense()</a>.</p>

</div>
</div>
<a id="ga25765881ec0229d2f6b0a2cde2202f59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25765881ec0229d2f6b0a2cde2202f59">&#9670;&nbsp;</a></span>GetDenseFromSparse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSparseMatrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structug_1_1_dense_matrix_from_sparse_matrix.html">DenseMatrixFromSparseMatrix</a>&lt;TSparseMatrix&gt;::type&amp; ug::GetDenseFromSparse </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="structug_1_1_dense_matrix_from_sparse_matrix.html">DenseMatrixFromSparseMatrix</a>&lt; TSparseMatrix &gt;::type &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TSparseMatrix &amp;&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga04e1b55e8160dd71a6bde7371d655af4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04e1b55e8160dd71a6bde7371d655af4">&#9670;&nbsp;</a></span>GetDoubleFromSparseBlock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDoubleType , typename TSparseMatrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ug::GetDoubleFromSparseBlock </td>
          <td>(</td>
          <td class="paramtype">TDoubleType &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TSparseMatrix &amp;&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceug.html#a7405db84d59e2fb44d64fcaebca18454">ug::BlockRef()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__lib__algebra.html#ga9ed0739a5937e2adeadf74439e187b01">ug::GetDenseDoubleFromSparse()</a>, and <a class="el" href="group__lib__algebra.html#ga476f78fff8ccd5c4fd626f4925f3a67b">ug::GetDoubleSparseFromBlockSparse()</a>.</p>

</div>
</div>
<a id="ga066c012e62162f3245b680048351bee9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga066c012e62162f3245b680048351bee9">&#9670;&nbsp;</a></span>GetDoubleSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSparseMatrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t ug::GetDoubleSize </td>
          <td>(</td>
          <td class="paramtype">const TSparseMatrix &amp;&#160;</td>
          <td class="paramname"><em>S</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="group__ugbase__common.html#gaf0ce958f12c62aa44c231a700b830374">UG_COND_THROW</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__lib__algebra.html#ga9ed0739a5937e2adeadf74439e187b01">ug::GetDenseDoubleFromSparse()</a>, and <a class="el" href="group__lib__algebra.html#ga476f78fff8ccd5c4fd626f4925f3a67b">ug::GetDoubleSparseFromBlockSparse()</a>.</p>

</div>
</div>
<a id="ga476f78fff8ccd5c4fd626f4925f3a67b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga476f78fff8ccd5c4fd626f4925f3a67b">&#9670;&nbsp;</a></span>GetDoubleSparseFromBlockSparse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDoubleSparse , typename TSparseMatrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t ug::GetDoubleSparseFromBlockSparse </td>
          <td>(</td>
          <td class="paramtype">TDoubleSparse &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TSparseMatrix &amp;&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="group__lib__algebra.html#ga04e1b55e8160dd71a6bde7371d655af4">ug::GetDoubleFromSparseBlock()</a>, and <a class="el" href="group__lib__algebra.html#ga066c012e62162f3245b680048351bee9">ug::GetDoubleSize()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classug_1_1_i_external_solver.html#a2f75d3f467d7f62b0ad6d08bcd6cf636">ug::IExternalSolver&lt; TAlgebra &gt;::mat_preprocess()</a>, and <a class="el" href="classug_1_1_i_l_u_t_scalar_preconditioner.html#aa86a2242cc3ab137250d43e162b8415a">ug::ILUTScalarPreconditioner&lt; TAlgebra &gt;::preprocess()</a>.</p>

</div>
</div>
<a id="gaefc28813774a71719d96778603d26282"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaefc28813774a71719d96778603d26282">&#9670;&nbsp;</a></span>GetMaxConnections()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSparseMatrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t ug::GetMaxConnections </td>
          <td>(</td>
          <td class="paramtype">const TSparseMatrix &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns max number of non-zero connections in rows </p>

</div>
</div>
<a id="gae7dded838c7ae9cffe31c0aafb44e73a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7dded838c7ae9cffe31c0aafb44e73a">&#9670;&nbsp;</a></span>GetNeighborhood() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSparseMatrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ug::GetNeighborhood </td>
          <td>(</td>
          <td class="paramtype">const TSparseMatrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="group__lib__algebra.html#ga4282b51c1309076385f9ce7ffc1b6711">ug::GetNeighborhood()</a>, and <a class="el" href="profiler_8h.html#a3766fe91615588782ad5452a4d60ea5b">PROFILE_FUNC_GROUP</a>.</p>

</div>
</div>
<a id="ga4282b51c1309076385f9ce7ffc1b6711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4282b51c1309076385f9ce7ffc1b6711">&#9670;&nbsp;</a></span>GetNeighborhood() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSparseMatrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ug::GetNeighborhood </td>
          <td>(</td>
          <td class="paramtype">const TSparseMatrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>bVisited</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bResetVisitedFlags</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="group__lib__algebra.html#ga5f57b93a579bf6159d548139db9d955c">ug::GetNeighborhood_worker()</a>, and <a class="el" href="profiler_8h.html#a3766fe91615588782ad5452a4d60ea5b">PROFILE_FUNC_GROUP</a>.</p>

<p class="reference">Referenced by <a class="el" href="classug_1_1_block_gauss_seidel.html#a6e3a3f95542d7d7c0ff9c57bba8cf707">ug::BlockGaussSeidel&lt; TAlgebra, backward, forward &gt;::block_preprocess()</a>, <a class="el" href="classug_1_1_block_gauss_seidel_iterative.html#aa81666b0dfbe1c91aa84b95748507333">ug::BlockGaussSeidelIterative&lt; TAlgebra, backward, forward &gt;::block_preprocess()</a>, <a class="el" href="classug_1_1_sparse_block_gauss_seidel.html#a52254049ca65d41f7ccb882e8ff7780c">ug::SparseBlockGaussSeidel&lt; TAlgebra, backward, forward &gt;::block_preprocess()</a>, and <a class="el" href="group__lib__algebra.html#gae7dded838c7ae9cffe31c0aafb44e73a">ug::GetNeighborhood()</a>.</p>

</div>
</div>
<a id="ga5f57b93a579bf6159d548139db9d955c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f57b93a579bf6159d548139db9d955c">&#9670;&nbsp;</a></span>GetNeighborhood_worker()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSparseMatrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ug::GetNeighborhood_worker </td>
          <td>(</td>
          <td class="paramtype">const TSparseMatrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>bVisited</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="group__lib__algebra.html#ga4282b51c1309076385f9ce7ffc1b6711">ug::GetNeighborhood()</a>.</p>

</div>
</div>
<a id="gaecfee9ea1328c255c9198196bd41131e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaecfee9ea1328c255c9198196bd41131e">&#9670;&nbsp;</a></span>GetNeighborhoodHierachy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSparseMatrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ug::GetNeighborhoodHierachy </td>
          <td>(</td>
          <td class="paramtype">const TSparseMatrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; size_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="group__lib__algebra.html#gae929092009419957d34116aafb267787">ug::GetNeighborhoodHierachy()</a>.</p>

</div>
</div>
<a id="gae929092009419957d34116aafb267787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae929092009419957d34116aafb267787">&#9670;&nbsp;</a></span>GetNeighborhoodHierachy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSparseMatrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ug::GetNeighborhoodHierachy </td>
          <td>(</td>
          <td class="paramtype">const TSparseMatrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; size_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>bVisited</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bResetVisitedFlags</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="profiler_8h.html#a3766fe91615588782ad5452a4d60ea5b">PROFILE_FUNC_GROUP</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__lib__algebra.html#gaecfee9ea1328c255c9198196bd41131e">ug::GetNeighborhoodHierachy()</a>.</p>

</div>
</div>
<a id="gab1420754fc13975271b328dd56a08e85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1420754fc13975271b328dd56a08e85">&#9670;&nbsp;</a></span>GetNeighborhoodHierachy_worker()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSparseMatrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ug::GetNeighborhoodHierachy_worker </td>
          <td>(</td>
          <td class="paramtype">const TSparseMatrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxdepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; size_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>bVisited</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga6cc763c460b57eb9f5b2c6eb2fe2652f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6cc763c460b57eb9f5b2c6eb2fe2652f">&#9670;&nbsp;</a></span>GetNNZs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSparseMatrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t ug::GetNNZs </td>
          <td>(</td>
          <td class="paramtype">const TSparseMatrix &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the number of non-zeroes (!= number of connections) </p>

</div>
</div>
<a id="ga98970ee004dd8a19da9268ba651ffdce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98970ee004dd8a19da9268ba651ffdce">&#9670;&nbsp;</a></span>gs_step_LL() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix_type , typename Vector_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ug::gs_step_LL </td>
          <td>(</td>
          <td class="paramtype">const Matrix_type &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector_type &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector_type &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a>&#160;</td>
          <td class="paramname"><em>relaxFactor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gauss-Seidel-Iterations. </p>
<p>Here, iteration schemes of gauss-seidel-type are described for solving the linear equation </p><pre class="fragment">\f$ A * x = b.      A \in R^{nxn}, x \in R^n, b \in R^n \f$.
</pre><p> Most of the common linear iteration-methods base on the decomposition of A into its diagonal (D) and strict-upper(-U) and strict-lower part (-L),</p>
<p>\( A = D - L - U \).</p>
<p>Among others, W. Hackbusch ('Iterative Loesung grosser Gleichungssysteme'), distinguishes three different forms for describing a linear iteration scheme. The general 'first normal-form' of a linear iteration scheme takes the form</p>
<p>\( x^{m+1} = M * x^m + N * b \),</p>
<p>with some Matrices \( M \) and \( N \in R^{nxn} \). m denotes the iteration index. The general 'second normal-form' of a linear iteration scheme takes the form</p>
<p>\( x^{m+1} = x^m - N * (A * x^m - b) \).</p>
<p>Those linear iteration schemes, which can be represented by the second normal-form are the linear, consistent iteration schemes.</p>
<p>Introducing the correction \( c{m+1} := x^{m+1} - x^m \) and the defect \( d^m := b - A * x^m \) the second normal-form can be rewritten as</p>
<p>\( c = N * d \).</p>
<p>Below, methods for the (forward) Gauss-Seidel step, the backward Gauss-Seidel step and the symmetric Gauss-Seidel step are implemented ('gs_step_LL', 'gs_step_UR' resp. 'sgs_step'). The matrices of the second normal-form are</p>
<p>\( N = (D-L)^{-1}\) for the (forward) Gauss-Seidel step, \( N = (D-U)^{-1}\) for the backward Gauss-Seidel step and \( N = (D-u)^{-1}D(D-U)^{-1} \) for the symmetric Gauss-Seidel step.</p>
<p>References: </p><ul>
<li>
W. Hackbusch. Iterative Loesung grosser Gleichungssysteme </li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__lib__algebra.html#ga98970ee004dd8a19da9268ba651ffdce" title="Gauss-Seidel-Iterations.">gs_step_LL</a>, <a class="el" href="group__lib__algebra.html#ga6cec366add5874b559c21b14321e6a25" title="Performs a backward gauss-seidel-step, that is, solve on the upper right of A. Using gs_step_UR withi...">gs_step_UR</a>, <a class="el" href="group__lib__algebra.html#gae550d865ffb7730fde393ab5a1f83a4b" title="Performs a symmetric gauss-seidel step. Using sgs_step within a preconditioner-scheme leads to the fa...">sgs_step</a></dd></dl>
<p>Performs a forward gauss-seidel-step, that is, solve on the lower left of A. Using gs_step_LL within a preconditioner-scheme leads to the fact that we get the correction by successive inserting the already computed values of c in c = N * d, with c being the correction and d being the defect. N denotes the matrix of the second normal-form of a linear iteration scheme.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Matrix \(A = D - L - U\) </td></tr>
    <tr><td class="paramname">c</td><td><a class="el" href="classug_1_1_vector.html">Vector</a>. \( c = N * d = (D-L)^{-1} * d \) </td></tr>
    <tr><td class="paramname">d</td><td><a class="el" href="classug_1_1_vector.html">Vector</a> d. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__lib__algebra.html#ga6cec366add5874b559c21b14321e6a25" title="Performs a backward gauss-seidel-step, that is, solve on the upper right of A. Using gs_step_UR withi...">gs_step_UR</a>, <a class="el" href="group__lib__algebra.html#gae550d865ffb7730fde393ab5a1f83a4b" title="Performs a symmetric gauss-seidel step. Using sgs_step within a preconditioner-scheme leads to the fa...">sgs_step</a> </dd></dl>

<p class="reference">References <a class="el" href="namespaceug.html#ae3578a2d24573312c4b9c35ebac65494">ug::InverseMatMult()</a>, <a class="el" href="namespaceug.html#a6f1addfcc15e261ec19eca7c425d5d79">ug::MatMultAdd()</a>, and <a class="elRef" href="../plugins/_biogas_8lua.html#a9dda901d5ee6289370201a700f88e789">s</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__lib__algebra.html#gae550d865ffb7730fde393ab5a1f83a4b">ug::sgs_step()</a>, and <a class="el" href="classug_1_1_gauss_seidel.html#aef9592646b438ef64e423e27d99f3b38">ug::GaussSeidel&lt; TAlgebra &gt;::step()</a>.</p>

</div>
</div>
<a id="gaf89a853adfa2e1a00812ac4d9e160bbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf89a853adfa2e1a00812ac4d9e160bbd">&#9670;&nbsp;</a></span>gs_step_LL() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix_type , typename Vector_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ug::gs_step_LL </td>
          <td>(</td>
          <td class="paramtype">const Matrix_type &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector_type &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector_type &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a forward gauss-seidel-step, that is, solve on the lower left of A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Matrix \(A = D - L - U\) </td></tr>
    <tr><td class="paramname">x</td><td>will be \(x = (D-L)^{-1}b \) </td></tr>
    <tr><td class="paramname">b</td><td>the vector b. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__lib__algebra.html#ga6cec366add5874b559c21b14321e6a25" title="Performs a backward gauss-seidel-step, that is, solve on the upper right of A. Using gs_step_UR withi...">gs_step_UR</a>, <a class="el" href="group__lib__algebra.html#gae550d865ffb7730fde393ab5a1f83a4b" title="Performs a symmetric gauss-seidel step. Using sgs_step within a preconditioner-scheme leads to the fa...">sgs_step</a> </dd></dl>

<p class="reference">References <a class="el" href="namespaceug.html#ae3578a2d24573312c4b9c35ebac65494">ug::InverseMatMult()</a>, <a class="el" href="namespaceug.html#a6f1addfcc15e261ec19eca7c425d5d79">ug::MatMultAdd()</a>, and <a class="elRef" href="../plugins/_biogas_8lua.html#a9dda901d5ee6289370201a700f88e789">s</a>.</p>

</div>
</div>
<a id="ga6cec366add5874b559c21b14321e6a25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6cec366add5874b559c21b14321e6a25">&#9670;&nbsp;</a></span>gs_step_UR() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix_type , typename Vector_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ug::gs_step_UR </td>
          <td>(</td>
          <td class="paramtype">const Matrix_type &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector_type &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector_type &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a>&#160;</td>
          <td class="paramname"><em>relaxFactor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a backward gauss-seidel-step, that is, solve on the upper right of A. Using gs_step_UR within a preconditioner-scheme leads to the fact that we get the correction by successive inserting the already computed values of c in c = N * d, with c being the correction and d being the defect. N denotes the matrix of the second normal-form of a linear iteration scheme. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Matrix \(A = D - L - U\) </td></tr>
    <tr><td class="paramname">c</td><td>will be \(c = N * d = (D-U)^{-1} * d \) </td></tr>
    <tr><td class="paramname">d</td><td>the vector d. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__lib__algebra.html#ga98970ee004dd8a19da9268ba651ffdce" title="Gauss-Seidel-Iterations.">gs_step_LL</a>, <a class="el" href="group__lib__algebra.html#gae550d865ffb7730fde393ab5a1f83a4b" title="Performs a symmetric gauss-seidel step. Using sgs_step within a preconditioner-scheme leads to the fa...">sgs_step</a> </dd></dl>

<p class="reference">References <a class="el" href="namespaceug.html#ae3578a2d24573312c4b9c35ebac65494">ug::InverseMatMult()</a>, <a class="el" href="namespaceug.html#a6f1addfcc15e261ec19eca7c425d5d79">ug::MatMultAdd()</a>, and <a class="elRef" href="../plugins/_biogas_8lua.html#a9dda901d5ee6289370201a700f88e789">s</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__lib__algebra.html#gae550d865ffb7730fde393ab5a1f83a4b">ug::sgs_step()</a>, and <a class="el" href="classug_1_1_backward_gauss_seidel.html#af8f632059fa398882ba95b71351f4211">ug::BackwardGaussSeidel&lt; TAlgebra &gt;::step()</a>.</p>

</div>
</div>
<a id="gad30a4b301891ccfb6f5ddaaab1b4b402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad30a4b301891ccfb6f5ddaaab1b4b402">&#9670;&nbsp;</a></span>gs_step_UR() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix_type , typename Vector_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ug::gs_step_UR </td>
          <td>(</td>
          <td class="paramtype">const Matrix_type &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector_type &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector_type &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a backward gauss-seidel-step, that is, solve on the upper right of A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Matrix \(A = D - L - U\) </td></tr>
    <tr><td class="paramname">x</td><td>will be \(x = (D-U)^{-1}b \) </td></tr>
    <tr><td class="paramname">b</td><td>the vector b. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__lib__algebra.html#ga98970ee004dd8a19da9268ba651ffdce" title="Gauss-Seidel-Iterations.">gs_step_LL</a>, <a class="el" href="group__lib__algebra.html#gae550d865ffb7730fde393ab5a1f83a4b" title="Performs a symmetric gauss-seidel step. Using sgs_step within a preconditioner-scheme leads to the fa...">sgs_step</a> </dd></dl>

<p class="reference">References <a class="el" href="namespaceug.html#ae3578a2d24573312c4b9c35ebac65494">ug::InverseMatMult()</a>, <a class="el" href="namespaceug.html#a6f1addfcc15e261ec19eca7c425d5d79">ug::MatMultAdd()</a>, and <a class="elRef" href="../plugins/_biogas_8lua.html#a9dda901d5ee6289370201a700f88e789">s</a>.</p>

</div>
</div>
<a id="gaaee05c7f21ad2d30fd7c7f74f978d97c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaee05c7f21ad2d30fd7c7f74f978d97c">&#9670;&nbsp;</a></span>IsCloseToBoundary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSparseMatrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ug::IsCloseToBoundary </td>
          <td>(</td>
          <td class="paramtype">const TSparseMatrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>distance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gets the neighborhood of a node in the connectivity graph of a <a class="el" href="classug_1_1_sparse_matrix.html" title="sparse matrix for big, variable sparse matrices.">SparseMatrix</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>(in) Matrix A </td></tr>
    <tr><td class="paramname">node</td><td>(in) the node where to start </td></tr>
    <tr><td class="paramname">depth</td><td>(in) the depth of neighborhood. 0 = empty. </td></tr>
    <tr><td class="paramname">indices</td><td>(out) the indices of the neighbors </td></tr>
    <tr><td class="paramname">posInConnections</td><td>array to speed up computation. Has to be posInConnections[i] = 0 for all i=0..A.num_rows(). Can be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the node itself is only included if there is a connection from node to node.</dd></dl>
<p>determines if a node is close to a unconnected node in the connectivity graph of a <a class="el" href="classug_1_1_sparse_matrix.html" title="sparse matrix for big, variable sparse matrices.">SparseMatrix</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>(in) Matrix A </td></tr>
    <tr><td class="paramname">node</td><td>(in) the node where to start </td></tr>
    <tr><td class="paramname">distance</td><td>(in) up to which distance "close" is. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if there is a distance long path in graph(A) to an unconnected node, true. otherwise false. </dd></dl>

</div>
</div>
<a id="ga88a690cd89636d7b0a375b8652d5317b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88a690cd89636d7b0a375b8652d5317b">&#9670;&nbsp;</a></span>IsDirichletRow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSparseMatrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ug::IsDirichletRow </td>
          <td>(</td>
          <td class="paramtype">const TSparseMatrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates 'true', iff corresponding row is Dirichlet. </p>

<p class="reference">References <a class="elRef" href="../plugins/group__small__strain__mechanics.html#ga8ff3c16c0fe165cbcce8e09e4eb4c61f">alpha</a>, <a class="el" href="namespaceug.html#a7405db84d59e2fb44d64fcaebca18454">ug::BlockRef()</a>, and <a class="el" href="namespaceug.html#a0c4cb807306f9392d69c0ec416e3718b">ug::GetCols()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__lib__algebra.html#gad9ebaabd22c0563f8ad332acb3d5634d">ug::MatAddNonDirichlet()</a>.</p>

</div>
</div>
<a id="gac1fce5c9f1b8df00c5218fb982db0b08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1fce5c9f1b8df00c5218fb982db0b08">&#9670;&nbsp;</a></span>MapVector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classug_1_1_map_vector.html">ug::MapVector</a>&lt; TValueType &gt;::<a class="el" href="classug_1_1_map_vector.html">MapVector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructor </p>

</div>
</div>
<a id="ga704b8f35ffe170e1aed99562e462e5da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga704b8f35ffe170e1aed99562e462e5da">&#9670;&nbsp;</a></span>MapVector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classug_1_1_map_vector.html">ug::MapVector</a>&lt; TValueType &gt;::<a class="el" href="classug_1_1_map_vector.html">MapVector</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>_length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructor with length </p>

</div>
</div>
<a id="ga65008c8fcc354658666ddc2452de8892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65008c8fcc354658666ddc2452de8892">&#9670;&nbsp;</a></span>MarkNeighbors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSparseMatrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ug::MarkNeighbors </td>
          <td>(</td>
          <td class="paramtype">const TSparseMatrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>bVisited</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gae0a2f1ced18e6724fa6174a860f91143"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0a2f1ced18e6724fa6174a860f91143">&#9670;&nbsp;</a></span>MatAdd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename matrix_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ug::MatAdd </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="../plugins/namespaceug_1_1_demo_plugin.html#a10498f9373a78e4bcc071def1baee06d">matrix_type</a> &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a>&#160;</td>
          <td class="paramname"><em>alpha1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="../plugins/namespaceug_1_1_demo_plugin.html#a10498f9373a78e4bcc071def1baee06d">matrix_type</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a>&#160;</td>
          <td class="paramname"><em>alpha2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="../plugins/namespaceug_1_1_demo_plugin.html#a10498f9373a78e4bcc071def1baee06d">matrix_type</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates M = A + B. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>(out) Matrix M, M = A + B </td></tr>
    <tr><td class="paramname">A</td><td>(in) Matrix A </td></tr>
    <tr><td class="paramname">B</td><td>(in) Matrix B note: A and/or B may be equal to M. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="profiler_8h.html#a3766fe91615588782ad5452a4d60ea5b">PROFILE_FUNC_GROUP</a>, and <a class="el" href="group__ugbase__common.html#ga0b928ef153b78f1b5e025638cf28f841">UG_ASSERT</a>.</p>

</div>
</div>
<a id="gad9ebaabd22c0563f8ad332acb3d5634d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9ebaabd22c0563f8ad332acb3d5634d">&#9670;&nbsp;</a></span>MatAddNonDirichlet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename matrix_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ug::MatAddNonDirichlet </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="../plugins/namespaceug_1_1_demo_plugin.html#a10498f9373a78e4bcc071def1baee06d">matrix_type</a> &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a>&#160;</td>
          <td class="paramname"><em>alpha1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="../plugins/namespaceug_1_1_demo_plugin.html#a10498f9373a78e4bcc071def1baee06d">matrix_type</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a>&#160;</td>
          <td class="paramname"><em>alpha2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="../plugins/namespaceug_1_1_demo_plugin.html#a10498f9373a78e4bcc071def1baee06d">matrix_type</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates M = A + B. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>(out) Matrix M, M = A + B </td></tr>
    <tr><td class="paramname">A</td><td>(in) Matrix A </td></tr>
    <tr><td class="paramname">B</td><td>(in) Matrix B note: A and/or B may be equal to M. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="elRef" href="../plugins/group__small__strain__mechanics.html#ga8ff3c16c0fe165cbcce8e09e4eb4c61f">alpha</a>, <a class="el" href="namespaceug.html#a7405db84d59e2fb44d64fcaebca18454">ug::BlockRef()</a>, <a class="el" href="namespaceug.html#ab61e5d284ebd622341c2475f85ccec6c">ug::GetRows()</a>, <a class="el" href="group__lib__algebra.html#ga88a690cd89636d7b0a375b8652d5317b">ug::IsDirichletRow()</a>, <a class="el" href="profiler_8h.html#a3766fe91615588782ad5452a4d60ea5b">PROFILE_FUNC_GROUP</a>, and <a class="el" href="group__ugbase__common.html#ga0b928ef153b78f1b5e025638cf28f841">UG_ASSERT</a>.</p>

</div>
</div>
<a id="ga900386dcaad538841307de03ccf59bae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga900386dcaad538841307de03ccf59bae">&#9670;&nbsp;</a></span>MatMultTransposedAdd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vector_t , typename matrix_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ug::MatMultTransposedAdd </td>
          <td>(</td>
          <td class="paramtype">vector_t &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a> &amp;&#160;</td>
          <td class="paramname"><em>alpha1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_t &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a> &amp;&#160;</td>
          <td class="paramname"><em>beta1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classug_1_1_map_sparse_matrix.html">MapSparseMatrix</a>&lt; matrix_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>A1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_t &amp;&#160;</td>
          <td class="paramname"><em>w1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>calculates dest = alpha1*v1 + beta1 * A1^T *w1; </p>

<p class="reference">References <a class="el" href="classug_1_1_map_sparse_matrix.html#a2493e60117063664bb32d45e78d87d16">ug::MapSparseMatrix&lt; TValueType &gt;::axpy_transposed()</a>.</p>

</div>
</div>
<a id="ga2bedbec132c5ec0328fbfc2d1e4fe2b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2bedbec132c5ec0328fbfc2d1e4fe2b2">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; ug::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classug_1_1_algebra_type.html">AlgebraType</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>writes the Identifier to the output stream </p>

<p class="reference">References <a class="el" href="classug_1_1_algebra_type.html#a340e0522dbcf9a7d5351c5e397ac5ab3">ug::AlgebraType::blocksize()</a>, <a class="el" href="classug_1_1_algebra_type.html#ab3a264146f087f78d70761091f5520e8a5a9452f6c24214482c886dd91f8aa847">ug::AlgebraType::CPU</a>, <a class="el" href="classug_1_1_algebra_type.html#ab3a264146f087f78d70761091f5520e8aafd37365290e1ccab251d25ff1f4d8fe">ug::AlgebraType::GPU</a>, <a class="el" href="classug_1_1_algebra_type.html#ae7dcf988eee29454b91c76c09c797019">ug::AlgebraType::type()</a>, and <a class="el" href="classug_1_1_algebra_type.html#a2eceed97255bb8287b6513c67488d701ab062a81643e4a4eb85ebb0cdb05b3f95">ug::AlgebraType::VariableBlockSize</a>.</p>

</div>
</div>
<a id="ga025e14dfd65cb4169e5955a59df0f5c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga025e14dfd65cb4169e5955a59df0f5c5">&#9670;&nbsp;</a></span>ScaleRow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSparseMatrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ug::ScaleRow </td>
          <td>(</td>
          <td class="paramtype">TSparseMatrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a>&#160;</td>
          <td class="paramname"><em>fac</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>scales (block-)row i. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>(in) Matrix A </td></tr>
    <tr><td class="paramname">i</td><td>(in) row to scales </td></tr>
    <tr><td class="paramname">fac</td><td>(in) Scaling factor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf1ebe41ef745874c5bd31f77ec75a94e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1ebe41ef745874c5bd31f77ec75a94e">&#9670;&nbsp;</a></span>ScaleSparseMatrixCommon()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSparseMatrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ug::ScaleSparseMatrixCommon </td>
          <td>(</td>
          <td class="paramtype">TSparseMatrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gafff5f870be2d5be78c9488565d81abb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafff5f870be2d5be78c9488565d81abb7">&#9670;&nbsp;</a></span>SerializeMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSparseMatrix , class TOStream &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ug::SerializeMatrix </td>
          <td>(</td>
          <td class="paramtype">TOStream &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TSparseMatrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="sparsematrix__interface_8h.html#a5c08a4de7d9b04993b920ac035074a35">num_connections()</a>, and <a class="el" href="namespaceug.html#ab254d4e3f5be2b03179816c20e4d3464">ug::Serialize()</a>.</p>

</div>
</div>
<a id="gad0759e26a47118ebfb07eb9cab776e36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0759e26a47118ebfb07eb9cab776e36">&#9670;&nbsp;</a></span>SetCol()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSparseMatrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ug::SetCol </td>
          <td>(</td>
          <td class="paramtype">TSparseMatrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a>&#160;</td>
          <td class="paramname"><em>val</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>set value for col for entry (i,alpha). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>(in) Matrix A </td></tr>
    <tr><td class="paramname">i</td><td>(in) col to set </td></tr>
    <tr><td class="paramname">alpha</td><td>the alpha index </td></tr>
    <tr><td class="paramname">val</td><td>the value to be set </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="elRef" href="../plugins/group__small__strain__mechanics.html#ga8ff3c16c0fe165cbcce8e09e4eb4c61f">alpha</a>, <a class="el" href="namespaceug.html#a7405db84d59e2fb44d64fcaebca18454">ug::BlockRef()</a>, and <a class="el" href="namespaceug.html#ab61e5d284ebd622341c2475f85ccec6c">ug::GetRows()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classug_1_1_i_obstacle_constraint.html#a603d97dee330de28e6be1af9fee47351">ug::IObstacleConstraint&lt; TDomain, TAlgebra &gt;::adjust_restriction()</a>.</p>

</div>
</div>
<a id="ga5386eec244c7ae060f05b81fc56674f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5386eec244c7ae060f05b81fc56674f4">&#9670;&nbsp;</a></span>SetDirichletRow() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSparseMatrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ug::SetDirichletRow </td>
          <td>(</td>
          <td class="paramtype">TSparseMatrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt;&#160;</td>
          <td class="paramname"><em>vIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>set Dirichlet row for block i. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>Matrix A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vIndex</td><td>vector of row indices to set dirichlet, that is A(i,i) = 1.0, A(i,k) = 0.0 for all k != i. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="group__ugbase__common.html#ga0b928ef153b78f1b5e025638cf28f841">UG_ASSERT</a>.</p>

</div>
</div>
<a id="ga01ed3ff58ad516c4d6ef6b761f54ba29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01ed3ff58ad516c4d6ef6b761f54ba29">&#9670;&nbsp;</a></span>SetDirichletRow() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSparseMatrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ug::SetDirichletRow </td>
          <td>(</td>
          <td class="paramtype">TSparseMatrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>set Dirichlet row for block i. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>(in) Matrix A </td></tr>
    <tr><td class="paramname">i</td><td>(in) row to set dirichlet, that is A(i,i) = 1.0, A(i,k) = 0.0 for all k != i. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa8517cb090f40832480c0dd692b0471b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8517cb090f40832480c0dd692b0471b">&#9670;&nbsp;</a></span>SetDirichletRow() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSparseMatrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ug::SetDirichletRow </td>
          <td>(</td>
          <td class="paramtype">TSparseMatrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>set Dirichlet row for entry (i,alpha). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>(in) Matrix A </td></tr>
    <tr><td class="paramname">i</td><td>(in) row to set dirichlet, that is A(i,i)(alpha, alpha) = 1.0, A(i,k)(alpha, beta) = 0.0 for all (k, beta) != (i, alpha)$. </td></tr>
    <tr><td class="paramname">alpha</td><td>the alpha index </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="elRef" href="../plugins/group__small__strain__mechanics.html#ga8ff3c16c0fe165cbcce8e09e4eb4c61f">alpha</a>, <a class="el" href="namespaceug.html#a7405db84d59e2fb44d64fcaebca18454">ug::BlockRef()</a>, and <a class="el" href="namespaceug.html#a0c4cb807306f9392d69c0ec416e3718b">ug::GetCols()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classug_1_1_generate_overlap_class.html#afeb968e61f931b7471528449fc529455">ug::GenerateOverlapClass&lt; matrix_type &gt;::calculate()</a>, <a class="el" href="classug_1_1_i_external_solver.html#a2f75d3f467d7f62b0ad6d08bcd6cf636">ug::IExternalSolver&lt; TAlgebra &gt;::mat_preprocess()</a>, <a class="el" href="classug_1_1_feti_layouts.html#a300b07e57da87f5289999687d49012f6">ug::FetiLayouts&lt; TAlgebra &gt;::mat_set_dirichlet_on_dual()</a>, <a class="el" href="classug_1_1_feti_layouts.html#a613c961c0b01a0117fb67f4881385b42">ug::FetiLayouts&lt; TAlgebra &gt;::mat_set_dirichlet_on_primal()</a>, <a class="el" href="classug_1_1_com_pol___mat_create_overlap.html#a53b2038293353f028dbe2b9223f96f24">ug::ComPol_MatCreateOverlap&lt; TMatrix &gt;::post_process()</a>, <a class="el" href="classug_1_1_i_l_u_t_scalar_preconditioner.html#aa86a2242cc3ab137250d43e162b8415a">ug::ILUTScalarPreconditioner&lt; TAlgebra &gt;::preprocess()</a>, <a class="el" href="classug_1_1_i_block_jacobi_preconditioner.html#a634ba3f20a70d90a7432180bf5c1c10a">ug::IBlockJacobiPreconditioner&lt; TAlgebra &gt;::preprocess()</a>, <a class="el" href="classug_1_1_gauss_seidel_base.html#ab9f60018ba3d3c2b0d8744e1f9cdb013">ug::GaussSeidelBase&lt; TAlgebra &gt;::preprocess()</a>, <a class="el" href="classug_1_1_i_l_u.html#a5952ebace9335bc3c223eec6cb6fe9dd">ug::ILU&lt; TAlgebra &gt;::preprocess()</a>, <a class="el" href="classug_1_1_vanka.html#af90336245409999a9f3cc8d05cad0042">ug::Vanka&lt; TAlgebra &gt;::preprocess()</a>, <a class="el" href="classug_1_1_diag_vanka.html#a50a9ca10e12f95878f8774f2d72bda16">ug::DiagVanka&lt; TAlgebra &gt;::preprocess()</a>, <a class="el" href="classug_1_1_component_gauss_seidel.html#a7700e11a3cfebe5cf541507688dad671">ug::ComponentGaussSeidel&lt; TDomain, TAlgebra &gt;::preprocess()</a>, <a class="el" href="classug_1_1_uzawa_base.html#a4f757b4fa1d90ef9a67ad63663668345">ug::UzawaBase&lt; TDomain, TAlgebra &gt;::preprocess()</a>, <a class="el" href="classug_1_1_line_gauss_seidel.html#ac9de326bb809a63b88512fee127fdc50">ug::LineGaussSeidel&lt; TDomain, TAlgebra &gt;::preprocess()</a>, <a class="el" href="classug_1_1_line_vanka.html#a32e22bc7e3d58a17fd0a1998e81981d2">ug::LineVanka&lt; TDomain, TAlgebra &gt;::preprocess()</a>, <a class="el" href="classug_1_1_i_l_u_t_preconditioner.html#a878bfddd48692c49aa517d9bd3e2465a">ug::ILUTPreconditioner&lt; TAlgebra &gt;::preprocess_mat()</a>, <a class="el" href="classug_1_1_assembling_tuner.html#ace3939609b7f85af70ac278d675b8a71">ug::AssemblingTuner&lt; TAlgebra &gt;::set_dirichlet_row()</a>, <a class="el" href="classug_1_1_active_set.html#adf69c2970f95254fce1d5331a0f13ade">ug::ActiveSet&lt; TDomain, TAlgebra &gt;::set_dirichlet_rows()</a>, and <a class="el" href="namespaceug.html#a62305680f25e1c0e631dd96ec638e7e8">ug::SetDirichletRow()</a>.</p>

</div>
</div>
<a id="gab76efa38a80f081ba03e58e0a2385a38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab76efa38a80f081ba03e58e0a2385a38">&#9670;&nbsp;</a></span>SetRow() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSparseMatrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ug::SetRow </td>
          <td>(</td>
          <td class="paramtype">TSparseMatrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a>&#160;</td>
          <td class="paramname"><em>val</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>set value for (block-)row i. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>(in) Matrix A </td></tr>
    <tr><td class="paramname">i</td><td>(in) row to scales </td></tr>
    <tr><td class="paramname">val</td><td>(in) value to be set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabf276745a13b918814ff59f9a9607eca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf276745a13b918814ff59f9a9607eca">&#9670;&nbsp;</a></span>SetRow() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSparseMatrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ug::SetRow </td>
          <td>(</td>
          <td class="paramtype">TSparseMatrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a>&#160;</td>
          <td class="paramname"><em>val</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>set value for row for entry (i,alpha). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>(in) Matrix A </td></tr>
    <tr><td class="paramname">i</td><td>(in) row to set </td></tr>
    <tr><td class="paramname">alpha</td><td>the alpha index </td></tr>
    <tr><td class="paramname">val</td><td>the value to be set </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="elRef" href="../plugins/group__small__strain__mechanics.html#ga8ff3c16c0fe165cbcce8e09e4eb4c61f">alpha</a>, <a class="el" href="namespaceug.html#a7405db84d59e2fb44d64fcaebca18454">ug::BlockRef()</a>, and <a class="el" href="namespaceug.html#a0c4cb807306f9392d69c0ec416e3718b">ug::GetCols()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classug_1_1_dirichlet_boundary.html#a131968ccc83859d43ef5ae92b398012f">ug::DirichletBoundary&lt; TDomain, TAlgebra &gt;::adjust_prolongation()</a>, <a class="el" href="classug_1_1_sym_p1_constraints.html#a1a71c47313d5577252aa46150524a5cf">ug::SymP1Constraints&lt; TDomain, TAlgebra &gt;::adjust_prolongation()</a>, <a class="el" href="classug_1_1_one_side_p1_constraints.html#a49048ccd2fadb3c5c02f8c0f044039d8">ug::OneSideP1Constraints&lt; TDomain, TAlgebra &gt;::adjust_prolongation()</a>, <a class="el" href="classug_1_1_dirichlet_boundary.html#aa19b0b7b886602af812562a08bd4a72e">ug::DirichletBoundary&lt; TDomain, TAlgebra &gt;::adjust_restriction()</a>, <a class="el" href="classug_1_1_assembled_multi_grid_cycle.html#acb0a2715676274e76457108c6bdcfadb">ug::AssembledMultiGridCycle&lt; TDomain, TAlgebra &gt;::assemble_rim_cpl()</a>, <a class="el" href="namespaceug.html#a5a7c14d8048fa08e0da7c38a561cb03b">ug::SetInterpolation()</a>, <a class="el" href="namespaceug.html#a564920a0e479cd00c95deb95379f1317">ug::SetRow()</a>, and <a class="el" href="classug_1_1_i_proj_gauss_seidel.html#a533b2d70a25092525cf094b869ba3ce3">ug::IProjGaussSeidel&lt; TDomain, TAlgebra &gt;::truncateMat()</a>.</p>

</div>
</div>
<a id="gae550d865ffb7730fde393ab5a1f83a4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae550d865ffb7730fde393ab5a1f83a4b">&#9670;&nbsp;</a></span>sgs_step() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix_type , typename Vector_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ug::sgs_step </td>
          <td>(</td>
          <td class="paramtype">const Matrix_type &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector_type &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector_type &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a>&#160;</td>
          <td class="paramname"><em>relaxFactor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a symmetric gauss-seidel step. Using sgs_step within a preconditioner-scheme leads to the fact that we get the correction by successive inserting the already computed values of c in c = N * d, with c being the correction and d being the defect. N denotes the matrix of the second normal-form of a linear iteration scheme. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Matrix \(A = D - L - R\) </td></tr>
    <tr><td class="paramname">c</td><td>will be \(c = N * d = (D-U)^{-1} D (D-L)^{-1} d \) </td></tr>
    <tr><td class="paramname">d</td><td>the vector d. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__lib__algebra.html#ga98970ee004dd8a19da9268ba651ffdce" title="Gauss-Seidel-Iterations.">gs_step_LL</a>, <a class="el" href="group__lib__algebra.html#ga98970ee004dd8a19da9268ba651ffdce" title="Gauss-Seidel-Iterations.">gs_step_LL</a> </dd></dl>

<p class="reference">References <a class="el" href="group__lib__algebra.html#ga98970ee004dd8a19da9268ba651ffdce">ug::gs_step_LL()</a>, <a class="el" href="group__lib__algebra.html#ga6cec366add5874b559c21b14321e6a25">ug::gs_step_UR()</a>, <a class="el" href="namespaceug.html#ad76b10ff156c4239abd30c333373f71c">ug::MatMult()</a>, and <a class="elRef" href="../plugins/_biogas_8lua.html#a9dda901d5ee6289370201a700f88e789">s</a>.</p>

<p class="reference">Referenced by <a class="el" href="classug_1_1_symmetric_gauss_seidel.html#a4adccca33326a7ab759ddef58dadfde6">ug::SymmetricGaussSeidel&lt; TAlgebra &gt;::step()</a>.</p>

</div>
</div>
<a id="ga2545fdc55efebdea7880c002b2aa3926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2545fdc55efebdea7880c002b2aa3926">&#9670;&nbsp;</a></span>sgs_step() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix_type , typename Vector_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ug::sgs_step </td>
          <td>(</td>
          <td class="paramtype">const Matrix_type &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector_type &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector_type &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a symmetric gauss-seidel step. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Matrix \(A = D - L - R\) </td></tr>
    <tr><td class="paramname">x</td><td>will be \(x = (D-U)^{-1} D (D-L)^{-1} b \) </td></tr>
    <tr><td class="paramname">b</td><td>the vector b. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__lib__algebra.html#ga98970ee004dd8a19da9268ba651ffdce" title="Gauss-Seidel-Iterations.">gs_step_LL</a>, <a class="el" href="group__lib__algebra.html#ga98970ee004dd8a19da9268ba651ffdce" title="Gauss-Seidel-Iterations.">gs_step_LL</a> </dd></dl>

<p class="reference">References <a class="el" href="group__lib__algebra.html#ga98970ee004dd8a19da9268ba651ffdce">ug::gs_step_LL()</a>, <a class="el" href="group__lib__algebra.html#ga6cec366add5874b559c21b14321e6a25">ug::gs_step_UR()</a>, and <a class="el" href="namespaceug.html#ad76b10ff156c4239abd30c333373f71c">ug::MatMult()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Mar 13 2023 01:06:05 for ug4 by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
